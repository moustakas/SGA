#!/usr/bin/env python
"""MPI wrapper for the Siena Galaxy Atlas 2025 project.

salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive
SGA2025-shifter
source /global/homes/i/ioannis/code/SGA/bin/SGA2025/SGA2025-env

SGA2025-mpi --build-refcat

# (1) nice isolated spiral; (2) second isolated spiral; (3) 2-member
# group; (4) giant and dwarf group;

SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="WISEA J125450.10+261929.6"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="KUG 1247+260"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="III Zw 040 NOTES02"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="UGC 05688"

SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-test1

# LVD tests
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd --debug --mp=8 --d25max=3 --coadds
SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd [--lvd-resolved] [--lvd-fixgeo] [--lvd-forcepsf]

In production:

salloc -N 2 -C cpu -A m3592 -t 04:00:00 --qos interactive --image=docker:legacysurvey/sga:0.4
srun --ntasks=8 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
  SGA2025-mpi --coadds --mp=32


"""
import os, time, sys, pdb
import numpy as np
import astropy.units as u
from astropy.coordinates import SkyCoord
from astropy.table import Table

from SGA.ellipse import ELLIPSEMODE
from SGA.logger import (log, LOGFMT, hook_legacypipe_and_root,
                        unhook_legacypipe_and_root,
                        setup_logging)


def get_logfile(galaxy, galaxydir, stagesuffix):
    from SGA.io import backup_filename
    logfile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}.log')
    backup_filename(logfile)
    return logfile


def restore_logger(fh=None, debug=False):
    import logging

    if fh is not None:
        unhook_legacypipe_and_root(fh, restore_console=True, debug=debug)

        # detach from both loggers
        logging.getLogger('py.warnings').removeHandler(fh)
        log.removeHandler(fh)
        fh.close()

        # reattach console logging to stdout
        have_console = any((type(h) is logging.StreamHandler) and
                           getattr(h, "stream", None) is sys.stdout
                           for h in log.handlers)
        if not have_console:
            ch = logging.StreamHandler(sys.stdout)
            ch.setLevel(logging.INFO)
            ch.setFormatter(LOGFMT)
            log.addHandler(ch)

def skip_ellipse_or_not(row):
    # RESOLVED - nothing to do
    if row['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED'] != 0:
        #log.info(f'No ellipse-fitting needed for RESOLVED source {galaxydir}/{galaxy}')
        return True
    else:
        return False


def done(galaxy, galaxydir, err, stagesuffix, fh=None, debug=False):

    donefile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}')
    if err == 0:
        log.warning(f'Problem processing {galaxydir}/{galaxy}; please check the log file.')
        donefile = f'{donefile}.isfail'
    else:
        donefile = f'{donefile}.isdone'

    # equivalent to 'touch'
    open(donefile, 'w').close()

    # restore the logger
    restore_logger(fh=fh, debug=debug)

def main():
    """Top-level wrapper.

    """
    from legacypipe.runs import get_survey

    from SGA.coadds import RUNS, BANDS, RELEASE
    from SGA.mpi import mpi_args
    from SGA.io import set_legacysurvey_dir
    from SGA.SGA import (RACOLUMN, DECCOLUMN, DIAMCOLUMN, SAMPLE, REFCAT,
                         sga_dir, sga_data_dir, sga_html_dir, SGA_version,
                         read_sample, missing_files, get_galaxy_galaxydir,
                         get_radius_mosaic)

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank, size = comm.rank, comm.size
    except:
        comm = None
        rank, size = 0, 1

    args = mpi_args()
    set_legacysurvey_dir(args.region, rank=rank)

    #if args.lvd:
    #    no_groups = True
    #else:
    #    no_groups = args.no_groups
    no_groups = args.no_groups

    if no_groups:
        RACOLUMN = 'RA'
        DECCOLUMN = 'DEC'
        DIAMCOLUMN = 'DIAM'

    basedir = sga_dir()
    datadir = args.datadir if args.datadir is not None else sga_data_dir()
    htmldir = args.htmldir if args.htmldir is not None else sga_html_dir()

    os.environ['SGA_DATA_DIR'] = os.path.abspath(datadir)
    os.environ['SGA_HTML_DIR'] = os.path.abspath(htmldir)

    run = RUNS[args.region]
    release = RELEASE[args.region]
    bands = BANDS[args.region]

    # Read and broadcast the sample.
    bricks = None
    if rank == 0:
        if not os.path.isdir(datadir):
            os.makedirs(datadir, exist_ok=True)
        if not os.path.isdir(htmldir):
            os.makedirs(htmldir, exist_ok=True)

        log.info(f'$SGA_DIR={basedir}')
        log.info(f'$SGA_DATA_DIR={datadir}')
        log.info(f'$SGA_HTML_DIR={htmldir}')
        log.info(f'$LARGEGALAXIES_CAT={os.getenv("LARGEGALAXIES_CAT")}')

        sga_version = SGA_version(parent=True)
        refcatfile = os.path.join(basedir, 'sample', f'SGA2025-beta-parent-refcat-{sga_version}.fits')
        kdrefcatfile = refcatfile.replace('.fits', '.kd.fits')
        if not os.getenv("LARGEGALAXIES_CAT"):
            msg = f'{os.getenv("LARGEGALAXIES_CAT")} not found!'
            log.critical(msg)
            raise ValueError(msg)
        else:
            if kdrefcatfile != os.getenv("LARGEGALAXIES_CAT"):
                if kdrefcatfile.replace('/global/', '/dvs_ro/') != os.getenv("LARGEGALAXIES_CAT"):
                    msg = f'Mismatch between $LARGEGALAXIES_CAT and {kdrefcatfile}!'
                    log.warning(msg)
                    #log.critical(msg)
                    #raise ValueError(msg)


        if args.build_refcat:
            region = None
        else:
            region = args.region

        sample, fullsample = read_sample(
            first=args.first, last=args.last, mindiam=args.mindiam,
            maxdiam=args.maxdiam, minmult=args.minmult, maxmult=args.maxmult,
            version=args.version, galaxylist=args.galaxylist,
            no_groups=no_groups, lvd=args.lvd, wisesize=args.wisesize,
            region=region, test_bricks=args.test_bricks, verbose=args.verbose)
        if len(fullsample) > 0:
            # pre-compute the SkyCoord object
            c_fullsample = SkyCoord(fullsample[RACOLUMN]*u.deg, fullsample[DECCOLUMN]*u.deg)
        else:
            c_fullsample = None
    else:
        sample = []
        fullsample = []
        c_fullsample = None

    if comm:
        sample = comm.bcast(sample, root=0)
        fullsample = comm.bcast(fullsample, root=0)
        c_fullsample = comm.bcast(c_fullsample, root=0)

    if len(sample) == 0:
        log.info(f' Rank {rank}: to do (empty sample)!')
        return

    # Building the web-page and integrating the ellipse-fitting
    # results work on the full sample, so do that here and then
    # return.
    if rank == 0:
        if args.build_catalog:
            from SGA.SGA import build_catalog
            build_catalog(sample, fullsample, comm=comm, bands=bands, region=args.region,
                          datadir=datadir, no_groups=no_groups, unwise=args.unwise, galex=args.galex,
                          wisesize=args.wisesize, verbose=args.verbose, test_bricks=args.test_bricks,
                          clobber=args.clobber)
            return

        if args.build_refcat:
            # Build a reference catalog for use with the
            # pipeline. Satellites can belong to more than one group,
            # so trim to unique IDs.
            import fitsio

            ngal = len(fullsample)
            assert(ngal == len(np.unique(fullsample['SGAID'])))

            ref = Table()
            ref['ra'] = fullsample['RA']
            ref['dec'] = fullsample['DEC']
            ref['ref_id'] = fullsample['SGAID']
            ref['mag'] = fullsample['MAG']
            ref['fitmode'] = fullsample['FITMODE']
            ref['pa'] = fullsample['PA']
            ref['ba'] = fullsample['BA']
            ref['diam'] = fullsample['DIAM'] # [arcmin]

            # some objects added by hand have no fluxes
            I = ref['mag'] < 0.
            if np.any(I):
                ref['mag'][I] = 17.

            for col in ['pa', 'ba', 'diam', 'mag']:
                assert(np.all(np.isfinite(ref[col])))
            assert(np.all(ref['diam'] > 0.))
            assert(np.all(ref['mag'] > 0.))
            assert(np.all((ref['ba'] > 0.) & (ref['ba'] <= 1.)))
            assert(np.all((ref['pa'] >= 0.) & (ref['pa'] <= 180.)))
            assert(len(ref) == len(np.unique(ref['ref_id'])))

            log.info(f'Writing {ngal} galaxies to {refcatfile}')

            hdr = fitsio.FITSHDR()
            hdr['VER'] = REFCAT
            fitsio.write(refcatfile, ref.as_array(), header=hdr, clobber=True)

            log.info(f'Writing {kdrefcatfile}')
            cmd = f'startree -i {refcatfile} -o {kdrefcatfile} -T -P -k -n stars'
            log.info(cmd)
            _ = os.system(cmd)

            cmd = f'modhead {kdrefcatfile} VER {REFCAT}'
            _ = os.system(cmd)

            return

    # need at least one keyword at this point
    if (args.coadds is False and args.ellipse is False and args.htmlplots is False and
        args.htmlindex is False):
        log.warning('Need to specify at least one of --coadds, --ellipse, or ' + \
                    '--htmlplots; nothing to do.')
        return

    # Determine how many more galaxies we need to analyze and divide them across
    # ranks.
    if rank == 0:
        suffix, groups, _, fail = missing_files(
            sample=sample, region=args.region, bricks=bricks,
            coadds=args.coadds, ellipse=args.ellipse,
            htmlplots=args.htmlplots, htmlindex=args.htmlindex,
            no_groups=no_groups, clobber=args.clobber,
            verbose=args.verbose, datadir=datadir, htmldir=htmldir,
            size=size, mp=args.mp)

        if args.htmlindex:
            from SGA.html import make_html
            make_html(sample[groups[0]], fullsample, mp=args.mp, clobber=args.clobber,
                      region=args.region, htmldir=htmldir)#, htmlhome=args.htmlhome)
            return

        if args.diameter_file:
            if len(groups) > 0:
                todo = np.hstack(groups)
                with open(args.diameter_file, 'w') as F:
                    for diam in sample[DIAMCOLUMN][todo].value:
                        F.write(f'{diam}\n')
                log.info(f'Wrote {len(todo):,d} objects to {args.diameter_file}')
            else:
                log.warning('All done!')
            return
    else:
        groups, suffix = [], ''

    if comm:
        groups = comm.bcast(groups, root=0)
        suffix = comm.bcast(suffix, root=0)

    if rank == 0:
        if len(groups) == 0:
            ntodo = 0
        else:
            ntodo = len(np.hstack(groups))
        log.info(f'{suffix.upper()} left to do: {ntodo:,d} / ' + \
                 f'{len(sample):,d} divided across {size} rank(s).')
    if comm:
        comm.barrier()

    if len(groups) == 0:
        log.info(f'{suffix.upper()} for all {len(sample):,d} galaxies on rank ' + \
                 f'{rank} are complete!')
        if args.count:
            if rank == 0:
                if len(fail[rank]) > 0:
                    log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                             f'{len(sample):,d}')
                    galaxy, galaxydir = get_galaxy_galaxydir(
                        sample[fail[rank]], region=args.region,
                        group=not no_groups, datadir=datadir, htmldir=htmldir)
                    for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                            sample[DIAMCOLUMN][fail[rank]]):
                        print(f'  {ii} {dd} (d={diam:.3f} arcmin)')
        return
    elif len(groups[rank]) == 0:
        log.info(f'{suffix.upper()} for all {len(sample):,d} galaxies on rank ' + \
                 f'{rank} are complete!')
        if args.count:
            if rank == 0:
                if len(fail[rank]) > 0:
                    log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                             f'{len(sample):,d}')
                    galaxy, galaxydir = get_galaxy_galaxydir(
                        sample[fail[rank]], region=args.region,
                        group=not no_groups, datadir=datadir, htmldir=htmldir)
                    for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                            sample[DIAMCOLUMN][fail[rank]]):
                        print(f'  {ii} {dd} (d={diam:.3f} arcmin)')
        return
    else:
        log.info(f' Rank {rank}: {len(groups[rank]):,d} galaxies left to do.')
        if args.count:
            if rank == 0:
                if len(fail[rank]) > 0:
                    log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                             f'{len(sample):,d}')
                    galaxy, galaxydir = get_galaxy_galaxydir(
                        sample[fail[rank]], region=args.region,
                        group=not no_groups, datadir=datadir, htmldir=htmldir)
                    for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                            sample[DIAMCOLUMN][fail[rank]]):
                        print(f'  {ii} {dd} (d={diam:.3f} arcmin)')
                if args.debug:
                    if len(fail[rank]) > 0:
                        log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                                 f'{len(sample):,d}')
                        galaxy, galaxydir = get_galaxy_galaxydir(
                            sample[fail[rank]], region=args.region,
                            group=not no_groups, datadir=datadir, htmldir=htmldir)
                        for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                                sample[DIAMCOLUMN][fail[rank]]):
                            print(f'  {ii} {dd} (d={diam:.3f} arcmin)')

                    todo = np.hstack(groups)
                    if len(todo) > 0:
                        log.info(f'{suffix.upper()} todo: {len(todo):,d} / {len(sample):,d}')
                        galaxy, galaxydir = get_galaxy_galaxydir(
                            sample[todo], region=args.region,
                            group=not no_groups,
                            datadir=datadir, htmldir=htmldir)
                        for ii, dd, obj, diam in zip(todo, np.atleast_1d(galaxydir),
                                                     sample['OBJNAME'][todo],
                                                     sample[DIAMCOLUMN][todo]):
                            log.info(f'{dd} "{obj}" (d={diam:.3f} arcmin)')
                            #log.info(f'  {ii} {dd} ({obj}; d={diam:.3f} arcmin)')
                            #log.info(f'{dd}')
            return

    # Loop on the remaining objects.
    log.info(f'Starting {len(groups[rank])} {suffix.upper()} ' + \
             f'on rank {rank} with {args.mp} cores on {time.asctime()}')

    # The rest of the pipeline--
    if rank == 0:
        tall = time.time()

    for count, ii in enumerate(groups[rank]):
        onegal = sample[ii]
        galaxy, galaxydir, htmlgalaxydir = get_galaxy_galaxydir(
            onegal, region=args.region, group=not no_groups,
            html=True, datadir=datadir, htmldir=htmldir)
        if not os.path.isdir(galaxydir):
            os.makedirs(galaxydir, exist_ok=True)

        log.info(f'Rank {rank:03d} ({count+1} / {len(groups[rank])}): ' + \
                 f'{galaxydir} (index {ii:,d})')

        logfile = get_logfile(galaxy, galaxydir, suffix)
        fh = setup_logging(logfile, debug=args.debug)
        if not args.debug:
            log.info(f'Logging output to {logfile}')

        # Need the object "radius" to build the coadds.
        if no_groups:
            multiplicity = 1
        else:
            multiplicity = onegal['GROUP_MULT']

        radius_mosaic_arcsec = get_radius_mosaic(onegal[DIAMCOLUMN], # diam in arcmin
                                                 multiplicity=multiplicity)

        survey = get_survey(run, allbands=bands, output_dir=galaxydir)

        if args.coadds:
            from SGA.coadds import custom_coadds
            # SGA fitting modes

            # RESOLVED sources: no fitting, just coadds (and should
            # always have GROUP_MULT==1)
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED'] != 0:
                just_cutouts = True
                layer = f'ls-{args.region}'
                if args.region == 'dr11-south':
                    log.warning(f"WARNING: Overriding layer={layer}-->ls-dr11-early-v2")
                    layer = 'ls-dr11-early-v2'

                if np.any(np.isin(onegal['OBJNAME'], ['LMC', 'SMC', 'Antlia II'])):
                    #pixscale = 60. # [arcsec]
                    pixscale = args.pixscale * 100               # [arcsec]
                    galex_pixscale = args.galex_pixscale * 100
                    unwise_pixscale = args.unwise_pixscale * 100
                elif np.any(np.isin(onegal['OBJNAME'], ['Crater II', 'Bootes III'])):
                    #pixscale = 10. # [arcsec]
                    pixscale = args.pixscale * 50               # [arcsec]
                    galex_pixscale = args.galex_pixscale * 50
                    unwise_pixscale = args.unwise_pixscale * 50
                else:
                    pixscale = args.pixscale
                    galex_pixscale = args.galex_pixscale
                    unwise_pixscale = args.unwise_pixscale
            else:
                pixscale = args.pixscale
                galex_pixscale = args.galex_pixscale
                unwise_pixscale = args.unwise_pixscale
                just_cutouts = False
                layer = None

            # FORCEGAIA (not yet implemented); may be useful for e.g., Leo I
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['FORCEGAIA'] != 0:
                pass

            # FORCEPSF
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['FORCEPSF'] != 0:
                force_psf_detection = True
            else:
                force_psf_detection = False

            if args.debug:
                err, _ = custom_coadds(
                    onegal, galaxy, survey, run, radius_mosaic_arcsec,
                    release=release, pixscale=pixscale, bands=bands, mp=args.mp,
                    unwise_pixscale=unwise_pixscale, galex_pixscale=galex_pixscale,
                    nsigma=args.nsigma, just_coadds=args.just_coadds,
                    force_psf_detection=force_psf_detection,
                    fit_on_coadds=args.fit_on_coadds, just_cutouts=just_cutouts,
                    use_gpu=args.use_gpu, ngpu=args.ngpu, layer=layer,
                    threads_per_gpu=args.threads_per_gpu,
                    force=args.force, cleanup=args.cleanup,
                    unwise=args.unwise, galex=args.galex,
                    verbose=args.verbose)
            else:
                from contextlib import redirect_stdout, redirect_stderr
                from wurlitzer import pipes
                with open(logfile, 'a', buffering=1) as L, pipes(stdout=L, stderr=L), \
                     redirect_stdout(L), redirect_stderr(L):
                    err, _ = custom_coadds(
                        onegal, galaxy, survey, run, radius_mosaic_arcsec,
                        release=release, pixscale=pixscale, bands=bands, mp=args.mp,
                        unwise_pixscale=unwise_pixscale, galex_pixscale=galex_pixscale,
                        nsigma=args.nsigma, just_coadds=args.just_coadds,
                        force_psf_detection=force_psf_detection,
                        fit_on_coadds=args.fit_on_coadds, just_cutouts=just_cutouts,
                        use_gpu=args.use_gpu, ngpu=args.ngpu, layer=layer,
                        threads_per_gpu=args.threads_per_gpu,
                        force=args.force, cleanup=args.cleanup,
                        unwise=args.unwise, galex=args.galex,
                        verbose=args.verbose)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.ellipse or args.htmlplots:
            from SGA.SGA import (REFIDCOLUMN, SBTHRESH, APERTURES,
                                 OPTMASKBITS, GALEXMASKBITS, UNWISEMASKBITS,
                                 read_multiband, unpack_maskbits)
            SGAMASKBITS = [OPTMASKBITS, ]
            if args.unwise:
                SGAMASKBITS += [UNWISEMASKBITS]
            if args.galex:
                SGAMASKBITS += [GALEXMASKBITS]


        if args.ellipse:
            from SGA.ellipse import ellipsefit_multiband

            if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-coadds.isdone')):
                log.warning('Coadds must be generated before running ellipse-fitting.')
                restore_logger(fh=fh, debug=args.debug)
                continue

            # Always write out the individual galaxies for this mosaic
            # if doing ellipse-fitting to make sure we get the latest
            # catalog parameters.
            if no_groups:
                sample_thisgroup = Table(onegal)
            else:
                I = np.where(onegal['GROUP_NAME'] == fullsample['GROUP_NAME'])[0]
                sample_thisgroup = fullsample[I]

            samplefile = os.path.join(galaxydir, f'{galaxy}-sample.fits')
            log.info(f'Writing {len(sample_thisgroup)} galaxy(ies) to {samplefile}')
            tmpfile = samplefile+'.tmp'
            sample_thisgroup.write(tmpfile, overwrite=True, format='fits')
            os.rename(tmpfile, samplefile)

            #print('Temporarily make htmlgalaxydir here')
            #if not os.path.isdir(htmlgalaxydir):
            #    os.makedirs(htmlgalaxydir, exist_ok=True)

            if args.debug:
                args.qaplot = False # True # always

            skip_ellipse = skip_ellipse_or_not(onegal)

            # Find other objects not in this group (excluding RESOLVED
            # sources) which may contaminate the actual group members.
            minsep = (0.5 * u.deg) # 5. * u.arcmin
            c_thisgroup = SkyCoord(onegal[RACOLUMN]*u.deg, onegal[DECCOLUMN]*u.deg)
            Imask_nearby = (c_thisgroup.separation(c_fullsample) < minsep * # separation < 1 degree
                            ~np.isin(fullsample[REFIDCOLUMN], sample_thisgroup[REFIDCOLUMN]) *
                            ((fullsample['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED']) == 0))
            if np.any(Imask_nearby):
                mask_nearby = fullsample['OBJNAME', 'RA', 'DEC', 'DIAM', 'BA', 'PA'][Imask_nearby]
            else:
                mask_nearby = None

            err = ellipsefit_multiband(galaxy, galaxydir, REFIDCOLUMN, read_multiband,
                                       unpack_maskbits, SGAMASKBITS, run=run, bands=bands,
                                       mp=args.mp, sbthresh=SBTHRESH, apertures=APERTURES,
                                       nmonte=args.nmonte, seed=args.seed, mask_nearby=mask_nearby,
                                       use_tractor_position=args.use_tractor_position,
                                       use_radial_weight=args.use_radial_weight,
                                       pixscale=args.pixscale, unwise_pixscale=args.unwise_pixscale,
                                       galex_pixscale=args.galex_pixscale, unwise=args.unwise,
                                       galex=args.galex, qaplot=args.qaplot, verbose=args.verbose,
                                       clobber=args.clobber, skip_ellipse=skip_ellipse,
                                       htmlgalaxydir=htmlgalaxydir)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.htmlplots:
            from SGA.html import make_plots

            skip_ellipse = skip_ellipse_or_not(onegal)
            if not skip_ellipse:
                if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-ellipse.isdone')):
                    log.warning('Ellipse-fitting must be done before generating plots.')
                    restore_logger(fh=fh, debug=args.debug)
                    continue

            if not os.path.isdir(htmlgalaxydir):
                os.makedirs(htmlgalaxydir, exist_ok=True)

            _, barlen, barlabel = get_radius_mosaic(
                onegal[DIAMCOLUMN], pixscale=args.pixscale, get_barlen=True)

            err = make_plots(galaxy, galaxydir, htmlgalaxydir, REFIDCOLUMN, read_multiband,
                             unpack_maskbits, SGAMASKBITS, APERTURES,
                             barlen=barlen, barlabel=barlabel, run=run,
                             skip_ellipse=skip_ellipse,
                             bands=bands, mp=args.mp, pixscale=args.pixscale,
                             unwise=args.unwise, galex=args.galex,
                             verbose=args.verbose, clobber=args.clobber)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


    if comm:
        comm.barrier()

    if rank == 0:
        log.info(f'Finished {ntodo} {suffix.upper()} at {time.asctime()} ' + \
                 f'after {(time.time()-tall)/60.:.3f} minutes')
        _, groups, _, _ = missing_files(sample=sample, region=args.region,
                                        bricks=bricks, coadds=args.coadds,
                                        ellipse=args.ellipse,
                                        htmlplots=args.htmlplots,
                                        htmlindex=args.htmlindex,
                                        #clobber=args.clobber,
                                        no_groups=no_groups,
                                        verbose=args.verbose,
                                        datadir=datadir, htmldir=htmldir,
                                        size=size, mp=args.mp)

        if len(groups) > 0:
            stilltodo = len(np.hstack(groups))
        else:
            stilltodo = 0
        log.info(f'{suffix.upper()} left to do: {stilltodo:,d} / {ntodo:,d}.')



if __name__ == '__main__':
    main()
