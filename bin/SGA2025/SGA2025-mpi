#!/usr/bin/env python
"""MPI wrapper for the Siena Galaxy Atlas 2025 project.

salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive
SGA2025-shifter
source /global/homes/i/ioannis/code/SGA/bin/SGA2025/SGA2025-env

SGA2025-mpi --build-refcat

# (1) nice isolated spiral; (2) second isolated spiral; (3) 2-member
# group; (4) giant and dwarf group;

SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="WISEA J125450.10+261929.6"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="KUG 1247+260"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="III Zw 040 NOTES02"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="UGC 05688"

SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-test1

# LVD tests
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd --debug --mp=8 --d25max=3 --coadds
SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd [--lvd-resolved] [--lvd-fixgeo] [--lvd-forcepsf]

In production:

salloc -N 2 -C cpu -A m3592 -t 04:00:00 --qos interactive --image=docker:legacysurvey/sga:0.4
srun --ntasks=8 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
  SGA2025-mpi --coadds --mp=32


"""
import os, time, sys, pdb
from astropy.table import Table
import numpy as np

from SGA.logger import (log, LOGFMT, hook_legacypipe_and_root,
                        unhook_legacypipe_and_root,
                        setup_logging)


def get_logfile(galaxy, galaxydir, stagesuffix):
    from SGA.io import backup_filename
    logfile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}.log')
    backup_filename(logfile)
    return logfile


def done(galaxy, galaxydir, err, stagesuffix, fh=None, debug=False):
    import logging

    donefile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}')
    if err == 0:
        log.warning(f'Problem processing {galaxydir}/{galaxy}; please check the log file.')
        donefile = f'{donefile}.isfail'
    else:
        donefile = f'{donefile}.isdone'

    # equivalent to 'touch'
    open(donefile, 'w').close()

    # restore the logger
    if fh is not None:
        unhook_legacypipe_and_root(fh, restore_console=True, debug=debug)

        # detach from both loggers
        logging.getLogger('py.warnings').removeHandler(fh)
        log.removeHandler(fh)
        fh.close()

        # reattach console logging to stdout
        have_console = any((type(h) is logging.StreamHandler) and
                           getattr(h, "stream", None) is sys.stdout
                           for h in log.handlers)
        if not have_console:
            ch = logging.StreamHandler(sys.stdout)
            ch.setLevel(logging.INFO)
            ch.setFormatter(LOGFMT)
            log.addHandler(ch)

def main():
    """Top-level wrapper.

    """
    from legacypipe.runs import get_survey

    from SGA.coadds import RUNS, BANDS, RELEASE
    from SGA.mpi import mpi_args
    from SGA.io import set_legacysurvey_dir
    from SGA.ellipse import ELLIPSEMODE
    from SGA.SGA import (RACOLUMN, DECCOLUMN, DIAMCOLUMN, SAMPLE, REFCAT,
                         sga_dir, sga_data_dir, sga_html_dir, SGA_version,
                         read_sample, missing_files, get_galaxy_galaxydir,
                         build_catalog, get_radius_mosaic)

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank, size = comm.rank, comm.size
    except:
        comm = None
        rank, size = 0, 1

    args = mpi_args()
    set_legacysurvey_dir(args.region, rank=rank)

    if args.lvd:
        no_groups = True
    else:
        no_groups = args.no_groups

    if no_groups:
        RACOLUMN = 'RA'
        DECCOLUMN = 'DEC'
        DIAMCOLUMN = 'DIAM'

    basedir = sga_dir()
    datadir = args.datadir if args.datadir is not None else sga_data_dir()
    htmldir = args.htmldir if args.htmldir is not None else sga_html_dir()

    os.environ['SGA_DATA_DIR'] = os.path.abspath(datadir)
    os.environ['SGA_HTML_DIR'] = os.path.abspath(htmldir)

    run = RUNS[args.region]
    release = RELEASE[args.region]
    bands = BANDS[args.region]

    # Read and broadcast the sample.
    bricks = None
    if rank == 0:
        if not os.path.isdir(datadir):
            os.makedirs(datadir, exist_ok=True)
        if not os.path.isdir(htmldir):
            os.makedirs(htmldir, exist_ok=True)

        log.info(f'$SGA_DIR={basedir}')
        log.info(f'$SGA_DATA_DIR={datadir}')
        log.info(f'$SGA_HTML_DIR={htmldir}')
        log.info(f'$LARGEGALAXIES_CAT={os.getenv("LARGEGALAXIES_CAT")}')

        sga_version = SGA_version(parent=True)
        refcatfile = os.path.join(basedir, 'sample', f'SGA2025-refcat-{sga_version}.fits')
        kdrefcatfile = refcatfile.replace('.fits', '.kd.fits')
        if not os.getenv("LARGEGALAXIES_CAT"):
            msg = f'{os.getenv("LARGEGALAXIES_CAT")} not found!'
            log.critical(msg)
            raise ValueError(msg)
        else:
            if kdrefcatfile != os.getenv("LARGEGALAXIES_CAT"):
                if kdrefcatfile.replace('/global/', '/dvs_ro/') != os.getenv("LARGEGALAXIES_CAT"):
                    msg = f'Mismatch between $LARGEGALAXIES_CAT and {kdrefcatfile}!'
                    log.warning(msg)
                    #log.critical(msg)
                    #raise ValueError(msg)


        if args.build_refcat:
            region = None
        else:
            region = args.region

        sample, fullsample = read_sample(
            first=args.first, last=args.last, mindiam=args.mindiam,
            maxdiam=args.maxdiam, maxmult=args.maxmult,
            galaxylist=args.galaxylist, no_groups=no_groups,
            lvd=args.lvd, region=region,
            test_bricks=args.test_bricks, verbose=args.verbose)

    else:
        sample = []
        fullsample = []

    if comm:
        sample = comm.bcast(sample, root=0)
        fullsample = comm.bcast(fullsample, root=0)

    if len(sample) == 0:
        log.info(f' Rank {rank}: to do (empty sample)!')
        return

    # Building the web-page and integrating the ellipse-fitting
    # results work on the full sample, so do that here and then
    # return.
    if rank == 0:
        if args.htmlindex:
            SGA.html.make_html(sample, survey=None, pixscale=args.pixscale,
                               racolumn=RACOLUMN, deccolumn=DECCOLUMN,
                               mp=args.mp, clobber=args.clobber,
                               region=args.region, makeplots=False,
                               verbose=args.verbose, htmldir=args.htmldir,
                               htmlhome=args.htmlhome,
                               html_raslices=args.html_raslices,
                               args=args)
            return

        if args.build_refcat:
            # Build a reference catalog for use with the
            # pipeline. Satellites can belong to more than one group,
            # so trim to unique IDs.
            import fitsio

            ngal = len(fullsample)
            assert(ngal == len(np.unique(fullsample['SGAID'])))

            ref = Table()
            ref['ra'] = fullsample['RA']
            ref['dec'] = fullsample['DEC']
            ref['ref_id'] = fullsample['SGAID']
            ref['mag'] = fullsample['MAG']
            ref['pa'] = fullsample['PA']
            ref['ba'] = fullsample['BA']
            ref['diam'] = fullsample['DIAM'] # [arcmin]
            for col in ['pa', 'ba', 'diam', 'mag']:
                assert(np.all(np.isfinite(ref[col])))
            ref['fitmode'] = fullsample['FITMODE']

            log.info(f'Writing {ngal} galaxies to {refcatfile}')

            hdr = fitsio.FITSHDR()
            hdr['VER'] = REFCAT
            fitsio.write(refcatfile, ref.as_array(), header=hdr, clobber=True)

            log.info(f'Writing {kdrefcatfile}')
            cmd = f'startree -i {refcatfile} -o {kdrefcatfile} -T -P -k -n stars'
            log.info(cmd)
            _ = os.system(cmd)

            cmd = f'modhead {kdrefcatfile} VER {REFCAT}'
            _ = os.system(cmd)

            return

    if args.build_catalog:
        build_catalog(sample, fullsample, comm=comm, bands=bands, region=args.region,
                      datadir=datadir, no_groups=no_groups, unwise=args.unwise,
                      galex=args.galex, mp=args.mp, verbose=args.verbose,
                      clobber=args.clobber)
        return

    # need at least one keyword at this point
    if args.coadds is False and args.ellipse is False and args.htmlplots is False:
        log.warning('Need to specify at least one of --coadds, --ellipse, or ' + \
                    '--htmlplots; nothing to do.')
        return

    # Determine how many more galaxies we need to analyze and divide them across
    # ranks.
    if rank == 0:
        suffix, groups, _, fail = missing_files(
            sample=sample, region=args.region, bricks=bricks,
            coadds=args.coadds, ellipse=args.ellipse,
            htmlplots=args.htmlplots, htmlindex=args.htmlindex,
            no_groups=no_groups, clobber=args.clobber,
            verbose=args.verbose, datadir=datadir, htmldir=htmldir,
            size=size, mp=args.mp)

        if args.diameter_file:
            todo = np.hstack(groups)
            with open(args.diameter_file, 'w') as F:
                for diam in sample[DIAMCOLUMN][todo].value:
                    F.write(f'{diam}\n')
            log.info(f'Wrote {len(todo):,d} objects to {args.diameter_file}')
            return
    else:
        groups, suffix = [], ''

    if comm:
        groups = comm.bcast(groups, root=0)
        suffix = comm.bcast(suffix, root=0)

    if rank == 0:
        if len(groups) == 0:
            ntodo = 0
        else:
            ntodo = len(np.hstack(groups))
        log.info(f'{suffix.upper()} left to do: {ntodo:,d} / ' + \
                 f'{len(sample):,d} divided across {size} rank(s).')
    if comm:
        comm.barrier()

    if len(groups) == 0:
        log.info(f'{suffix.upper()} for all {len(sample):,d} galaxies on rank ' + \
                 f'{rank} are complete!')
        return
    elif len(groups[rank]) == 0:
        log.info(f'{suffix.upper()} for all {len(sample):,d} galaxies on rank ' + \
                 f'{rank} are complete!')
        return
    else:
        log.info(f' Rank {rank}: {len(groups[rank]):,d} galaxies left to do.')
        if args.count:
            if rank == 0:
                if args.debug:
                    if len(fail[rank]) > 0:
                        log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                                 f'{len(sample):,d}')
                        galaxy, galaxydir = get_galaxy_galaxydir(
                            sample[fail[rank]], region=args.region,
                            group=not no_groups, datadir=datadir, htmldir=htmldir)
                        for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                                sample[DIAMCOLUMN][fail[rank]]):
                            print(f'  {ii} {dd} (d={diam:.3f} arcmin)')

                    todo = np.hstack(groups)
                    if len(todo) > 0:
                        log.info(f'{suffix.upper()} todo: {len(todo):,d} / {len(sample):,d}')
                        galaxy, galaxydir = get_galaxy_galaxydir(
                            sample[todo], region=args.region,
                            group=not no_groups,
                            datadir=datadir, htmldir=htmldir)
                        for ii, dd, obj, diam in zip(todo, np.atleast_1d(galaxydir),
                                                     sample['OBJNAME'][todo],
                                                     sample[DIAMCOLUMN][todo]):
                            log.info(f'{dd} "{obj}" (d={diam:.3f} arcmin)')
                            #log.info(f'  {ii} {dd} ({obj}; d={diam:.3f} arcmin)')
                            #log.info(f'{dd}')
            return

    # Loop on the remaining objects.
    log.info(f'Starting {len(groups[rank])} {suffix.upper()} ' + \
             f'on rank {rank} with {args.mp} cores on {time.asctime()}')

    # The rest of the pipeline--
    if rank == 0:
        tall = time.time()

    for count, ii in enumerate(groups[rank]):
        onegal = sample[ii]
        galaxy, galaxydir, htmlgalaxydir = get_galaxy_galaxydir(
            onegal, region=args.region, group=not no_groups,
            html=True, datadir=datadir, htmldir=htmldir)
        if not os.path.isdir(galaxydir):
            os.makedirs(galaxydir, exist_ok=True)

        log.info(f'Rank {rank:03d} ({count+1} / {len(groups[rank])}): ' + \
                 f'{galaxydir} (index {ii:,d})')

        logfile = get_logfile(galaxy, galaxydir, suffix)
        fh = setup_logging(logfile, debug=args.debug)
        if not args.debug:
            log.info(f'Logging output to {logfile}')

        # Need the object "radius" to build the coadds.
        if no_groups:
            multiplicity = 1
        else:
            multiplicity = onegal['GROUP_MULT']

        radius_mosaic_arcsec = get_radius_mosaic(onegal[DIAMCOLUMN], # diam in arcmin
                                                 multiplicity=multiplicity)

        survey = get_survey(run, allbands=bands, output_dir=galaxydir)

        if args.coadds:
            from SGA.coadds import custom_coadds

            # Write out the individual galaxies for this mosaic.
            if no_groups:
                thissample = Table(onegal)
            else:
                I = np.where(onegal['GROUP_ID'] == fullsample['GROUP_ID'])[0]
                thissample = fullsample[I]

            samplefile = os.path.join(galaxydir, f'{galaxy}-sample.fits')
            if args.clobber or not os.path.isfile(samplefile):
                log.debug(f'Writing {len(thissample)} galaxy(ies) ' + \
                          f'to {samplefile}')
                tmpfile = samplefile+'.tmp'
                thissample.write(tmpfile, overwrite=True, format='fits')
                os.rename(tmpfile, samplefile)

            # SGA fitting modes
            # FIXGEO
            #   ...
            # FORCEGAIA
            #   ...


            # FORCEPSF
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['FORCEPSF'] != 0:
                force_psf_detection = True
            else:
                force_psf_detection = False

            if onegal['SAMPLE'] & SAMPLE['GCLPNE'] != 0:
                # FIXME - set --no-clusters or --no-force-gaia
                pass

            if args.debug:
                err, _ = custom_coadds(
                    onegal, galaxy, survey, run, radius_mosaic_arcsec,
                    release=release, pixscale=args.pixscale, bands=bands, mp=args.mp,
                    nsigma=args.nsigma, just_coadds=args.just_coadds,
                    force_psf_detection=force_psf_detection,
                    fit_on_coadds=args.fit_on_coadds,
                    use_gpu=args.use_gpu, ngpu=args.ngpu,
                    threads_per_gpu=args.threads_per_gpu,
                    force=args.force, cleanup=args.cleanup,
                    unwise=args.unwise, galex=args.galex,
                    verbose=args.verbose)
            else:
                from contextlib import redirect_stdout, redirect_stderr
                from wurlitzer import pipes
                with open(logfile, 'a', buffering=1) as L, pipes(stdout=L, stderr=L), \
                     redirect_stdout(L), redirect_stderr(L):
                    err, _ = custom_coadds(
                        onegal, galaxy, survey, run, radius_mosaic_arcsec,
                        release=release, pixscale=args.pixscale, bands=bands, mp=args.mp,
                        nsigma=args.nsigma, just_coadds=args.just_coadds,
                        force_psf_detection=force_psf_detection,
                        fit_on_coadds=args.fit_on_coadds,
                        use_gpu=args.use_gpu, ngpu=args.ngpu,
                        threads_per_gpu=args.threads_per_gpu,
                        force=args.force, cleanup=args.cleanup,
                        unwise=args.unwise, galex=args.galex,
                        verbose=args.verbose)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.ellipse or args.htmlplots:
            from SGA.SGA import (REFIDCOLUMN, SBTHRESH, APERTURES,
                                 OPTMASKBITS, GALEXMASKBITS, UNWISEMASKBITS,
                                 read_multiband, unpack_maskbits)
            SGAMASKBITS = [OPTMASKBITS, ]
            if args.unwise:
                SGAMASKBITS += [UNWISEMASKBITS]
            if args.galex:
                SGAMASKBITS += [GALEXMASKBITS]


        if args.ellipse:
            from SGA.ellipse import ellipsefit_multiband

            if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-coadds.isdone')):
                log.warning('Coadds must be generated before running ellipse-fitting.')
                continue

            #print('Temporarily make htmlgalaxydir here')
            #if not os.path.isdir(htmlgalaxydir):
            #    os.makedirs(htmlgalaxydir, exist_ok=True)

            #if args.debug:
            #    qaplot = True
            #else:
            #    #print('Temporarily setting qaplot=True!')
            #    #qaplot = True
            #    qaplot = False

            err = ellipsefit_multiband(galaxy, galaxydir, REFIDCOLUMN, read_multiband,
                                       unpack_maskbits, SGAMASKBITS, run=run, bands=bands,
                                       mp=args.mp, sbthresh=SBTHRESH, apertures=APERTURES,
                                       nmonte=args.nmonte, seed=args.seed,
                                       pixscale=args.pixscale, unwise_pixscale=args.unwise_pixscale,
                                       galex_pixscale=args.galex_pixscale, unwise=args.unwise,
                                       galex=args.galex, qaplot=False, verbose=args.verbose,
                                       clobber=args.clobber,
                                       # HACK!!
                                       htmlgalaxydir=htmlgalaxydir)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.htmlplots:
            from SGA.html import make_plots

            if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-ellipse.isdone')):
                log.warning('Ellipse-fitting must be done before generating plots.')
                continue

            if not os.path.isdir(htmlgalaxydir):
                os.makedirs(htmlgalaxydir, exist_ok=True)

            radius_mosaic_arcsec, barlen, barlabel = get_radius_mosaic(
                onegal[DIAMCOLUMN], pixscale=args.pixscale, get_barlen=True)

            err = make_plots(galaxy, galaxydir, htmlgalaxydir, REFIDCOLUMN, read_multiband,
                             unpack_maskbits, SGAMASKBITS, APERTURES,
                             #radius_mosaic_arcsec=radius_mosaic_arcsec,
                             barlen=barlen, barlabel=barlabel, run=run,
                             bands=bands, mp=args.mp, pixscale=args.pixscale,
                             unwise=args.unwise, galex=args.galex,
                             verbose=args.verbose, clobber=args.clobber)

            #onegal, galaxy, pixscale=args.pixscale,
            #mp=args.mp, verbose=args.verbose, debug=args.debug,
            #clobber=args.clobber,
            #htmldir=htmldir, datadir=datadir,
            #barlen=barlen, barlabel=barlabel,
            #galex=args.galex, unwise=args.unwise,
            #region=args.region,
            #get_galaxy_galaxydir=get_galaxy_galaxydir,
            #read_multiband=read_multiband)

    if comm:
        comm.barrier()

    if rank == 0:
        log.info(f'Finished {ntodo} {suffix.upper()} at {time.asctime()} ' + \
                 f'after {(time.time()-tall)/60.:.3f} minutes')
        _, groups, _, _ = missing_files(sample=sample, region=args.region,
                                        bricks=bricks, coadds=args.coadds,
                                        ellipse=args.ellipse,
                                        htmlplots=args.htmlplots,
                                        htmlindex=args.htmlindex,
                                        #clobber=args.clobber,
                                        no_groups=no_groups,
                                        verbose=args.verbose,
                                        datadir=datadir, htmldir=htmldir,
                                        size=size, mp=args.mp)

        if len(groups) > 0:
            stilltodo = len(np.hstack(groups))
        else:
            stilltodo = 0
        log.info(f'{suffix.upper()} left to do: {stilltodo:,d} / {ntodo:,d}.')



if __name__ == '__main__':
    main()
