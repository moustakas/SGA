#!/usr/bin/env python
"""MPI wrapper for the Siena Galaxy Atlas 2025 project.

salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive
SGA2025-shifter
source /global/homes/i/ioannis/code/SGA/bin/SGA2025/SGA2025-env

SGA2025-mpi --build-refcat

# (1) nice isolated spiral; (2) second isolated spiral; (3) 2-member
# group; (4) giant and dwarf group;

SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="WISEA J125450.10+261929.6"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="KUG 1247+260"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="III Zw 040 NOTES02"
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-flags --mp=32 --debug --coadds --galaxylist="UGC 05688"

SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-test1

# LVD tests
SGA2025-mpi --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd --debug --mp=8 --d25max=3 --coadds
SGA2025-tractor-qa --datadir=/pscratch/sd/i/ioannis/SGA2025-lvd-v0.1 --lvd [--lvd-resolved] [--lvd-fixgeo] [--lvd-forcepsf]

In production:

salloc -N 2 -C cpu -A m3592 -t 04:00:00 --qos interactive --image=docker:legacysurvey/sga:0.4
srun --ntasks=8 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
  SGA2025-mpi --coadds --mp=32


"""
import os, time, sys, pdb
import numpy as np
import astropy.units as u
from astropy.coordinates import SkyCoord
from astropy.table import Table

from SGA.ellipse import ELLIPSEMODE
from SGA.logger import (log, LOGFMT, hook_legacypipe_and_root,
                        unhook_legacypipe_and_root,
                        setup_logging)


def get_logfile(galaxy, galaxydir, stagesuffix):
    from SGA.io import backup_filename
    logfile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}.log')
    backup_filename(logfile)
    return logfile


def restore_logger(fh=None, debug=False):
    import logging

    if fh is not None:
        unhook_legacypipe_and_root(fh, restore_console=True, debug=debug)

        # detach from both loggers
        logging.getLogger('py.warnings').removeHandler(fh)
        log.removeHandler(fh)
        fh.close()

        # reattach console logging to stdout
        have_console = any((type(h) is logging.StreamHandler) and
                           getattr(h, "stream", None) is sys.stdout
                           for h in log.handlers)
        if not have_console:
            ch = logging.StreamHandler(sys.stdout)
            ch.setLevel(logging.INFO)
            ch.setFormatter(LOGFMT)
            log.addHandler(ch)

def skip_ellipse_or_not(row):
    # RESOLVED - nothing to do
    if row['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED'] != 0:
        #log.info(f'No ellipse-fitting needed for RESOLVED source {galaxydir}/{galaxy}')
        return True
    else:
        return False


def done(galaxy, galaxydir, err, stagesuffix, fh=None, debug=False):

    donefile = os.path.join(galaxydir, f'{galaxy}-{stagesuffix}')
    if err == 0:
        log.warning(f'Problem processing {galaxydir}/{galaxy}; please check the log file.')
        donefile = f'{donefile}.isfail'
    else:
        donefile = f'{donefile}.isdone'

    # equivalent to 'touch'
    open(donefile, 'w').close()

    # restore the logger
    restore_logger(fh=fh, debug=debug)


def sort_groups_by_attempts(galaxy, galaxydir, sample, diamcolumn='DIAM'):
    """
    Sort galaxy groups by number of attempts (highest to lowest).

    Parameters
    ----------
    galaxy : array-like
        Group names (e.g., 'SGA2025_19895p4202')
    galaxydir : array-like
        Group directories
    sample : Table
        Catalog with OBJNAME and diameter columns
    diamcolumn : str
        Name of diameter column in sample

    Prints sorted list grouped by attempt count.

    """
    import glob

    galaxy = np.atleast_1d(galaxy)
    galaxydir = np.atleast_1d(galaxydir)

    attempts = []
    for gname, gdir in zip(galaxy, galaxydir):
        # Look for log files matching pattern
        logpattern = os.path.join(gdir, f'{gname}-coadds.log*')
        logfiles = glob.glob(logpattern)
        attempts.append(len(logfiles))

    attempts = np.array(attempts)

    # Sort by attempts (descending)
    sort_idx = np.argsort(attempts)[::-1]

    # Group by attempt count and print
    unique_attempts = np.unique(attempts[sort_idx])[::-1]  # High to low

    for iattempt, n_attempt in enumerate(unique_attempts):
        mask = attempts == n_attempt
        indices = np.where(mask)[0]

        if n_attempt == 0:
            log.info(f"\n=== Not yet attempted ({len(indices)} groups) ===")
        else:
            log.info(f"\n=== {n_attempt} attempt(s) ({len(indices)} groups) ===")

        todo, diams = [], []
        for idx in indices:
            gdir = galaxydir[idx]
            obj = sample['OBJNAME'][idx]
            diam = sample[diamcolumn][idx]
            log.info(f'{gdir} "{obj}" (d={diam:.3f} arcmin)')
            todo.append(os.path.basename(gdir))
            diams.append(diam)

        if len(todo) > 0:
            print()
            print(','.join(todo))

    #if len(todo) > 0:
    #    print()
    #    print(','.join(todo))
    #    #_ = [print(f'{one},{diam}') for one, diam in zip(todo, diams)]


def main():
    """Top-level wrapper.

    """
    from legacypipe.runs import get_survey

    from SGA.coadds import RUNS, BANDS, RELEASE
    from SGA.mpi import mpi_args
    from SGA.io import set_legacysurvey_dir
    from SGA.SGA import (RACOLUMN, DECCOLUMN, DIAMCOLUMN, SAMPLE, REFCAT,
                         sga_dir, sga_data_dir, sga_html_dir, SGA_version,
                         read_sample, missing_files, get_galaxy_galaxydir,
                         get_radius_mosaic)

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank, size = comm.rank, comm.size
    except:
        comm = None
        rank, size = 0, 1

    args = mpi_args()
    set_legacysurvey_dir(args.region, rank=rank)

    #if args.mp > 1 and 'NERSC_HOST' in os.environ:
    #    import multiprocessing
    #    multiprocessing.set_start_method('spawn')

    #if args.lvd:
    #    no_groups = True
    #else:
    #    no_groups = args.no_groups
    no_groups = args.no_groups

    if no_groups:
        RACOLUMN = 'RA'
        DECCOLUMN = 'DEC'
        DIAMCOLUMN = 'DIAM'

    basedir = sga_dir()
    datadir = args.datadir if args.datadir is not None else sga_data_dir()
    htmldir = args.htmldir if args.htmldir is not None else sga_html_dir()

    os.environ['SGA_DATA_DIR'] = os.path.abspath(datadir)
    os.environ['SGA_HTML_DIR'] = os.path.abspath(htmldir)

    run = RUNS[args.region]
    release = RELEASE[args.region]
    bands = BANDS[args.region]

    # Read and broadcast the sample.
    bricks = None
    if rank == 0:
        if not os.path.isdir(datadir):
            os.makedirs(datadir, exist_ok=True)
        if not os.path.isdir(htmldir):
            os.makedirs(htmldir, exist_ok=True)

        log.info(f'$SGA_DIR={basedir}')
        log.info(f'$SGA_DATA_DIR={datadir}')
        log.info(f'$SGA_HTML_DIR={htmldir}')
        log.info(f'$LARGEGALAXIES_CAT={os.getenv("LARGEGALAXIES_CAT")}')

        sga_version = SGA_version(parent=True)
        refcatfile = os.path.join(basedir, 'sample', f'SGA2025-beta-parent-refcat-{sga_version}.fits')
        kdrefcatfile = refcatfile.replace('.fits', '.kd.fits')
        if not os.getenv("LARGEGALAXIES_CAT"):
            msg = f'{os.getenv("LARGEGALAXIES_CAT")} not found!'
            log.critical(msg)
            raise ValueError(msg)
        else:
            if kdrefcatfile != os.getenv("LARGEGALAXIES_CAT"):
                if kdrefcatfile.replace('/global/', '/dvs_ro/') != os.getenv("LARGEGALAXIES_CAT"):
                    msg = f'Mismatch between $LARGEGALAXIES_CAT and {kdrefcatfile}!'
                    log.warning(msg)
                    #log.critical(msg)
                    #raise ValueError(msg)


        if args.build_refcat:
            region = None
        else:
            region = args.region

        sample, fullsample = read_sample(
            first=args.first, last=args.last, mindiam=args.mindiam,
            maxdiam=args.maxdiam, minmult=args.minmult, maxmult=args.maxmult,
            version=args.version, galaxylist=args.galaxylist,
            no_groups=no_groups, lvd=args.lvd, final_sample=args.final_sample,
            wisesize=args.wisesize, region=region, test_bricks=args.test_bricks,
            verbose=args.verbose)

        #galaxy, galaxydir = get_galaxy_galaxydir(sample, region=args.region, datadir=datadir)
        #_=[print(gdir+'/*ellipse*') for gdir in galaxydir]

        #from importlib import resources
        #from SGA.parent import load_overlays, apply_flags_inplace
        #overlay_dir = resources.files('SGA').joinpath(f'data/SGA2025/overlays/v0.40')
        #ov = load_overlays(overlay_dir)
        #apply_flags_inplace(sample, ov.flags, ELLIPSEMODE)
        #apply_flags_inplace(fullsample, ov.flags, ELLIPSEMODE)

        if len(fullsample) > 0:
            # pre-compute the SkyCoord object
            c_fullsample = SkyCoord(fullsample[RACOLUMN]*u.deg, fullsample[DECCOLUMN]*u.deg)
        else:
            c_fullsample = None
    else:
        sample = []
        fullsample = []
        c_fullsample = None

    if comm:
        sample = comm.bcast(sample, root=0)
        fullsample = comm.bcast(fullsample, root=0)
        c_fullsample = comm.bcast(c_fullsample, root=0)

    if len(sample) == 0:
        log.info(f' Rank {rank}: to do (empty sample)!')
        return

    # Building the web-page and integrating the ellipse-fitting
    # results work on the full sample, so do that here and then
    # return.
    if rank == 0:
        if args.build_refcat:
            # Build a reference catalog for use with the
            # pipeline. Satellites can belong to more than one group,
            # so trim to unique IDs.
            import fitsio

            ngal = len(fullsample)
            assert(ngal == len(np.unique(fullsample['SGAID'])))

            ref = Table()
            ref['ra'] = fullsample['RA']
            ref['dec'] = fullsample['DEC']
            ref['ref_id'] = fullsample['SGAID']
            ref['mag'] = fullsample['MAG']
            ref['fitmode'] = fullsample['FITMODE']
            ref['pa'] = fullsample['PA']
            ref['ba'] = fullsample['BA']
            ref['diam'] = fullsample['DIAM'] # [arcmin]

            # some objects added by hand have no fluxes
            I = ref['mag'] < 0.
            if np.any(I):
                ref['mag'][I] = 17.

            for col in ['pa', 'ba', 'diam', 'mag']:
                assert(np.all(np.isfinite(ref[col])))
            assert(np.all(ref['diam'] > 0.))
            assert(np.all(ref['mag'] > 0.))
            assert(np.all((ref['ba'] > 0.) & (ref['ba'] <= 1.)))
            assert(np.all((ref['pa'] >= 0.) & (ref['pa'] <= 180.)))
            assert(len(ref) == len(np.unique(ref['ref_id'])))

            log.info(f'Writing {ngal} galaxies to {refcatfile}')

            hdr = fitsio.FITSHDR()
            hdr['VER'] = REFCAT
            fitsio.write(refcatfile, ref.as_array(), header=hdr, clobber=True)

            log.info(f'Writing {kdrefcatfile}')
            cmd = f'startree -i {refcatfile} -o {kdrefcatfile} -T -P -k -n stars'
            log.info(cmd)
            _ = os.system(cmd)

            cmd = f'modhead {kdrefcatfile} VER {REFCAT}'
            _ = os.system(cmd)

            return

    if args.build_catalog:
        from SGA.SGA import build_catalog
        build_catalog(sample, fullsample, comm=comm, bands=bands, region=args.region,
                      datadir=datadir, no_groups=no_groups, unwise=args.unwise, galex=args.galex,
                      wisesize=args.wisesize, verbose=args.verbose, test_bricks=args.test_bricks,
                      clobber=args.clobber)
        return

    # need at least one keyword at this point
    if (args.coadds is False and args.ellipse is False and args.htmlplots is False and
        args.htmlindex is False):
        log.warning('Need to specify at least one of --coadds, --ellipse, or ' + \
                    '--htmlplots; nothing to do.')
        return

    # Determine how many more galaxies we need to analyze and divide them across
    # ranks.
    if rank == 0:
        suffix, groups, _, fail, wait = missing_files(
            sample=sample, region=args.region, bricks=bricks,
            coadds=args.coadds, ellipse=args.ellipse,
            htmlplots=args.htmlplots, htmlindex=args.htmlindex,
            no_groups=no_groups, clobber=args.clobber,
            verbose=args.verbose, datadir=datadir, htmldir=htmldir,
            size=size, mp=args.mp)

        if args.htmlindex:
            from SGA.html import make_html
            make_html(sample[groups[0]], fullsample, mp=args.mp, clobber=args.clobber,
                      region=args.region, htmldir=htmldir)#, htmlhome=args.htmlhome)
            return

        if args.diameter_file or args.galaxylist_file:
            if len(groups) > 0:
                todo = np.hstack(groups)
                if args.diameter_file:
                    with open(args.diameter_file, 'w') as F:
                        for diam in sample[DIAMCOLUMN][todo].value:
                            F.write(f'{diam}\n')
                    log.info(f'Wrote {len(todo):,d} objects to {args.diameter_file}')
                elif args.galaxylist_file:
                    with open(args.galaxylist_file, 'w') as F:
                        for gal, diam in zip(sample['GROUP_NAME'][todo].value, sample['GROUP_DIAMETER'][todo].value):
                            F.write(f'{gal},{diam}\n')
                    log.info(f'Wrote {len(todo):,d} objects to {args.galaxylist_file}')
            else:
                log.warning('All done!')
            return
    else:
        groups, suffix = [], ''

    if comm:
        groups = comm.bcast(groups, root=0)
        suffix = comm.bcast(suffix, root=0)

    # Report summary (rank 0 only)
    if rank == 0:
        nwait = len(wait[rank])
        ntodo = len(np.hstack(groups)) if len(groups) > 0 else 0
        if nwait > 0:
            log.info(f'{suffix.upper()} waiting for previous stage: {nwait:,d} / ' + \
                     f'{len(sample):,d}')
        log.info(f'{suffix.upper()} left to do: {ntodo:,d} / ' + \
                 f'{len(sample):,d} divided across {size} rank(s).')

    if comm:
        comm.barrier()

    # Determine if this rank has work
    has_work = len(groups) > 0 and len(groups[rank]) > 0

    # Report completion status for this rank
    if not has_work:
        log.info(f'{suffix.upper()} for all {len(sample):,d} galaxies on rank ' + \
                 f'{rank} are complete!')
        if rank == 0 and len(fail[rank]) > 0:
            log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                     f'{len(sample):,d}')
            galaxy, galaxydir = get_galaxy_galaxydir(
                sample[fail[rank]], region=args.region,
                group=not no_groups, datadir=datadir, htmldir=htmldir)
            for ii, dd, obj, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                         sample['OBJNAME'][fail[rank]],
                                         sample[DIAMCOLUMN][fail[rank]]):
                print(f'  {ii} {dd} [{obj} D={diam:.3f} arcmin]')
        return
    else:
        log.info(f' Rank {rank}: {len(groups[rank]):,d} galaxies left to do.')

    # Handle special modes (rank 0 only)
    if rank == 0:
        # Always report failures if present
        if len(fail[rank]) > 0:
            log.info(f'{suffix.upper()} failures: {len(fail[rank]):,d} / ' + \
                     f'{len(sample):,d}')
            galaxy, galaxydir = get_galaxy_galaxydir(
                sample[fail[rank]], region=args.region,
                group=not no_groups, datadir=datadir, htmldir=htmldir)
            for ii, dd, obj, diam in zip(fail[rank], np.atleast_1d(galaxydir),
                                         sample['OBJNAME'][fail[rank]],
                                         sample[DIAMCOLUMN][fail[rank]]):
                print(f'  {ii} {dd} [{obj} D={diam:.3f} arcmin]')

        # Analysis mode
        if args.analyze and args.coadds and has_work:
            todo = np.hstack(groups)
            galaxy, galaxydir = get_galaxy_galaxydir(
                sample[todo], region=args.region,
                group=not no_groups, datadir=datadir, htmldir=htmldir)
            sort_groups_by_attempts(galaxy, galaxydir, sample[todo], diamcolumn=DIAMCOLUMN)

        # Debug mode: print detailed todo list
        if args.count and args.debug and has_work:
            todo = np.hstack(groups)
            log.info(f'{suffix.upper()} todo: {len(todo):,d} / {len(sample):,d}')
            galaxy, galaxydir = get_galaxy_galaxydir(
                sample[todo], region=args.region,
                group=not no_groups,
                datadir=datadir, htmldir=htmldir)
            for ii, dd, obj, diam in zip(todo, np.atleast_1d(galaxydir),
                                         sample['OBJNAME'][todo],
                                         sample[DIAMCOLUMN][todo]):
                log.info(f'{dd} [{obj} D={diam:.3f} arcmin]')
                #print(dd)

    # Exit early for count/analyze modes
    if args.count or (args.analyze and args.coadds):
        return

    # Loop on the remaining objects.
    log.info(f'Starting {len(groups[rank])} {suffix.upper()} ' + \
             f'on rank {rank} with {args.mp} cores on {time.asctime()}')

    # The rest of the pipeline--
    t0 = time.time()
    if rank == 0:
        tall = time.time()

    for count, ii in enumerate(groups[rank]):
        onegal = sample[ii]
        galaxy, galaxydir, htmlgalaxydir = get_galaxy_galaxydir(
            onegal, region=args.region, group=not no_groups,
            html=True, datadir=datadir, htmldir=htmldir)
        if not os.path.isdir(galaxydir):
            os.makedirs(galaxydir, exist_ok=True)

        log.info(f'Rank {rank:03d} ({count+1} / {len(groups[rank])}): ' + \
                 f'{galaxydir} [{onegal["OBJNAME"]} D={onegal[DIAMCOLUMN]:.3f} arcmin]')

        logfile = get_logfile(galaxy, galaxydir, suffix)
        fh = setup_logging(logfile, debug=args.debug)
        if not args.debug:
            log.info(f'Logging output to {logfile}')

        # Need the object "radius" to build the coadds.
        if no_groups:
            multiplicity = 1
        else:
            multiplicity = onegal['GROUP_MULT']

        radius_mosaic_arcsec = get_radius_mosaic(onegal[DIAMCOLUMN], # diam in arcmin
                                                 multiplicity=multiplicity)

        survey = get_survey(run, allbands=bands, output_dir=galaxydir)

        if args.coadds:
            from SGA.coadds import custom_coadds
            # SGA fitting modes

            # RESOLVED sources: no fitting, just coadds (and should
            # always have GROUP_MULT==1)
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED'] != 0:
                just_cutouts = True
                ivar_cutouts = False
                layer = f'ls-{args.region}'
                if args.region == 'dr11-south':
                    log.warning(f"WARNING: Overriding layer={layer}-->ls-dr11-early-v2")
                    layer = 'ls-dr11-early-v2'

                if np.any(np.isin(onegal['OBJNAME'], ['LMC', 'SMC', 'Antlia II'])):
                    #pixscale = 60. # [arcsec]
                    pixscale = args.pixscale * 100               # [arcsec]
                    galex_pixscale = args.galex_pixscale * 100
                    unwise_pixscale = args.unwise_pixscale * 100
                elif np.any(np.isin(onegal['OBJNAME'], ['Crater II', 'Bootes III'])):
                    #pixscale = 10. # [arcsec]
                    pixscale = args.pixscale * 50               # [arcsec]
                    galex_pixscale = args.galex_pixscale * 50
                    unwise_pixscale = args.unwise_pixscale * 50
                else:
                    pixscale = args.pixscale
                    galex_pixscale = args.galex_pixscale
                    unwise_pixscale = args.unwise_pixscale
            else:
                pixscale = args.pixscale
                galex_pixscale = args.galex_pixscale
                unwise_pixscale = args.unwise_pixscale
                if args.skip_tractor:
                    just_cutouts = True
                    ivar_cutouts = True
                    layer = f'ls-{args.region}'
                    if args.region == 'dr11-south':
                        log.warning(f"WARNING: Overriding layer={layer}-->ls-dr11-early-v2")
                        layer = 'ls-dr11-early-v2'
                else:
                    just_cutouts = False
                    ivar_cutouts = False
                    layer = None

            # FORCEGAIA (not yet implemented); may be useful for e.g., Leo I
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['FORCEGAIA'] != 0:
                pass

            # FORCEPSF
            if onegal['ELLIPSEMODE'] & ELLIPSEMODE['FORCEPSF'] != 0:
                force_psf_detection = True
            else:
                force_psf_detection = False

            ## for very large mosaics, turn off iterative source detection and increase nsigma
            #if onegal[DIAMCOLUMN] > 5.:
            #    no_iterative = True
            #    if args.nsigma is None:
            #        nsigma = 10
            #    else:
            #        nsigma = args.nsigma
            #    fit_on_coadds = True
            #else:
            #    no_iterative = args.no_iterative
            #    nsigma = args.nsigma
            #    fit_on_coadds = args.fit_on_coadds

            no_iterative = True
            nsigma = 10
            fit_on_coadds = True
            saddle_fraction = 0.2
            saddle_min = 4.

            if not just_cutouts:
                log.info(f'Forcing --fit-on-coadds, --no-iterative and nsigma={nsigma:.0f} for all sources!')

            if args.debug:
                err, _ = custom_coadds(
                    onegal, galaxy, survey, run, radius_mosaic_arcsec,
                    release=release, pixscale=pixscale, bands=bands, mp=args.mp,
                    unwise_pixscale=unwise_pixscale, galex_pixscale=galex_pixscale,
                    nsigma=nsigma, saddle_fraction=saddle_fraction, saddle_min=saddle_min,
                    just_coadds=args.just_coadds, force_psf_detection=force_psf_detection,
                    no_iterative=no_iterative,
                    fit_on_coadds=fit_on_coadds, just_cutouts=just_cutouts,
                    ivar_cutouts=ivar_cutouts,
                    use_gpu=args.use_gpu, ngpu=args.ngpu, layer=layer,
                    threads_per_gpu=args.threads_per_gpu,
                    force=args.force, cleanup=args.cleanup,
                    unwise=args.unwise, galex=args.galex,
                    verbose=args.verbose)
            else:
                from contextlib import redirect_stdout, redirect_stderr
                from wurlitzer import pipes
                with open(logfile, 'a', buffering=1) as L, pipes(stdout=L, stderr=L), \
                     redirect_stdout(L), redirect_stderr(L):
                    err, _ = custom_coadds(
                        onegal, galaxy, survey, run, radius_mosaic_arcsec,
                        release=release, pixscale=pixscale, bands=bands, mp=args.mp,
                        unwise_pixscale=unwise_pixscale, galex_pixscale=galex_pixscale,
                        nsigma=nsigma, saddle_fraction=saddle_fraction, saddle_min=saddle_min,
                        just_coadds=args.just_coadds, force_psf_detection=force_psf_detection,
                        no_iterative=no_iterative,
                        fit_on_coadds=fit_on_coadds, just_cutouts=just_cutouts,
                        ivar_cutouts=ivar_cutouts,
                        use_gpu=args.use_gpu, ngpu=args.ngpu, layer=layer,
                        threads_per_gpu=args.threads_per_gpu,
                        force=args.force, cleanup=args.cleanup,
                        unwise=args.unwise, galex=args.galex,
                        verbose=args.verbose)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.ellipse or args.htmlplots:
            from SGA.SGA import (REFIDCOLUMN, SBTHRESH, APERTURES,
                                 OPTMASKBITS, GALEXMASKBITS, UNWISEMASKBITS,
                                 read_multiband, unpack_maskbits)
            SGAMASKBITS = [OPTMASKBITS, ]
            if args.unwise:
                SGAMASKBITS += [UNWISEMASKBITS]
            if args.galex:
                SGAMASKBITS += [GALEXMASKBITS]


        if args.ellipse:
            from SGA.ellipse import ellipsefit_multiband

            if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-coadds.isdone')):
                log.warning('Coadds must be generated before running ellipse-fitting.')
                restore_logger(fh=fh, debug=args.debug)
                continue

            log.info(f'Working on {galaxydir}')

            # Always write out the individual galaxies for this mosaic
            # if doing ellipse-fitting to make sure we get the latest
            # catalog parameters.
            if no_groups:
                sample_thisgroup = Table(onegal)
            else:
                I = np.where(onegal['GROUP_NAME'] == fullsample['GROUP_NAME'])[0]
                sample_thisgroup = fullsample[I]

            samplefile = os.path.join(galaxydir, f'{galaxy}-sample.fits')
            #import fitsio
            #if len(sample_thisgroup) != len(fitsio.read(samplefile)):
            #    print(galaxydir)
            #continue

            log.info(f'Writing {len(sample_thisgroup)} galaxy(ies) to {samplefile}')
            tmpfile = samplefile+'.tmp'
            sample_thisgroup.write(tmpfile, overwrite=True, format='fits')
            os.rename(tmpfile, samplefile)

            #print('Temporarily make htmlgalaxydir here')
            #if not os.path.isdir(htmlgalaxydir):
            #    os.makedirs(htmlgalaxydir, exist_ok=True)

            if args.debug:
                args.qaplot = False # True # always

            skip_ellipse = skip_ellipse_or_not(onegal)

            # Find other objects not in this group (excluding RESOLVED
            # sources) which may contaminate the actual group members.
            minsep = (0.5 * u.deg) # 5. * u.arcmin
            c_thisgroup = SkyCoord(onegal[RACOLUMN]*u.deg, onegal[DECCOLUMN]*u.deg)
            Imask_nearby = (c_thisgroup.separation(c_fullsample) < minsep * # separation < 1 degree
                            ~np.isin(fullsample[REFIDCOLUMN], sample_thisgroup[REFIDCOLUMN]) *
                            ((fullsample['ELLIPSEMODE'] & ELLIPSEMODE['RESOLVED']) == 0))
            if np.any(Imask_nearby):
                mask_nearby = fullsample['OBJNAME', 'RA', 'DEC', 'DIAM', 'BA', 'PA'][Imask_nearby]
            else:
                mask_nearby = None

            err = ellipsefit_multiband(galaxy, galaxydir, REFIDCOLUMN, read_multiband,
                                       unpack_maskbits, SGAMASKBITS, region=args.region,
                                       run=run, bands=bands, mp=args.mp, sbthresh=SBTHRESH,
                                       apertures=APERTURES, nmonte=args.nmonte, seed=args.seed,
                                       mask_nearby=mask_nearby, use_tractor_position=args.use_tractor_position,
                                       use_radial_weight=args.use_radial_weight,
                                       pixscale=args.pixscale, unwise_pixscale=args.unwise_pixscale,
                                       galex_pixscale=args.galex_pixscale, unwise=args.unwise,
                                       galex=args.galex, qaplot=args.qaplot, verbose=args.verbose,
                                       clobber=args.clobber, skip_ellipse=skip_ellipse,
                                       skip_tractor=args.skip_tractor,
                                       htmlgalaxydir=htmlgalaxydir)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)


        if args.htmlplots:
            from SGA.html import make_plots

            skip_ellipse = skip_ellipse_or_not(onegal)
            if not skip_ellipse:
                if not os.path.isfile(os.path.join(galaxydir, f'{galaxy}-ellipse.isdone')):
                    log.warning('Ellipse-fitting must be done before generating plots.')
                    restore_logger(fh=fh, debug=args.debug)
                    continue

            if not os.path.isdir(htmlgalaxydir):
                os.makedirs(htmlgalaxydir, exist_ok=True)

            _, barlen, barlabel = get_radius_mosaic(
                onegal[DIAMCOLUMN], pixscale=args.pixscale, get_barlen=True)

            err = make_plots(galaxy, galaxydir, htmlgalaxydir, REFIDCOLUMN, read_multiband,
                             unpack_maskbits, SGAMASKBITS, APERTURES,
                             args.region, barlen=barlen, barlabel=barlabel,
                             run=run, skip_ellipse=skip_ellipse,
                             skip_tractor=args.skip_tractor,
                             bands=bands, mp=args.mp, pixscale=args.pixscale,
                             unwise=args.unwise, galex=args.galex,
                             verbose=args.verbose, clobber=args.clobber)
            done(galaxy, galaxydir, err, suffix, fh=fh, debug=args.debug)

    if len(groups[rank]) > 0:
        log.info(f'Rank {rank:03d} finished {len(groups[rank]):,d} object(s) ' + \
                 f'in {(time.time()-t0)/60.:.3f} minutes')

    if comm:
        comm.barrier()

    if rank == 0:
        log.info(f'Finished {ntodo} {suffix.upper()} at {time.asctime()} ' + \
                 f'after {(time.time()-tall)/60.:.3f} minutes')
        _, groups, _, _, _ = missing_files(sample=sample, region=args.region,
                                           bricks=bricks, coadds=args.coadds,
                                           ellipse=args.ellipse,
                                           htmlplots=args.htmlplots,
                                           htmlindex=args.htmlindex,
                                           #clobber=args.clobber,
                                           no_groups=no_groups,
                                           verbose=args.verbose,
                                           datadir=datadir, htmldir=htmldir,
                                           size=size, mp=args.mp)

        if len(groups) > 0:
            stilltodo = len(np.hstack(groups))
        else:
            stilltodo = 0
        log.info(f'{suffix.upper()} left to do: {stilltodo:,d} / {ntodo:,d}.')


if __name__ == '__main__':
    main()
