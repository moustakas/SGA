#!/usr/bin/env python
"""Parse the DR9/DR10 catalog of "large" (Tractor) galaxies produced
by DJS by looping over all sweep catalogs.

See /global/cfs/cdirs/cosmo/work/users/djschleg/sga/README for
details.

Read 245,706 objects from /global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/external/biggals-dr9.fits
Read 522,607 objects from /global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/external/biggals-dr10.fits
Trimming 202,044/768,313 ref_cat!="" and NOBS_[GRZ]>0 objects from the combined catalog.
Resolving 181,304 duplicates.
Unique catalog has 475,316 objects
Read 1,154,637 objects from /global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/SGA2025-parent-archive-v1.0.fits
Trimming 13,881/475,316 objects which match version=v1.0 parent catalog.
Trimming 416,646/461,435 objects with FITBITS>0
Trimming 582/44,789 objects with -1<g-r<2 and -2<r-z<2.5
Wrote /global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/external/dr910-supplement-v1.0.png
Wrote 44,207 objects to /global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/external/dr910-supplement-v1.0.fits

"""
import os, pdb
import numpy as np
import fitsio
from astropy.table import Table, vstack
from astrometry.libkd.spherematch import match_radec
import matplotlib.pyplot as plt

from SGA.io import radec_to_name
from SGA.parent import parent_version
from SGA.SGA import sga_dir, sga2025_name
from SGA.geometry import get_tractor_ellipse

cols = ['RELEASE', 'BRICKID', 'BRICKNAME', 'OBJID',
        'RA', 'DEC', 'TYPE', 'SERSIC', 'SHAPE_R', 'SHAPE_E1', 'SHAPE_E2',
        'REF_CAT', 'FITBITS', 'NOBS_G', 'NOBS_R', 'NOBS_Z',
        'FLUX_G', 'FLUX_R', 'FLUX_Z', 'FLUX_IVAR_G', 'FLUX_IVAR_R', 'FLUX_IVAR_Z']

dr9file = os.path.join(sga_dir(), 'parent', 'external', 'biggals-dr9.fits')
dr10file = os.path.join(sga_dir(), 'parent', 'external', 'biggals-dr10.fits')

dr9 = Table(fitsio.read(dr9file, columns=cols))
dr9['DR'] = 'DR9'
dr9['ROW'] = np.arange(len(dr9))
print(f'Read {len(dr9):,d} objects from {dr9file}')

dr10 = Table(fitsio.read(dr10file, columns=cols))
dr10['DR'] = 'DR10'
dr10['ROW'] = np.arange(len(dr10))
print(f'Read {len(dr10):,d} objects from {dr10file}')

# stack and apply some basic cuts
dr = vstack((dr9, dr10))

snrcut = 1.
#rmagcut = 22.
#rfluxcut = 10.**(-0.4*(rmagcut-22.5))

I = ((dr['REF_CAT'] == '  ') *
     (dr['NOBS_G'] > 0) * (dr['NOBS_R'] > 0) * (dr['NOBS_Z'] > 0) *
     #(dr['FLUX_R'] > rfluxcut) *
     (dr['FLUX_G']*np.sqrt(dr['FLUX_IVAR_G']) > snrcut) *
     (dr['FLUX_R']*np.sqrt(dr['FLUX_IVAR_R']) > snrcut) *
     (dr['FLUX_Z']*np.sqrt(dr['FLUX_IVAR_Z']) > snrcut) *
     np.logical_or.reduce((dr['NOBS_G'] > 1, dr['NOBS_R'] > 1, dr['NOBS_Z'] > 1)))
print(f'Trimming {np.sum(~I):,d}/{len(dr):,d} ref_cat!="" ' + \
      'and NOBS_[GRZ]>0 objects from the combined catalog.')
dr = dr[I]

# resolve duplicates using SGANAME, which is precise to ~3.5 arcsec,
# but then choose based on NOBS
dr['NOBS'] = dr['NOBS_G'].value + dr['NOBS_R'].value + dr['NOBS_Z'].value
dr['SGANAME'] = sga2025_name(dr['RA'].value, dr['DEC'])
uname, uindx, cc = np.unique(dr['SGANAME'].value, return_counts=True, return_index=True)
#print(uname[cc>1])
#cat = dr[uindx]

cat_nodups = dr[np.isin(dr['SGANAME'], uname[cc==1])]

cat_dups = dr[np.isin(dr['SGANAME'], uname[cc>1])]
uname, cc = np.unique(cat_dups['SGANAME'].value, return_counts=True)
print(f'Resolving {np.sum(cc):,d} duplicates.')

# resolve doubles first
cat_doubles = cat_dups[np.isin(cat_dups['SGANAME'], uname[cc==2])]
cat_therest = cat_dups[np.isin(cat_dups['SGANAME'], uname[cc>2])]

# every other double (starting from 1) will have the largest value of NOBS
srt = np.lexsort((cat_doubles['NOBS'], cat_doubles['SGANAME']))
cat_doubles = cat_doubles[srt]
assert(np.all(cat_doubles['SGANAME'][::2] == cat_doubles['SGANAME'][1::2]))
cat = vstack((cat_nodups, cat_doubles[1::2]))

uname, cc = np.unique(cat_therest['SGANAME'].value, return_counts=True)
keep = []
for name in uname:
    I = np.where(name == cat_therest['SGANAME'].value)[0]
    J = np.argmax(cat_therest['NOBS'][I])
    keep.append(cat_therest[I[J]])
    #if np.sum(I) > 3:
    #    pdb.set_trace()

keep = vstack(keep)
cat = vstack((cat, keep))
assert(len(np.unique(cat['SGANAME']) == len(cat)))
cat = cat[np.argsort(cat['SHAPE_R'])[::-1]]
print(f'Unique catalog has {len(cat):,d} objects')

cat.remove_columns(['NOBS_G', 'NOBS_R', 'NOBS_Z', 'REF_CAT'])

# match against the current parent catalog

version = parent_version(archive=True)
version = 'v1.0'
parentfile = os.path.join(sga_dir(), 'parent', f'SGA2025-parent-archive-{version}.fits')
parent = Table(fitsio.read(parentfile, columns=['OBJNAME', 'RA', 'DEC']))
print(f'Read {len(parent):,d} objects from {parentfile}')
m1, m2, _ = match_radec(cat['RA'], cat['DEC'], parent['RA'], parent['DEC'], 10./3600., nearest=True)
print(f'Trimming {len(m2):,d}/{len(cat):,d} objects which match version={version} parent catalog.')
cat = cat[np.delete(np.arange(len(cat)), m1)]

#_, ba, pa = get_tractor_ellipse(cat['SHAPE_R'], cat['SHAPE_E1'], cat['SHAPE_E2'])
#cat['DIAM'] = cat['SHAPE_R'] * 2. / 60.
#cat['BA'] = ba
#cat['PA'] = pa

I = cat['FITBITS'] == 0
print(f'Trimming {np.sum(~I):,d}/{len(cat):,d} objects with FITBITS>0')
cat = cat[I]
cat.remove_column('FITBITS')

gmag = 22.5-2.5*np.log10(cat['FLUX_G'])
rmag = 22.5-2.5*np.log10(cat['FLUX_R'])
zmag = 22.5-2.5*np.log10(cat['FLUX_Z'])
rz = rmag-zmag
gr = gmag-rmag

grmin = -1.
grmax = 2.5
rzmin = -2.
rzmax = 2.5
rmagcut = 22.5
gmagcut = rmagcut - grmin
zmagcut = rmagcut - rzmin

I = ((gr > grmin) * (gr < grmax) * (rz > rzmin) * (rz < rzmax) * \
     (rmag < rmagcut) * (gmag < gmagcut) * (zmag < zmagcut))
print(f'Trimming {np.sum(~I):,d}/{len(cat):,d} objects with ' + \
      f'{grmin:.0f}<g-r<{grmax:.0f} and {rzmin:.0f}<r-z<{rzmax}')
cat = cat[I]

gmag = 22.5-2.5*np.log10(cat['FLUX_G'])
rmag = 22.5-2.5*np.log10(cat['FLUX_R'])
zmag = 22.5-2.5*np.log10(cat['FLUX_Z'])
rz = rmag-zmag
gr = gmag-rmag

# generate a fully-populated catalog
out = []
for dr, drfile in zip(['DR9', 'DR10'], [dr9file, dr10file]):
    rows = cat['ROW'][cat['DR'] == dr]
    out.append(Table(fitsio.read(drfile, rows=rows)))
out = vstack(out)
out.add_column(sga2025_name(out['RA'].value, out['DEC'].value), name='SGANAME', index=0)
out.add_column(radec_to_name(out['RA'].value, out['DEC'].value, prefix='DESI'), name='DESINAME', index=0)
cat = out

version = 'v1.0'
pngfile = os.path.join(sga_dir(), 'parent', 'external', f'dr910-supplement-{version}.png')
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))

for drpre, dr in zip([9, 10], ['DR9', 'DR10']):
    I = cat['RELEASE']//1000 == drpre

    ax1.scatter(cat['RA'][I], cat['DEC'][I], s=1, alpha=0.5)
    ax2.scatter(rmag[I], 2.*1.2*cat['SHAPE_R'][I]/60., s=1, alpha=0.5, label=dr)
    ax3.scatter(rz[I], gr[I], alpha=0.5, s=1)
    #ax3.axhline(y=-2, color='k')
    #ax3.axhline(y=2.5, color='k')
    #ax3.axvline(x=-2, color='k')
    #ax3.axvline(x=2.5, color='k')

ax1.set_xlabel('RA')
ax1.set_ylabel('Dec')
ax1.set_ylim(-90, 90)
ax1.set_xlim(360, 0)

ax2.set_xlabel('r (AB mag)')
ax2.set_ylabel(r'$1.2\times2\times$shape_r (arcmin)')
ax2.axhline(y=1.2*2*10./60., color='k')

ax3.set_xlabel('r - z')
ax3.set_ylabel('g - r')
ax2.legend(loc='upper right')

fig.suptitle(f'DR9/DR10 SGA-2025 Candidates (N={len(cat):,d})')
fig.tight_layout()
fig.savefig(pngfile)
print(f'Wrote {pngfile}')

outfile = os.path.join(sga_dir(), 'parent', 'external', f'dr910-supplement-{version}.fits')
print(f'Wrote {len(cat):,d} objects to {outfile}')
cat.write(outfile, overwrite=True)
