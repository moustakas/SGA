#!/usr/bin/env python

"""MPI wrapper to get a large number of image cutouts.

Working interactively in a login node, one would do something like:

  shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh --image dstndstn/cutouts:dvsro bash
  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1
  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1 --annotate

Alternatively, in production, one would do:

  salloc -N 1 -C cpu -A desi -t 04:00:00 --qos interactive --image=docker:dstndstn/cutouts:dvsro
  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=4 > \
    /pscratch/sd/i/ioannis/SGA2025/cutouts/SGA2025-cutouts-parent-north-native-JOBID.log 2>&1 &

  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=4 --rescale > \
    /pscratch/sd/i/ioannis/SGA2025/cutouts/SGA2025-cutouts-parent-north-rescale-JOBID.log 2>&1 &

To build the ssl-legacysurvey catalog:
  SGA2025-shifter

  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --ssl-legacysurvey


"""
import pdb # for debugging

import os, sys, time
import numpy as np
import fitsio
from astropy.table import Table
import multiprocessing

from astrometry.libkd.spherematch import match_radec

from SGA.io import custom_brickname, get_raslice
from SGA.util import radec_to_name, choose_geometry, parse_geometry


def _get_annotate_one(args):
    return get_annotate_one(*args)


def get_annotate_one(obj, objname, indir, outdir, overwrite=False, verbose=False):
    raslice = get_raslice(obj['RA'])

    if objname is None:
        brick = custom_brickname(obj['RA'], obj['DEC'])
        jpgfile = os.path.join(indir, raslice, brick[:6], f'{brick}.jpeg')
        pngfile = os.path.join(outdir, raslice, brick[:6], f'{brick}.png')
    else:
        jpgfile = os.path.join(indir, raslice, f'{objname}.jpeg')
        pngfile = os.path.join(outdir, raslice, f'{objname}.png')
    nobj = 1

    if overwrite is False:
        if os.path.isfile(pngfile):
            nobj = 0
            if verbose:
                print(f'Skipping existing annotated cutout {pngfile}')
    else:
        if not os.path.isfile(jpgfile):
            nobj = 0
            print(f'Missing input cutout {jpgfile}')

    return jpgfile, pngfile, nobj


def _annotate_one(args):
    return annotate_one(*args)


def annotate_one(jpgfile, pngfile, objname, commonname, pixscale,
                 mosaic_diam, primary, group, dry_run, rank, iobj):
    """Annotate one image.

    """
    #from PIL import Image, ImageDraw
    #from astropy.io import fits
    #from astropy.wcs import WCS
    #import astropy.units as u
    #from astropy.coordinates import SkyCoord
    #from SGA.qa import draw_ellipse_on_png#, addbar_to_png

    import matplotlib.pyplot as plt
    import matplotlib.image as mpimg
    from matplotlib.patches import Circle, Ellipse
    from matplotlib.lines import Line2D
    from urllib.request import urlretrieve
    from astropy.wcs import WCS
    from astropy.io import fits

    def get_wcs(racenter, deccenter, width):
        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = racenter
        hdr['CRVAL2'] = deccenter
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600.
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600.
        return WCS(hdr)


    def draw_ellipse(diam, ba, pa, pixscale, xpix, ypix, color, linestyle):
        semimajor = diam / pixscale # [pixels]
        semiminor = ba * semimajor  # [pixels]
        theta = np.radians(90.-pa)
        x0 = xpix
        y0 = width - ypix

        ax.add_artist(Ellipse((x0, y0), semimajor, semiminor, angle=90.-pa,
                              facecolor='none', edgecolor=color, lw=1.5, ls=linestyle, 
                              alpha=0.9, clip_on=True))

        x1, y1 = x0 + semimajor/2. * np.cos(theta), y0 + semimajor/2. * np.sin(theta)
        x2, y2 = x0 - semimajor/2. * np.cos(theta), y0 - semimajor/2. * np.sin(theta)
        x3, y3 = x0 + semiminor/2. * np.sin(theta), y0 - semiminor/2. * np.cos(theta)
        x4, y4 = x0 - semiminor/2. * np.sin(theta), y0 + semiminor/2. * np.cos(theta)
        
        # Draw the major and minor axes
        ax.plot([x1, x2], [y1, y2], lw=0.5, color=color, ls='-')#ls=linestyle)
        ax.plot([x3, x4], [y3, y4], lw=0.5, color=color, ls='-')#ls=linestyle)

    #sns, colors = plot_style(talk=True, font_scale=1.0)

    if not os.path.isfile(jpgfile):
        return

    bbox = dict(boxstyle='round', facecolor='k', alpha=0.5)
    ref_pixscale = 0.262
    #barlen = np.ceil(30 / pixscale) # [pixels]
    #barlabel = '' # '30 arcsec'

    N = len(group)
    primary_ra, primary_dec = primary['RA'], primary['DEC']

    img = mpimg.imread(jpgfile)
    width = img.shape[0]
    wcs = get_wcs(primary_ra, primary_dec, width)

    ellipse_colors = {'RC3': 'yellow', 'SGA2020': 'dodgerblue', 'HYPERLEDA': 'red', 'LIT': 'green'}
    ellipse_linestyles = {'RC3': 'solid', 'SGA2020': 'dashed', 'HYPERLEDA': 'dashdot', 'LIT': 'dotted'}

    outdir = os.path.dirname(pngfile)
    if not os.path.isdir(outdir):
        os.makedirs(outdir)

    fig, ax = plt.subplots(figsize=(8, 8))
    ax.imshow(img, origin='lower')
    #for ra, dec, diam, ba, pa in zip(ras, decs, diams, bas, pas):
    for onegal in group:
        #label = f'{mem["OBJNAME"]} ({mem["OBJTYPE"]}): D={mem["DIAM"]:.3g}\nPGC {mem["PGC"]}: D(LEDA)={mem["DIAM_LEDA"]:.3g})'

        ra = onegal['RA']
        dec = onegal['DEC']
        xpix, ypix = wcs.wcs_world2pix(ra, dec, 1)
        if xpix < 0 or ypix < 0 or xpix > width or ypix > width:
            continue

        for ref in ['RC3', 'SGA2020', 'HYPERLEDA', 'LIT']:
        #for ref in ['RC3', 'SGA2020']:#, 'HYPERLEDA']:
        #for ref in ['SGA2020']:#, 'HYPERLEDA']:
            diam, ba, pa = parse_geometry(Table(onegal), ref)
            if diam > 0.:
                #print(onegal['OBJNAME'], ref, xpix, ypix, diam[0], ba[0], pa[0])
                draw_ellipse(diam[0], ba[0], pa[0], pixscale, xpix, ypix, 
                             color=ellipse_colors[ref], linestyle=ellipse_linestyles[ref])


    ax.invert_yaxis() # JPEG is flipped relative to my FITS WCS
    #print(ax.get_xlim(), ax.get_ylim())
    ax.set_title(f'{commonname}:{objname} ({primary_ra:.8f},{primary_dec:.8f})')
    ax.axis('off')
    fig.tight_layout()
    fig.savefig(pngfile, bbox_inches=0)#, dpi=200)
    plt.close()
    print(f'Wrote {pngfile}')

    #pdb.set_trace()


def do_annotate(cat, objname, commonname, diam, pixscale=0.262, 
                comm=None, mp=1, indir='.', outdir='.', overwrite=False, 
                dry_run=False, verbose=False):
    """Wrapper to set up the full set of annotations.

    """
    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    t0 = time.time()
    if rank == 0:
        jpgfiles, pngfiles, groups = plan(
            cat, objname, comm=comm, outdir=outdir, 
            indir=indir, overwrite=overwrite, mp=mp, 
            verbose=verbose, annotate=True)
        print(f'Planning took {time.time() - t0:.2f} sec')
    else:
        jpgfiles, pngfiles, groups = [], [], []

    if comm:
        jpgfiles = comm.bcast(jpgfiles, root=0)
        pngfiles = comm.bcast(pngfiles, root=0)
        groups = comm.bcast(groups, root=0)
    sys.stdout.flush()

    # all done
    if len(jpgfiles) == 0 or len(np.hstack(jpgfiles)) == 0:
        return
        
    assert(len(groups) == size)

    print(f'Rank {rank} started at {time.asctime()}')
    sys.stdout.flush()

    indx = groups[rank]

    if np.isscalar(pixscale):
        in_pixscale = [pixscale] * len(indx)
    else:
        in_pixscale = pixscale

    mpargs = []
    for iobj in indx:
        # find nearby objects
        if diam[iobj]/60 < 5.:
            print('HACK!!')
            continue
        m1, m2, _ = match_radec(cat[iobj]['RA'], cat[iobj]['DEC'], 
                                cat['RA'], cat['DEC'], 2.*diam[iobj]/3600.)
        #if len(m2) == 1:
        #    continue
        #group = (cat[m2]['RA'].value, cat[m2]['DEC'].value, diam[m2], ba[m2], pa[m2])
        primary = cat[iobj]
        group = cat[m2]
        mpargs.append((jpgfiles[iobj], pngfiles[iobj], objname[iobj], commonname[iobj], 
                       in_pixscale[iobj], diam[iobj], primary, group, dry_run, rank, iobj))
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            P.map(_annotate_one, mpargs)
    else:
        [annotate_one(*mparg) for mparg in mpargs]

    #print(f'  rank {rank} is done')
    sys.stdout.flush()

    if comm is not None:
        comm.barrier()

    if rank == 0 and not dry_run:
        print(f'All done at {time.asctime()}')
    

def _cutout_one(args):
    return cutout_one(*args)


def cutout_one(basefile, ra, dec, width, pixscale, layer, dry_run, rank, iobj):
    """
    pixscale = 0.262
    width = int(30 / pixscale)   # =114
    height = int(width / 1.3) # =87 [3:2 aspect ratio]

    shifterimg pull dstndstn/viewer-cutouts:latest
    shifter --image dstndstn/viewer-cutouts cutout --output cutout.jpg --ra 234.2915 --dec 16.7684 --size 256 --layer ls-dr9 --pixscale 0.262 --force

    """
    from cutout import cutout

    for suffix in ['.jpeg', '.fits']:
        outfile = basefile+suffix
        #outfile = f'"{basefile}{suffix}"'
        cmdargs = f'--output={outfile} --ra={ra} --dec={dec} --size={width} ' + \
            f'--layer={layer} --pixscale={pixscale} --force'
        if dry_run:
            if suffix == '.jpeg':
                print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')            
        else:
            if suffix == '.jpeg':
                outdir = os.path.dirname(basefile)
                if not os.path.isdir(outdir):
                    os.makedirs(outdir, exist_ok=True)
            try:
                cutout(ra, dec, outfile, size=width, layer=layer, pixscale=pixscale, force=True)
                if suffix == '.jpeg':
                    print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')
            except:
                if suffix == '.jpeg':
                    print(f'WARNING: Rank {rank}, object {iobj} off the footprint: cutout {cmdargs}')                


def _get_basefiles_one(args):
    return get_basefiles_one(*args)


def get_basefiles_one(obj, objname, outdir, overwrite=False, verbose=False):
    raslice = get_raslice(obj['RA'])

    if objname is None:
        brick = custom_brickname(obj['RA'], obj['DEC'])
        basefile = os.path.join(outdir, raslice, brick[:6], brick)
    else:
        basefile = os.path.join(outdir, raslice, objname)
    nobj = 1

    if overwrite is False:
        if os.path.isfile(basefile+'.fits') and os.path.isfile(basefile+'.jpeg'):
            nobj = 0
            if verbose:
                print(f'Skipping existing cutout {basefile}.')

    return basefile, obj['RA'], obj['DEC'], nobj


def plan(cat, objname, layer='ls-dr9', comm=None, indir='.', outdir='.', 
         mp=1, annotate=False, overwrite=False, verbose=False):
    """Build a plan!

    """
    t0 = time.time()
    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    if annotate:
        mpargs = [(obj, objname1, indir, outdir, overwrite, verbose) 
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_annotate_one, mpargs)
        else:
            out = [get_annotate_one(*mparg) for mparg in mpargs]
        out = list(zip(*out))
    
        jpgfiles = np.array(out[0], dtype=object)
        pngfiles = np.array(out[1], dtype=object)
        nobj = np.array(out[2], dtype=object)
    else:
        mpargs = [(obj, objname1, outdir, overwrite, verbose) 
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_basefiles_one, mpargs)
        else:
            out = [get_basefiles_one(*mparg) for mparg in mpargs]
        out = list(zip(*out))
    
        basefiles = np.array(out[0], dtype=object)
        allra = np.array(out[1], dtype=object)
        alldec = np.array(out[2], dtype=object)
        nobj = np.array(out[3], dtype=object)

    iempty = np.where(nobj == 0)[0]
    if len(iempty) > 0:
        print(f'Skipping {len(iempty):,d} objects with existing cutouts.')

    itodo = np.where(nobj > 0)[0]
    if len(itodo) > 0:
        nobj = nobj[itodo]
        if annotate:
            print(f'Annotating {np.sum(nobj):,d} images.')
            jpgfiles = jpgfiles[itodo]
            pngfiles = pngfiles[itodo]
        else:
            print(f'Generating cutouts for {np.sum(nobj):,d} objects.')
            basefiles = basefiles[itodo]
            allra = allra[itodo]
            alldec = alldec[itodo]

        indices = np.arange(len(nobj))
        groups = np.array_split(indices, size) # unweighted distribution
    else:
        groups = [np.array([])]

    if annotate:
        return jpgfiles, pngfiles, groups
    else:
        return basefiles, allra, alldec, groups


def do_cutouts(cat, objname, layer='ls-dr9', width=152, pixscale=0.262, 
               comm=None, mp=1, outdir='.', overwrite=False, dry_run=False,
               verbose=False):

    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    t0 = time.time()
    if rank == 0:
        basefiles, allra, alldec, groups = plan(cat, objname, layer=layer, comm=comm, 
                                                outdir=outdir, overwrite=overwrite, mp=mp,
                                                verbose=verbose)
        print(f'Planning took {time.time() - t0:.2f} sec')
    else:
        basefiles, allra, alldec, groups = [], [], [], []

    if comm:
        basefiles = comm.bcast(basefiles, root=0)
        allra = comm.bcast(allra, root=0)
        alldec = comm.bcast(alldec, root=0)
        groups = comm.bcast(groups, root=0)
    sys.stdout.flush()
    
    # all done
    if len(basefiles) == 0 or len(np.hstack(basefiles)) == 0:
        return
        
    assert(len(groups) == size)

    print(f'Rank {rank} started at {time.asctime()}')
    sys.stdout.flush()

    indx = groups[rank]

    if np.isscalar(pixscale):
        in_pixscale = [pixscale] * len(indx)
    else:
        in_pixscale = pixscale

    if np.isscalar(width):
        in_width = [width] * len(indx)
    else:
        in_width = width

    mpargs = [(basefiles[iobj], allra[iobj], alldec[iobj], in_width[iobj], 
               in_pixscale[iobj], layer, dry_run, rank, iobj) for iobj in indx]
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            P.map(_cutout_one, mpargs)
    else:
        [cutout_one(*mparg) for mparg in mpargs]

    #print(f'  rank {rank} is done')
    sys.stdout.flush()

    if comm is not None:
        comm.barrier()

    if rank == 0 and not dry_run:
        print(f'All done at {time.asctime()}')


def read_catalog(catfile, ext=1, columns=None, rows=None):
    """Simple wrapper to read an input catalog.

    """
    if not os.path.isfile(catfile):
        print(f'Catalog {catfile} not found')
        return

    try:
        cat = Table(fitsio.read(catfile, ext=ext, rows=rows, columns=columns))
        print(f'Read {len(cat):,d} galaxies from {catfile}')
        return cat
    except:
        msg = f'Problem reading {args.catalog}'
        raise IOError(msg)


def get_pixscale_and_width(diam, mindiam, rescale=False, maxdiam_arcmin=5.,
                           default_width=152, default_pixscale=0.262):
    """Simple function to compute the pixel scale of the desired
    output images.

    """
    nobj = len(diam)

    if rescale:
        # scale the pixel scale so that larger objects "fit" in DEFAULT_WIDTH
        pixscale = default_pixscale * 2. * diam / mindiam   # [arcsec/pixel]
        width = np.zeros(nobj, int) + default_width # [pixels]
    else:
        # full-mosaic, native resolution width, except for objects
        # larger than XX arcmin
        pixscale = np.zeros(nobj) + default_pixscale # [arcsec/pixel]
        width = 2. * diam / pixscale # [pixels]
    
        maxdiam = maxdiam_arcmin * 60 # [arcsec]
        I = diam > maxdiam
        if np.any(I):
            pixscale[I] = default_pixscale * diam[I] / maxdiam
            width[I] = 2. * diam[I] / pixscale[I]
    
    width = width.astype(int)

    return pixscale, width


def build_ssl_legacysurvey(objname, cat, region='north', cutoutdir='.', outdir='.', 
                           overwrite=False, verbose=False):
    """Build the hdf5 file needed by ssl-legacysurvey.

    """
    nobj = len(cat)

    h5file = f'ssl-{region}.hdf5'
    if os.path.isfile(h5file) and not overwrite:
        log.warning(f'Skipping existing output file {h5file}.')
    try:
        F = h5py.File(h5file, 'w')

        pdb.set_trace()

        jpgfiles = [os.path.join(cutoutdir, get_raslice(ra), f'{objname}.jpeg') for ra in cat['RA'].value]

        images = F.create_dataset('images', (nsga + nobj, nband, ssl_width, ssl_width))
        F.create_dataset('row', data=np.hstack((sgaras, srcs['ra'].data)))
        F.create_dataset('ra', data=np.hstack((sgaras, srcs['ra'].data)))
        F.create_dataset('dec', data=np.hstack((sgadecs, srcs['dec'].data)))
        #F.create_dataset('ra', data=srcs['ra'].data)
        #F.create_dataset('dec', data=srcs['dec'].data)

        for isga, (sgaid, sgara, sgadec) in enumerate(zip(sgaids, sgaras, sgadecs)):
            coutoutfile = os.path.join(sgadir, get_raslice(sgara), f'SGA2020-{sgaid:06d}.fits')
            images[isga, :] = fitsio.read(coutoutfile)
    
        for iband, band in enumerate(bands):
            log.debug(f'Working on band {band}')
            imgfile = os.path.join(coaddsdir, 'coadd', subdir, brickname, f'legacysurvey-{brickname}-image-{band}.fits.fz')
            if not os.path.isfile(imgfile):
                log.info(f'Missing {imgfile}')
                continue

            # pad the image with zeros so we can get cutouts with impunity
            img = np.zeros((height + ssl_width, width + ssl_width), 'f4')
            img[ssl_width//2:height+ssl_width//2, ssl_width//2:width+ssl_width//2] = fitsio.read(imgfile)            
            
            for isrc, src in enumerate(srcs):
                # one-pixel offset?!?
                y1 = src['iby'] - ssl_width//2 + ssl_width//2
                y2 = src['iby'] + ssl_width//2 + ssl_width//2
                x1 = src['ibx'] - ssl_width//2 + ssl_width//2
                x2 = src['ibx'] + ssl_width//2 + ssl_width//2
                #print(isrc, y1, y2, x1, x2)
                cutout = img[y1:y2, x1:x2]
                assert(cutout.shape[0] == ssl_width and cutout.shape[1] == ssl_width)
                images[nsga + isrc, iband, :] = cutout
                
                #plt.clf() ; plt.imshow(np.log10(cutout), origin='lower') ; plt.savefig('/global/cfs/cdirs/desi/users/ioannis/tmp/junk2.png')
                #pdb.set_trace()
    except:
        msg = f'Problem generating HDF5 dataset {h5file}!'
        log.critical(msg)
        raise ValueError(msg)

    F.close()
    log.info(f'Wrote {nobj} cutout(s) to {h5file}')

    #with h5py.File(h5file, 'r') as F:
    #    print(list(F['ra']))


def main():
    """Main wrapper.

    """
    import argparse    
    
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--catalog', type=str, default='sga2025-parent', choices=['sga2025-parent', 'sga2020'], help='Catalog to read.')
    parser.add_argument('--region', default='north', choices=['north', 'south'], type=str, help='Region to analyze (only for --catalog="sga2025-parent").')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--width', type=int, default=152, help='Default cutout width [pixels].')
    parser.add_argument('--pixscale', type=float, default=0.262, help='Default pixel scale [arcsec/pixel].')
    parser.add_argument('--version', default='v1.0', type=str, help='Version of the parent catalog to read (only for --catalog="sga2025-parent").')
    parser.add_argument('--outdir', default='./', type=str, help='Base output data directory.')

    parser.add_argument('--plan', action='store_true', help='Plan how many nodes to use and how to distribute the targets.')
    parser.add_argument('--annotate', action='store_true', help='Annotate the native-resolution cutouts.')
    parser.add_argument('--dry-run', action='store_true', help='Generate but do not run commands.')
    parser.add_argument('--rescale', action='store_true', help='Scale the pixel size.')
    parser.add_argument('--ssl-legacysurvey', action='store_true', help='Build the hdf5 file needed by ssl-legacysurvey.')
    parser.add_argument('--verbose', action='store_true', help='Be verbose.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite any existing output files.')
    
    args = parser.parse_args()

    #print('Hack!')
    #sys.path.append('/global/homes/i/ioannis/code/git/SGA/py')

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
    except ImportError:
        comm = None

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    if comm is None:
        rank = 0
    else:
        rank = comm.rank

    (cat, objname, commonname, layer, indir, outdir, cutoutdir,
     pixscale, width, diam) = [[]] * 10
    #(cat, objname, commonname, layer, indir, outdir, cutoutdir,
    # pixscale, width, diam, ba, pa) = [[]] * 12
    if rank == 0:
        if args.catalog == 'sga2025-parent':

            catfile = '/global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/' + \
                f'SGA2025-parent-{args.region}-{args.version}.fits'
            columns = ['OBJNAME', 'FILTERS', 'RA', 'DEC', 'DIAM_LIT_REF', 
                       'DIAM_LIT', 'BA_LIT', 'PA_LIT',
                       'DIAM_HYPERLEDA', 'BA_HYPERLEDA', 'PA_HYPERLEDA', 
                       'DIAM_SGA2020', 'BA_SGA2020', 'PA_SGA2020']

            F = fitsio.FITS(catfile)
            N = F[1].get_nrows()
            if False:
                S = 1000
                rng = np.random.default_rng(seed=1)
                rows = rng.choice(N, size=S, replace=False)
                rows = rows[np.argsort(rows)]
            else:
                rows = np.arange(N)

            cat = read_catalog(catfile, columns=columns, rows=rows)

            #cat = cat[np.isin(cat['OBJNAME'], ['NGC 2796', 'NGC 3104', 'Bootes IV Dwarf', 'Leo III', 'MESSIER 110'])]
            #cat = cat[cat['DIAM'] == 60.]
            if False:
                refcat = cat[(cat['DIAM_HYPERLEDA'] > 5.) * (cat['FILTERS'] == 'grz')]
                m1, m2, _ = match_radec(refcat['RA'], refcat['DEC'], cat['RA'], cat['DEC'], 5./60)
                cat = cat[m2]

            #cat = cat[(cat['OBJTYPE'] != 'GPair') * (cat['OBJTYPE'] != 'GTrpl') * cat['DIAM_LIT_REF'] == 'RC3') * (cat['FILTERS'] == 'grz')]
            #cat = cat[cat['OBJNAME'] == 'NGC 1020']
            #cat = cat[:8]
            #print(f'Trimming to {len(cat):,d} objects')

            commonname = cat['OBJNAME']
            objname = np.char.replace(radec_to_name(cat['RA'], cat['DEC']), ' ', '_')
            #objname = np.char.replace(cat['OBJNAME'].value, ' ', '_')

            if args.ssl_legacysurvey:
                cutoutdir = os.path.join(args.outdir, args.region, 'rescale')
            else:
                mindiam = args.width * args.pixscale # [arcsec]
                diam, ba, pa, ref = choose_geometry(cat, mindiam=mindiam)
    
                pixscale, width = get_pixscale_and_width(
                    diam, mindiam, rescale=args.rescale, 
                    default_width=args.width,
                    default_pixscale=args.pixscale)
    
                if args.annotate:
                    indir = os.path.join(args.outdir, args.region, 'native')
                    outdir = os.path.join(args.outdir, args.region, 'annotate')
                else:
                    layer = f'ls-dr9-{args.region}'
                    if args.region == 'south':
                        # FIXME - need DR10 CCDs file
                        #layer = f'ls-dr10-{args.region}'
                        pass
        
                    if args.rescale:
                        outdir = os.path.join(args.outdir, args.region, 'rescale')
                    else:
                        outdir = os.path.join(args.outdir, args.region, 'native')

        elif args.catalog == 'sga2020':
            catfile = '/global/cfs/cdirs/cosmo/data/sga/2020/SGA-2020.fits'
            columns = ['SGA_ID', 'GALAXY', 'RA', 'DEC']
            cat = read_catalog(catfile, ext='ELLIPSE', columns=columns)#, rows=np.arange(10))
            objname = [f'SGA2020-{sgaid:06d}' for sgaid in cat['SGA_ID']]

            layer = 'ls-dr9'

            #d26_pixels = cat['D26'] * 60 / args.pixscale # [pixels]
            #d26cut_arcmin = args.width * 1.5 * args.pixscale / 60
            #I = np.where(d26_pixels < (args.width * 1.5))[0] # no more than 50% larger than the default cutout width
            #I = rand.choice(I, 4096, replace=False)
            #print(f'Selecting {len(I):,d}/{len(cat):,d} SGA galaxies with cutout width < 1.5*{args.width} pixels (<{d26cut_arcmin:.2f} arcmin).')
            #out = cat[I]
        
    if comm is not None:
        cat = comm.bcast(cat, root=0)
        objname = comm.bcast(objname, root=0)
        commonname = comm.bcast(commonname, root=0)
        layer = comm.bcast(layer, root=0)
        outdir = comm.bcast(outdir, root=0)
        indir = comm.bcast(indir, root=0)
        cutoutdir = comm.bcast(cutoutdir, root=0)
        pixscale = comm.bcast(pixscale, root=0)
        width = comm.bcast(width, root=0)
        diam = comm.bcast(diam, root=0)
        #ba = comm.bcast(ba, root=0)
        #pa = comm.bcast(pa, root=0)

    if args.plan:
        if rank == 0:
            plan(cat, objname, layer=layer, comm=comm, indir=indir, outdir=outdir, 
                 mp=args.mp, annotate=args.annotate, overwrite=args.overwrite, 
                 verbose=args.verbose)
    elif args.ssl_legacysurvey:
        if rank == 0:
            build_ssl_legacysurvey(objname, cat, region=args.region, cutoutdir=cutoutdir, 
                                   outdir=args.outdir, overwrite=args.overwrite, verbose=args.verbose)
    else:
        if args.annotate:
            do_annotate(cat, objname, commonname, diam, pixscale=pixscale, 
                        mp=args.mp, comm=comm, indir=indir, outdir=outdir, 
                        overwrite=args.overwrite, dry_run=args.dry_run, verbose=args.verbose)
        else:
            do_cutouts(cat, objname, layer=layer, width=width, pixscale=pixscale, 
                       mp=args.mp, comm=comm, outdir=outdir, overwrite=args.overwrite,
                       dry_run=args.dry_run, verbose=args.verbose)

if __name__ == '__main__':
    main()
