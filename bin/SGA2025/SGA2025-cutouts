#!/usr/bin/env python

"""MPI wrapper to get a large number of image cutouts.

Working interactively in a login node, one would do something like:

  salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive
  SGA2025-shifter
  source $HOME/code/SGA/bin/SGA2025/SGA2025-env

  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/parent --region=dr11-south --mp=1
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/parent --region=dr11-south --mp=1 --annotate

  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/diamcut1 --region=dr11-south --mp=1 --photo --photo-version=v1.0
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/diamcut1 --region=dr11-south --mp=1 --gather-photo --photo-version=v1.0
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/diamcut1 --region=dr11-south --mp=1 --photo --photo-version=v1.0 --annotated-montage

  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/lvd --region=dr11-south --lvd --mp=32
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/lvd --region=dr11-south --lvd --mp=32 --photo --photo-version=lvd-v1.0

Alternatively, in production, one would do:

  salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive --image=docker:dstndstn/cutouts:dvsro4

  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/cutouts/parent --region=dr9-north --mp=4 > \
    $PSCRATCH/SGA2025-cutouts/cutouts/SGA2025-cutouts-parent-dr9-north-native-JOBID.log 2>&1 &

  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/cutouts/parent --region=dr9-north --mp=4 --rescale > \
    $PSCRATCH/SGA2025-cutouts/cutouts/SGA2025-cutouts-parent-dr9-north-rescale-JOBID.log 2>&1 &

###
To build the ssl-legacysurvey catalog:

  First generate the rescaled cutouts of everything:
    salloc -N 1 -C cpu -A m3592 -t 04:00:00 --qos interactive
    shifter --image dstndstn/cutouts:dvsro4 bash
    source $CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh

    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --region=dr9-north --rescale --mp=128
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --region=dr9-north --rescale --mp=128

    SGA2025-shifter
    source $HOME/code/git/SGA/bin/SGA2025/SGA2025-env

    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --build-ssl --ssl-version=v4
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --build-ssl --ssl-version=v3
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --build-ssl --ssl-version=v2
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --build-ssl --ssl-version=v1

  Investigate...
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --ssl --ssl-version=v3 --rescale --annotate --region=dr11-south --mp=32
    SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/ssl --ssl --ssl-version=v3 --rescale --annotated-montage --region=dr11-south --mp=32

###
LVD sample:
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/lvd --region=dr11-south --mp=32 --lvd
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/lvd --region=dr11-south --annotate --mp=32 --lvd
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/lvd --region=dr11-south --annotated-montage --lvd

###
Kim's wisesize project:
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/wisesize --wisesize --region=dr9-north --mp=32
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/wisesize --wisesize --region=dr9-north --annotate --annotate-central-only --mp=32
  SGA2025-cutouts --cutoutdir=$PSCRATCH/SGA2025-cutouts/wisesize --wisesize --region=dr9-north --annotated-montage

###
zooniverse project:
  SGA2025-cutouts --cutoutdir=/global/cfs/cdirs/cosmo/www/temp/SGA2025/zooniverse/project1 \
    --httpdir=https://portal.nersc.gov/project/cosmo/temp/SGA2025/zooniverse/project1 \
    --region=dr9-north --mp=32 --zooniverse
  SGA2025-cutouts --cutoutdir=/global/cfs/cdirs/cosmo/www/temp/SGA2025/zooniverse/project1 \
    --httpdir=https://portal.nersc.gov/project/cosmo/temp/SGA2025/zooniverse/project1 \
    --region=dr9-north --mp=32 --zooniverse --annotate
  SGA2025-cutouts --cutoutdir=/global/cfs/cdirs/cosmo/www/temp/SGA2025/zooniverse/project1 \
    --httpdir=https://portal.nersc.gov/project/cosmo/temp/SGA2025/zooniverse/project1 \
    --region=dr9-north --zooniverse --annotated-montage

"""
import pdb # for debugging
import os, re, sys, time
from glob import glob
import numpy as np
import fitsio

from SGA.geometry import choose_geometry

#from astropy.table import Table, vstack
#import astropy.units as u
#import multiprocessing
#
#from astrometry.libkd.spherematch import match_radec
#from astrometry.util.starutil_numpy import arcsec_between
#
#import warnings
#from astropy.io.fits.verify import VerifyWarning
#warnings.simplefilter('ignore', category=VerifyWarning)
#
#from SGA.io import sga_dir, custom_brickname, get_raslice, radec_to_name
#from SGA.ellipse import choose_geometry, parse_geometry
#from SGA.coadds import PIXSCALE, GALEX_PIXSCALE, UNWISE_PIXSCALE

from SGA.logger import log


def get_wcs(racenter, deccenter, width, pixscale=0.262):
    from astropy.wcs import WCS
    from astropy.io import fits
    hdr = fits.Header()
    hdr['NAXIS'] = 2
    hdr['NAXIS1'] = width
    hdr['NAXIS2'] = width
    hdr['CTYPE1'] = 'RA---TAN'
    hdr['CTYPE2'] = 'DEC--TAN'
    hdr['CRVAL1'] = racenter
    hdr['CRVAL2'] = deccenter
    hdr['CRPIX1'] = width/2+0.5
    hdr['CRPIX2'] = width/2+0.5
    hdr['CD1_1'] = -pixscale/3600.
    hdr['CD1_2'] = 0.0
    hdr['CD2_1'] = 0.0
    hdr['CD2_2'] = +pixscale/3600.
    return WCS(hdr)


def plan(cat, width=152, layer='ls-dr9', cutoutdir='.', annotatedir='.',
         photodir='.', size=1, mp=1, photo=False, gather_photo=False,
         annotate=False, fits_cutouts=True, unwise_cutouts=False,
         galex_cutouts=False, overwrite=False, verbose=False):
    """Build a plan!

    """
    t0 = time.time()

    objname = radec_to_name(cat['RA'], cat['DEC'], unixsafe=True)

    if photo or gather_photo:
        mpargs = [(obj, objname1, cutoutdir, photodir, gather_photo, overwrite, verbose)
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_photo_filename, mpargs)
        else:
            out = [get_photo_filename(*mparg) for mparg in mpargs]
        out = list(zip(*out))

        fitsfiles = np.array(out[0], dtype=object)
        jpgfiles = np.array(out[1], dtype=object)
        photfiles = np.array(out[2], dtype=object)
        qafiles = np.array(out[3], dtype=object)
        nobj = np.array(out[4], dtype=object)
    elif annotate:
        mpargs = [(obj, objname1, cutoutdir, annotatedir, overwrite, verbose)
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_annotate_filename, mpargs)
        else:
            out = [get_annotate_filename(*mparg) for mparg in mpargs]
        out = list(zip(*out))

        jpgfiles = np.array(out[0], dtype=object)
        pngfiles = np.array(out[1], dtype=object)
        nobj = np.array(out[2], dtype=object)
    else:
        if np.isscalar(width):
            width = [width] * len(objname)

        mpargs = [(obj, objname1, cutoutdir, width1, fits_cutouts, unwise_cutouts,
                   galex_cutouts, overwrite, verbose)
                  for obj, objname1, width1 in zip(cat, objname, width)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_basefiles_one, mpargs)
        else:
            out = [get_basefiles_one(*mparg) for mparg in mpargs]
        out = list(zip(*out))

        basefiles = np.array(out[0], dtype=object)
        allra = np.array(out[1], dtype=object)
        alldec = np.array(out[2], dtype=object)
        nobj = np.array(out[3], dtype=object)

    iempty = np.where(nobj == 0)[0]
    if len(iempty) > 0:
        if gather_photo:
            log.info(f'Missing {len(iempty):,d} photometry file(s).')
        elif photo:
            log.info(f'Skipping {len(iempty):,d} object(s) with existing photometry files (or missing FITS cutouts).')
        elif annotate:
            log.info(f'Skipping {len(iempty):,d} object(s) with existing annotated images.')
        else:
            log.info(f'Skipping {len(iempty):,d} object(s) with existing cutouts.')

    itodo = np.where(nobj > 0)[0]
    if len(itodo) > 0:
        if gather_photo:
            log.info(f'Gathered photometry file names for {np.sum(nobj[itodo]):,d} objects.')
        elif photo:
            log.info(f'Photometry files needed for {np.sum(nobj[itodo]):,d} objects.')
        elif annotate:
            log.info(f'Annotated images needed for {np.sum(nobj[itodo]):,d} objects.')
        else:
            log.info(f'Cutouts needed for {np.sum(nobj[itodo]):,d} objects.')
        groups = np.array_split(itodo, size) # unweighted distribution
    else:
        groups = [np.array([])]

    if photo or gather_photo:
        return fitsfiles, jpgfiles, photfiles, qafiles, groups
    elif annotate:
        return jpgfiles, pngfiles, groups
    else:
        return basefiles, allra, alldec, groups


def get_pixscale_and_width(diam, mindiam, rescale=False, maxdiam_arcmin=25.,
                           default_width=152, default_pixscale=0.262):
    """Simple function to compute the pixel scale of the desired
    output images.

    """
    nobj = len(diam)

    if rescale:
        # scale the pixel scale so that larger objects "fit" in DEFAULT_WIDTH
        pixscale = default_pixscale * 1.5 * diam / mindiam   # [arcsec/pixel]
        width = np.zeros(nobj, int) + default_width # [pixels]
    else:
        # full-mosaic, native resolution width, except for objects
        # larger than XX arcmin
        pixscale = np.zeros(nobj) + default_pixscale # [arcsec/pixel]
        width = 1.5 * diam / pixscale # [pixels]

        maxdiam = maxdiam_arcmin * 60. # [arcsec]
        I = diam > maxdiam
        if np.any(I):
            pixscale[I] = default_pixscale * diam[I] / maxdiam
            width[I] = 1.5 * diam[I] / pixscale[I]

    width = width.astype(int)

    return pixscale, width


def build_ssl_legacysurvey_refcat(cat, fullcat, ssl_version=None):
    """Build the reference catalog for use with ssl-legacysurvey

    v1 - original dr9-north and dr9-south version; mindiam = 10.
    v2 - like v1 but with mindiam = 30. (but did not perform well)
    v3 - like v1 but with dr9-north and dr11-south

    """
    def find_isolated(cat, fullcat, radius=90.):
        """Identify isolated sources.

        radius in arcsec

        """
        allmatches = match_radec(cat['RA'].value, cat['DEC'].value,
                                 fullcat['RA'].value, fullcat['DEC'].value,
                                 radius/3600., indexlist=True, notself=False)
        refindx = []
        for ii, mm in enumerate(allmatches):
            if len(mm) == 1:
                refindx.append(ii)
        refindx = np.array(refindx)
        return refindx


    # define the reference sample
    diam, _, _, ref = choose_geometry(cat, mindiam=0.)

    if ssl_version == 'v1':
        I = np.where((diam/60. > 1.5) * (diam/60. < 5.) * ~cat['RESOLVED'] *
                     (cat['STARFDIST'] > 1.5) * (cat['FILTERS'] == 'grz'))[0]
        # no other source (of any size) within 90 arcsec
        refindx = find_isolated(cat[I], fullcat, radius=90.)
        refcat = cat[I[refindx]]
    elif ssl_version == 'v2':
        I = np.where((diam/60. > 1.7) * (diam/60. < 5.) * ~cat['RESOLVED'] *
                     (cat['STARFDIST'] > 1.5) * (cat['FILTERS'] == 'grz'))[0]
        diam_full, _, _, _ = choose_geometry(fullcat, mindiam=0.)
        J = (diam_full > 30.) * (fullcat['FILTERS'] == 'grz')
        # no other source smaller than 30 arcsec within 90 arcsec
        refindx = find_isolated(cat[I], fullcat[J], radius=90.)
        refcat = cat[I[refindx]]
    elif ssl_version == 'v3':
        I = np.where((diam/60. > 1.7) * (diam/60. < 5.) * ~cat['RESOLVED'] *
                     (cat['STARFDIST'] > 1.5) * 
                     np.logical_or(cat['FILTERS'] == 'grz', cat['FILTERS'] == 'girz'))[0]
        diam_full, _, _, _ = choose_geometry(fullcat, mindiam=0.)
        J = (diam_full > 30.) * np.logical_or(fullcat['FILTERS'] == 'grz', fullcat['FILTERS'] == 'girz')
        # no other source smaller than 30 arcsec within 90 arcsec
        refindx = find_isolated(cat[I], fullcat[J], radius=90.)
        refcat = cat[I[refindx]]
    elif ssl_version == 'v4':
        pdb.set_trace()

    else:
        raise ValueError('Write me')

    #sslcols = ['OBJNAME', 'RA', 'DEC', 'FILTERS', 'ROW_PARENT', 'REGION']
    #refcat = refcat[sslcols]

    if ssl_version == 'v1':
        mindiam = 10.
        log.info('Trimming the ssl_legacysurvey sample to unresolved objects ' + \
                 f'smaller than {mindiam:.0f} arcsec.')
        I = (diam < mindiam) * (cat['FILTERS'] == 'grz') * ~cat['RESOLVED']
        cat = cat[I]
    elif ssl_version == 'v2':
        mindiam = 30.
        log.info('Trimming the ssl_legacysurvey sample to unresolved objects ' + \
                 f'smaller than {mindiam:.0f} arcsec.')
        I = (diam < mindiam) * (cat['FILTERS'] == 'grz') * ~cat['RESOLVED']
        cat = cat[I]
    elif ssl_version == 'v3':
        mindiam = 10.
        log.info('Trimming the ssl_legacysurvey sample to unresolved objects ' + \
                 f'smaller than {mindiam:.0f} arcsec.')
        I = (diam < mindiam) * np.logical_or(cat['FILTERS'] == 'grz', cat['FILTERS'] == 'girz') * ~cat['RESOLVED']
        cat = cat[I]
    else:
        raise ValueError('Write me')

    return refcat, cat


def build_ssl_legacysurvey(cat, fullcat, width=152, ncatmax=15000, ssl_version=None,
                           bands=['g', 'r', 'z'], outdir='.', verbose=False,
                           overwrite=False):
    """Build the hdf5 file needed by ssl-legacysurvey.

    nband = 3 (grz)
    ncatmax - maximum number of files per output catalog

    """
    import h5py

    def get_fitsfiles(cat, region):
        cutoutdir = os.path.join(outdir, region, 'rescale')
        I = []
        fitsfiles = []
        for ii, one in enumerate(cat):
            objname = radec_to_name(one['RA'], one['DEC'])[0].replace(' ', '_')
            fitsfile = os.path.join(cutoutdir, get_raslice(one['RA']), f'{objname}.fits')
            if os.path.isfile(fitsfile):
                I.append(ii)
                fitsfiles.append(fitsfile)
            else:
                log.info(f'Missing {fitsfile}')

        return np.array(fitsfiles), np.array(I)

    nband = len(bands)

    if ssl_version is None:
        log.warning('ssl_version must be specified')
        return

    # need to define a reference sample and make sure the files exist
    refcat, cat = build_ssl_legacysurvey_refcat(cat, fullcat, ssl_version=ssl_version)

    refcatfiles, refcatindx = [], []
    catfiles, catindx = [], []
    for region in sorted(set(refcat['REGION'])):
        R = np.where(refcat['REGION'] == region)[0]
        C = np.where(cat['REGION'] == region)[0]
        refcatfiles1, refcatindx1 = get_fitsfiles(refcat[R], region)
        catfiles1, catindx1 = get_fitsfiles(cat[C], region)
        refcatfiles.append(refcatfiles1)
        catfiles.append(catfiles1)
        refcatindx.append(R[refcatindx1])
        catindx.append(C[catindx1])

    refcatfiles = np.hstack(refcatfiles)
    catfiles = np.hstack(catfiles)
    refcatindx = np.hstack(refcatindx)
    catindx = np.hstack(catindx)

    cat = cat[catindx]
    refcat = refcat[refcatindx]
    ncat = len(cat)
    nrefcat = len(refcat)

    catdir = os.path.join(sga_dir(), 'ssl')#, ssl_version)

    refoutfile = os.path.join(catdir, f'ssl-parent-refcat-{ssl_version}.fits')
    if os.path.isfile(refoutfile):
        log.warning(f'Existing reference catalog {refoutfile} must be removed by-hand.')
        return
    outfile = os.path.join(catdir, f'ssl-parent-cat-{ssl_version}.fits')
    if os.path.isfile(outfile):
        log.warning(f'Existing catalog {outfile} must be removed by-hand.')
        return

    refcat.write(refoutfile, overwrite=True)
    log.info(f'Wrote {len(refcat):,d} objects to {refoutfile}')

    cat.write(outfile, overwrite=True)
    log.info(f'Wrote {len(cat):,d} objects to {outfile}')

    # Ensure each output file has no more than ncatmax objects, to we
    # don't run into memory problems at NERSC.
    nchunk = int(np.ceil(ncat / ncatmax))
    chunkindx = np.array_split(np.arange(ncat), nchunk)
    log.info(f'Dividing into {nchunk:,d} chunks.')

    for ichunk in range(nchunk):
        h5dir = os.path.join(outdir, ssl_version, 'input')
        if not os.path.isdir(h5dir):
            os.makedirs(h5dir, exist_ok=True)

        h5file = os.path.join(h5dir, f'ssl-parent-chunk{ichunk:03}-{ssl_version}.hdf5')
        if os.path.isfile(h5file) and not overwrite:
            log.info(f'Skipping existing HDF5 file {h5file}')
            continue

        refs = np.hstack((np.ones(nrefcat, bool), np.zeros(len(chunkindx[ichunk]), bool)))
        rows = np.hstack((refcat['ROW_PARENT'].value, cat['ROW_PARENT'][chunkindx[ichunk]].value))
        ras = np.hstack((refcat['RA'].value, cat['RA'][chunkindx[ichunk]].value))
        decs = np.hstack((refcat['DEC'].value, cat['DEC'][chunkindx[ichunk]].value))
        fitsfiles = np.hstack((refcatfiles, catfiles[chunkindx[ichunk]]))

        F = h5py.File(h5file, 'w')
        F.create_dataset('ref', data=refs)
        F.create_dataset('row', data=rows)
        F.create_dataset('ra', data=ras)
        F.create_dataset('dec', data=decs)

        images = F.create_dataset('images', (refs.size, nband, width, width))
        for iobj, fitsfile in enumerate(fitsfiles):
            raise ValueError('need to deal with missing bandpasses...and handle i-band')
            img = fitsio.read(fitsfile)
            images[iobj, :] = img

        F.close()
        log.info(f'Wrote {h5file} with {nrefcat:,d} reference objects and ' + \
                 f'{len(chunkindx[ichunk]):,d} objects to classify.')




def _write_objlist(cat, region, prefix='tmplist'):
    outfile = f'{prefix}-{region}.txt'
    out = cat['OBJNAME', ]
    out['COMMENT'] = 'drop,faint shred or compact'
    out.write(outfile, format='ascii.csv', overwrite=True)
    log.info(f'Wrote {outfile}')


def _read_test_sample1(cat, region, photo_version):
    """All objects with diameter<XX arcsec and no other source within
    XX arcsec.

    """
    from SGA.sky import find_close

    if photo_version is None:
        msg = 'photo_version is a required input for _read_sample1()'
        log.critical(msg)
        raise ValueError(msg)

    fullcat = cat.copy()

    primaries, groups = find_close(cat, cat, rad_arcsec=30., isolated=True)
    diam, _, _, _ = choose_geometry(primaries, mindiam=0.)

    # I have cutouts for everything < 20.
    #cat = primaries[diam < 20.]#[:128]

    if region == 'dr11-south':
        if photo_version == 'v1.0':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam > 0.) * (diam < 10.) # N=4,434
        elif photo_version == 'v1.1':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam >= 10.) * (diam < 12.) # N=434,092
        elif photo_version == 'v1.2':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam >= 12.) * (diam < 15.) # N=446,883
        elif photo_version == 'v1.3':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam >= 15.) * (diam < 20.) # N=542,082
    elif region == 'dr9-north':
        if photo_version == 'v1.0':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam > 0.) * (diam < 11.) # N=94,229
        elif photo_version == 'v1.1':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam >= 11.) * (diam < 15.) # N=212,676
        elif photo_version == 'v1.2':
            I = (primaries['ROW_LVD'] == -99) * (primaries['STARFDIST'] > 1.) * (diam >= 15.) * (diam < 20.) # N=154,287

    cat = primaries[I]
    #cat = cat[cat['OBJNAME'] == 'WISEA J000353.33-203717.1']

    #I = ~np.logical_or.reduce((cat['FILTERS'] == 'girz', cat['FILTERS'] == 'grz'))
    #cat = cat[I][:128]
    #cat = cat[:128]
    #_write_objlist(cat, region)

    return cat, fullcat


def _read_test_sample2(cat, region, photo_version):
    """Check the photo fitting results.

    """
    photofiles = sorted(glob(os.path.join(sga_dir(), 'parent','photo', f'parent-photo-{region}-v?.?.fits')))
    photo = []
    for photofile in photofiles:
        photo1 = Table(fitsio.read(photofile))
        print(f'Read {len(photo1):,d} objects from {photofile}')
        photo.append(photo1)
    photo = vstack(photo)

    #I = photo['NODATA']
    #I = photo['MGE_FAIL']
    #I = photo['CENTERMASKED']
    #cat = cat[np.isin(cat['OBJNAME'], photo['OBJNAME'][I])]

    #M = np.logical_or.reduce((photo['FRACMASK_INIT_G'] < 0.2, photo['FRACMASK_INIT_R'] < 0.2,
    #                          photo['FRACMASK_INIT_I'] < 0.2, photo['FRACMASK_INIT_Z'] < 0.2))
    #I = ((photo['DIAM_PHOT'] > photo['DIAM_INIT']) * (photo['DIAM_PHOT'] > 30.) * (photo['SEP'] < 5.) * M)
    I = (photo['DIAM_PHOT'] > 45.)
    photo = photo[I]
    #photo = photo[:128]
    cat = cat[np.isin(cat['OBJNAME'], photo['OBJNAME'])]
    _write_objlist(cat, region)

    return cat


def _read_test_sample3(cat, region, isolated=False):
    """All sources larger than XX arcmin with at least one other
    object within its diameter (or not, if isolated=True).

    """
    from SGA.geometry import choose_geometry
    from SGA.sky import in_ellipse_mask_sky

    fullcat = cat.copy()
    fullcat_diam, fullcat_ba, fullcat_pa, _ = choose_geometry(fullcat, mindiam=0.)

    if isolated:
        #I = (fullcat_diam <= 20.) * (fullcat['ROW_LVD'] == -99) * ~fullcat['RESOLVED']
        #I = (fullcat_diam/60. > 1.) * ~fullcat['RESOLVED']
        I = (fullcat_diam > 50.) * (fullcat_diam <= 60.) * ~fullcat['RESOLVED']
    else:
        #I = (fullcat_diam/60. > 4.) * (fullcat_diam/60. < 50.) * ~fullcat['RESOLVED']
        #I = (fullcat_diam/60. > 2.) * (fullcat_diam/60. < 4.) * ~fullcat['RESOLVED']
        #I = (fullcat_diam/60. > 1.) * (fullcat_diam/60. < 2.) * ~fullcat['RESOLVED']
        I = (fullcat_diam > 30.) * (fullcat_diam <= 60.) * ~fullcat['RESOLVED']
        #I = (fullcat_diam/60. > 1.) * ~fullcat['RESOLVED']
        #print('HACK!!')
        #I = np.isin(cat['OBJNAME'], ['NGC 5349'])#['NGC 0019'])#, 'ESO 241- G 020'])

    print(np.sum(I))
    cat = cat[I]
    diam = fullcat_diam[I]
    ba = fullcat_ba[I]
    pa = fullcat_pa[I]

    allmatches = match_radec(cat['RA'].value, cat['DEC'].value,
                             fullcat['RA'].value, fullcat['DEC'].value,
                             np.max(diam)/3600., indexlist=True,
                             notself=False, count=True)
    outcat, outfullcat = [], []

    if isolated:
        prefix = 'isolated'
    else:
        prefix = 'tmplist'

    for iobj in range(len(cat)):
        if isolated:
            # refine the search to this object's diameter
            _, m2, _ = match_radec(cat['RA'][iobj], cat['DEC'][iobj],
                                   fullcat['RA'][allmatches[iobj]],
                                   fullcat['DEC'][allmatches[iobj]],
                                   0.75*diam[iobj]/3600.)
            # isolated!
            if len(m2) == 1:
                outcat.append(cat[[iobj]])
                outfullcat.append(fullcat[allmatches[iobj]][m2])
        else:
            if len(allmatches[iobj]) == 1:
                m2 = [0]
                prefix_this = ''
                diam_this = [-99.]
            else:
                # find neighbors within this object's elliptical aperture
                ras, decs = fullcat['RA'][allmatches[iobj]], fullcat['DEC'][allmatches[iobj]]
                racen, deccen = cat['RA'][iobj], cat['DEC'][iobj]

                semia = diam[iobj] / 2. / 3600. # [degrees]
                semib = ba[iobj] * semia

                m2 = np.where(in_ellipse_mask_sky(
                    racen, deccen, semia, semib, pa[iobj], ras, decs))[0]

                # hack!
                prefix_this = np.array(list(zip(*np.char.split(fullcat['OBJNAME'][allmatches[iobj]][m2].value, ' ').tolist()))[0])
                diam_this = fullcat_diam[allmatches[iobj]][m2]
                objtypes = fullcat['OBJTYPE'][allmatches[iobj]][m2].value

            # at least one other object
            #if len(m2) > 1 and np.any(diam_this == 0.):
            if len(m2) > 1 and np.any(objtypes == 'g'):
            #if len(m2) > 1 and 'WISEA' in prefix_this and np.any(diam_this == 0.):
                outcat.append(cat[[iobj]])
                outfullcat.append(fullcat[allmatches[iobj]][m2])

    cat = vstack(outcat)
    print(len(cat))
    #allprefix = np.array(list(zip(*np.char.split(cat['OBJNAME'].value, ' ').tolist()))[0])
    #cat = cat[:100]

    _cat = vstack(outfullcat)
    _, uindx = np.unique(_cat['OBJNAME'], return_index=True)
    _cat = _cat[uindx]

    print('HACK - removing central galaxy from tmplist!')
    _cat = _cat[~np.isin(_cat['OBJNAME'], cat['OBJNAME'])]

    _cat = _cat[np.argsort(_cat['RA'])]
    _write_objlist(_cat, region, prefix=prefix)

    return cat, fullcat


def _read_zooniverse_sample(cat):

    # project0
    ## analyze the Zooniverse sample; toss out by STARFDIST?
    #diam, _, _, _ = choose_geometry(cat, mindiam=0.)
    #I = (diam > 3.*60.) * ~cat['RESOLVED']# * (cat['FILTERS'] == 'grz')
    #cat = cat[I]
    #if annotate:
    #    diam, _, _, _ = choose_geometry(fullcat, mindiam=0.)
    #    I = diam > 15.
    #    print(f'Trimmed fullcat to {np.sum(I):,d}/{len(fullcat):,d} objects with diam>15 arcsec')
    #    fullcat = fullcat[I]

    # project1


def _read_ssl_results(region, ssl_version):
    """Check Sara's the ssl results.

    """
    catdir = os.path.join(sga_dir(), 'ssl')#, ssl_version)
    cat = Table(fitsio.read(os.path.join(catdir, f'ssl-parent-cat-{ssl_version}.fits')))
    refcat = Table(fitsio.read(os.path.join(catdir, f'ssl-parent-refcat-{ssl_version}.fits')))

    cat = cat[cat['REGION'] == region]
    refcat = refcat[refcat['REGION'] == region]

    sslfiles = glob(os.path.join(cutoutdir, ssl_version, 'output', '*.txt'))
    allssl = vstack([Table.read(sslfile, format='ascii.commented_header') for sslfile in sslfiles])
    _, I = np.unique(allssl['ROW'], return_index=True)
    allssl = allssl[I]

    ssl_cat = allssl[np.isin(allssl['ROW'], cat['ROW_PARENT'])]
    ssl_refcat = allssl[np.isin(allssl['ROW'], refcat['ROW_PARENT'])]

    if False:#True:
        # first investigate refcat
        cat = refcat[np.isin(refcat['ROW_PARENT'], ssl_refcat['ROW'])]
    else:
        # investigate cat
        cat = cat[np.isin(cat['ROW_PARENT'], ssl_cat['ROW'])]
        #print(cat.pprint(max_lines=-1))
        pdb.set_trace()

    ## test code to identify objects with no other sources within 30 arcsec
    #fullcat = read_fits_catalog(catfile, columns=columns, rows=None)
    #matches = match_radec(cat['RA'].value, cat['DEC'].value, fullcat['RA'].value,
    #                      fullcat['DEC'].value, 30./3600., indexlist=True, notself=True)
    #indx_isolated = []
    #for iobj, onematch in enumerate(matches):
    #    if onematch is None:
    #        continue
    #    if len(onematch) == 1:
    #        indx_isolated.append(iobj)
    #indx_isolated = np.array(indx_isolated)
    #cat = cat[indx_isolated]

    #cat = cat[0:490] # 1000:1110]

    return cat


def read_catalog(region='dr9-north', cutoutdir='.', read_fullcat=False,
                 ssl_version=None, photo_version=None, ntest=None,
                 annotate=False, ssl=False, wisesize=False, lvd=False,
                 zooniverse=False):
    """Simple wrapper to read a specified catalog.

    """
    from SGA.io import parent_version, read_fits_catalog

    version = parent_version(archive=True)
    columns = ['OBJNAME', 'FILTERS', 'RA', 'DEC', 'OBJTYPE', 'MORPH', 'Z', 'PGC',
               'DIAM_LIT_REF', 'DIAM_LIT', 'BA_LIT', 'PA_LIT', 'DIAM_HYPERLEDA',
               'BA_HYPERLEDA', 'PA_HYPERLEDA', 'DIAM_SGA2020', 'BA_SGA2020',
               'PA_SGA2020', 'ROW_LVD', 'ROW_NEDLVS', 'ROW_PARENT',
               'STARFDIST', 'STARMAG', 'RESOLVED', 'FORCEGAIA', 'FORCEPSF']

    if 'NERSC_HOST' in os.environ:
        catdir = '/global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent'
    else:
        catdir = '/Users/ioannis/research/projects/SGA/2025/parent'

    catfile = os.path.join(catdir, f'SGA2025-parent-archive-{region}-{version}.fits')

    F = fitsio.FITS(catfile)
    N = F[1].get_nrows()

    # read a test sample
    if ntest is not None:
        rng = np.random.default_rng(seed=1)
        rows = rng.choice(N, size=ntest, replace=False)
        rows = rows[np.argsort(rows)]
    else:
        rows = np.arange(N)

    cat = read_fits_catalog(catfile, columns=columns, rows=rows)

    if ssl and ssl_version is None:
        log.info('ssl_version must be specified')
        return

    # when annotating, must make a copy *before* any cuts!
    if read_fullcat or annotate or ssl or lvd:
        if ntest is not None:
            fullcat = read_fits_catalog(catfile, columns=columns, rows=None)
        else:
            fullcat = cat.copy()
    else:
        fullcat = None

    # read various samples / projects
    #cat, fullcat = _read_test_sample1(cat, region, photo_version)
    #cat = _read_test_sample2(cat, region, photo_version)
    cat = _read_test_sample3(cat, region, isolated=False)


    pdb.set_trace()


    if False:#True:
        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J023340.70+345454.6'])]
        cat = cat[np.isin(cat['OBJNAME'], ['Pictor I', 'Phoenix'])]
        fullcat = cat.copy()
        fullcat_diam, fullcat_ba, fullcat_pa, _ = choose_geometry(fullcat, mindiam=0.)
        fullcat = fullcat[fullcat_diam > 30.]

        # good tests for do_photo()
        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J110416.71-003141.3', '6dF J1125579-114702', 'SDSS J125753.66+100506.8'])]

    # Explore a given photo sample
    if False:#True:
        photfile = os.path.join(sga_dir(), 'parent', 'photo', f'parent-photo-{region}-{photo_version}.fits')
        phot = Table(fitsio.read(photfile))
        log.info(f'Read {len(phot):,d} objects from {photfile}')

        #I = phot['MGE_FAIL']
        I = (phot['DIAM_PHOT'] > 30.) * (phot['SEP'] < 5.)
        #pdb.set_trace()

        # this works well!
        #I = np.logical_or.reduce((phot['NODATA'], phot['CENTERMASKED'], phot['MGE_FAIL']))

        # test
        #I = phot['SEP'] > 20.

        print(np.sum(I))
        phot = phot[I]
        cat = cat[np.isin(cat['OBJNAME'], phot['OBJNAME'])]


    if False:#True:
        ##########################
        ## All objects with at least one other sources within XX arcsec.
        #from SGA.util import resolve_close
        #
        #fullcat = cat.copy()
        #rad_arcsec = 5.#10.#1.5
        #
        #cat = find_close(cat, fullcat, rad_arcsec=rad_arcsec)
        #pdb.set_trace()
        #fullcat = resolve_close(cat, fullcat, maxsep=rad_arcsec, allow_vetos=False, trim=True, verbose=False)#True)
        #
        #cat = find_close(cat, fullcat, rad_arcsec=rad_arcsec)

        ##########################
        ## All objects with diameter==0 and no other source within
        ## 30 arcsec.
        #from SGA.util import find_close
        #fullcat = cat.copy()
        #
        #primaries, groups = find_close(cat, cat, rad_arcsec=30., isolated=True)
        #diam, _, _, _ = choose_geometry(primaries, mindiam=0.)
        #cat = primaries[diam == 0.]#[:128]
        #write_junk(cat, region)

        #########################
        ## All objects larger than XX arcmin that have an SDSS source near them.
        #fullcat = cat.copy()
        #I = (diam > 5.*60.)
        #cat = cat[I]
        #
        #allmatches = match_radec(cat['RA'].value, cat['DEC'].value,
        #                         fullcat['RA'].value, fullcat['DEC'].value,
        #                         1./60., indexlist=True, notself=False)
        #refindx = []
        #for ii, mm in enumerate(allmatches):
        #    if len(mm) > 1:
        #        if np.any('SDSS' in ' '.join(fullcat['OBJNAME'][mm].value)):
        #            refindx.append(ii)
        #refindx = np.array(refindx)
        #cat = fullcat[I][refindx]


    if False:#True:
        I = (cat['DIAM_LIT'] < 0.) * (np.char.find(cat['OBJNAME'].value, 'LSBG') != -1)
        cat = cat[I]

    if False:#True:
        # one-by-one checks

        cat = cat[np.isin(cat['OBJNAME'], ['WISEA J000146.05+101419.7', 'WISEA J000214.39-252944.6'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J110416.71-003141.3'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['MCG +00-11-011'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J023242.56+005813.7'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['UGCA 020'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['CGMW 5-02508'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['CGMW 5-00897'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J101736.54-075650.7'])]

        #print('SUPER HACK!')
        #cat = cat[np.isin(cat['OBJNAME'], ['ESO 569- G 005'])]
        #cat['RA'] += 5./3600.
        #cat['DEC'] -= 3./3600.

        #cat = cat[np.isin(cat['OBJNAME'], ['WISEA J110416.71-003141.3'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['KUG 1045+278'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['ESO 409- G 008'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['ESO 054- G 004'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['ESO 002- G 013', 'WISEA J110416.71-003141.3'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['UGC 00579', 'IC 1860'])]
        #cat = cat[cat['OBJNAME'] == 'UGC 03214']
        #m1, m2, _ = match_radec(cat['RA'], cat['DEC'], 27.2007, 10.5151, 120./3600.)
        #cat = cat[m1]
        #print(cat['OBJNAME', 'ROW_PARENT'])
        #pdb.set_trace()
        #diam, ba, pa, ref = choose_geometry(cat)
        #parse_geometry(cat, 'SMUDGes')

        #from SGA.groups import build_group_catalog
        #diam, _, _, _ = choose_geometry(cat, mindiam=10.)
        #cat['DIAM'] = diam
        #cat = cat[diam < 15.]
        #cat['SGANAME'] = radec_to_name(cat['RA'], cat['DEC'], unixsafe=False)
        #cat = build_group_catalog(cat)

    if False:
        # SMUDGes
        prefix = np.array(list(zip(*np.char.split(cat['OBJNAME'].value, ' ').tolist()))[0])
        cat = cat[(prefix == 'SMDG') * (cat['DIAM_LIT'] > 0.)]#[:8]
        diam, ba, pa, ref = choose_geometry(cat)
        #pdb.set_trace()

    if lvd:
        # analyze the LVD sample
        #diam, _, _, _ = choose_geometry(cat, mindiam=0.)
        #cat = cat[(cat['ROW_LVD'] != -99) * (diam == 0.)] # (diam > 20.*60.)]
        cat = cat[cat['ROW_LVD'] != -99]

        if photo_version is not None:
            # six galaxies with diam>40 arcmin in dr11-south (invvar cutouts not possible!)
            # ---------------------
            # OBJNAME      DIAM_LIT
            #          LMC   645.65
            #  Sagittarius   446.68
            #          SMC   380.19
            #    Antlia II    151.2
            #    Crater II     62.4
            #   Bootes III     56.0
            cat = cat[~np.isin(cat['OBJNAME'], ['LMC', 'Sagittarius', 'SMC', 'Antlia II', 'Crater II', 'Bootes III'])]
        else:
            cat = cat[~np.isin(cat['OBJNAME'], ['LMC', 'Sagittarius', 'SMC'])]
        #cat = cat[np.isin(cat['OBJNAME'], ['KK 221'])]
        #cat = cat[cat['RESOLVED']]
        diam, _, _, _ = choose_geometry(cat, mindiam=0.)
        #cat = cat[diam < 60.]
        cat = cat[cat['FORCEPSF']]
        #cat = cat[~np.logical_or.reduce((cat['RESOLVED'], cat['FORCEPSF'], cat['FORCEGAIA']))]
        #pdb.set_trace()

        fulldiam, _, _, _ = choose_geometry(fullcat, mindiam=0.)
        fullcat = fullcat[fulldiam > 30./60.]


    if wisesize:
        from SGA.external import read_wisesize_sample
        cat, fullcat = read_wisesize_sample(cat, fullcat=fullcat, catfile=catfile,
                                            region=region, cutoutdir=cutoutdir)


    if zooniverse:
        from SGA.external import read_zooniverse_sample
        cat, fullcat = read_zooniverse_sample(cat, fullcat=fullcat, catfile=catfile,
                                              region=region, cutoutdir=cutoutdir,
                                              project='project1')

    if ssl:
        _read_ssl_results(region, ssl_version)

    # more testing below here
    if False:
        ## SGA-2020 missing objects
        #miss = Table(fitsio.read(os.path.join(sga_dir(), 'sandbox', 'sga2020-missing.fits')))
        #m1, m2, _ = match_radec(cat['RA'], cat['DEC'], miss['RA'], miss['DEC'], 5./3600., nearest=True)
        ##m1, m2, _ = match_radec(cat['RA'], cat['DEC'], miss['RA'], miss['DEC'], 60./3600.)
        ##m1 = np.unique(m1)
        #cat = cat[m1]
        #cat = cat[np.argsort(cat['RA'])]
        ##cat = cat[cat['OBJNAME'] == 'WISEA J163631.04+461928.3']
        ##diam, ba, pa, ref = choose_geometry(cat)


    log.info(f'Trimmed to {len(cat):,d} objects.')


    sort_by_ra = False
    sort_by_diameter = True
    #if lvd and photo_version is not None:
    #    pdb.set_trace()
    if sort_by_ra:
        log.info('Sorting by RA')
        cat = cat[np.argsort(cat['RA'])]
    elif sort_by_diameter:
        log.info('Sorting by diameter')
        diam, _, _, ref = choose_geometry(cat, mindiam=0.)
        cat = cat[np.argsort(diam)[::-1]]
    else:
        log.info('Sorting by OBJNAME')
        cat = cat[np.argsort(cat['OBJNAME'])]

    if len(cat) == 0:
        raise ValueError('No objects in catalog!')

    return cat, fullcat


def main():
    """Main wrapper.

    """
    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--region', default='dr9-north', choices=['dr9-north', 'dr9-south', 'dr10-south', 'dr11-south'],
                        type=str, help='Region to analyze (only for --catalog="sga2025-parent").')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--ntest', type=int, default=None, help='Number of test objects to read.')
    parser.add_argument('--width', type=int, default=152, help='Default cutout width [pixels].')
    parser.add_argument('--pixscale', type=float, default=0.262, help='Default pixel scale [arcsec/pixel].')
    parser.add_argument('--cutoutdir', default='./', type=str, help='Base output data directory.')
    parser.add_argument('--httpdir', default=None, type=str, help='Base https output data directory.')

    parser.add_argument('--ssl', action='store_true', help='Analyze the ssl-legacysurvey samples.')
    parser.add_argument('--build-ssl', action='store_true', help='Build the hdf5 files needed by ssl-legacysurvey.')
    parser.add_argument('--ssl-version', default=None, type=str, help='Version number.')

    parser.add_argument('--lvd', action='store_true', help='Analyze the LVD sample.')
    parser.add_argument('--zooniverse', action='store_true', help='Analyze the zooniverse sample.')
    parser.add_argument('--wisesize', action='store_true', help='Analyze the wisesize sample.')

    parser.add_argument('--plan', action='store_true', help='Plan how many nodes to use and how to distribute the targets.')

    parser.add_argument('--photo', action='store_true', help='Perform photometry.')
    parser.add_argument('--photo-version', default=None, type=str, help='Version number.')
    parser.add_argument('--gather-photo', action='store_true', help='Gather photometric .')

    parser.add_argument('--annotate', action='store_true', help='Annotate the native-resolution cutouts.')
    parser.add_argument('--annotate-central-only', action='store_true', help='Only annotate the central galaxy.')
    parser.add_argument('--annotated-montage', action='store_true', help='Generate multipage montages of annotated images.')

    parser.add_argument('--no-fits-cutouts', action='store_false', dest='fits_cutouts', help='Do not generate FITS cutouts.')
    parser.add_argument('--ivar-cutouts', action='store_true', help='Generate ivar cutouts.')
    parser.add_argument('--invvar', dest='ivar_cutouts', action='store_true', help='Generate ivar cutouts.')
    parser.add_argument('--dry-run', action='store_true', help='Generate but do not run commands.')
    parser.add_argument('--rescale', action='store_true', help='Scale the pixel size.')
    parser.add_argument('--debug', action='store_true', help='Print out a variety of debugging messages.')
    parser.add_argument('--verbose', action='store_true', help='Be verbose.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite any existing output files.')

    args = parser.parse_args()

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
    except ImportError:
        comm = None

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    # define paths depending on the input keywords
    if args.build_ssl:
        pass
    else:
        layer = None
        cutoutdir = None
        annotatedir = None
        photodir = None

        if args.photo or args.gather_photo:
            # photometry
            if args.photo_version is None:
                msg = f'photo_version is a required input'
                log.critical(msg)
                raise ValueError(msg)
            cutoutdir = os.path.join(args.cutoutdir, args.region, 'native')
            photodir = os.path.join(args.cutoutdir, args.region, 'native')
        elif args.annotate:
            # annotated cutouts
            cutoutdir = os.path.join(args.cutoutdir, args.region, 'native')
            annotatedir = os.path.join(args.cutoutdir, args.region, 'annotate')
        else:
            # native or rescaled cutouts
            layer = f'ls-{args.region}'
            if args.region == 'dr11-south':
                log.warning(f"WARNING: Overriding layer={layer}-->ls-dr11-early-v2")
                layer = 'ls-dr11-early-v2'
            if args.rescale:
                cutoutdir = os.path.join(args.cutoutdir, args.region, 'rescale')
            else:
                cutoutdir = os.path.join(args.cutoutdir, args.region, 'native')
            annotatedir = os.path.join(args.cutoutdir, args.region, 'annotate')


    cat, fullcat = None, None
    if rank == 0:
        if args.build_ssl:
            if args.ssl_version is None:
                raise ValueError('ssl_version must be specified')
            if args.ssl_version == 'v1' or args.ssl_version == 'v2':
                cat_north, fullcat_north = read_catalog(read_fullcat=True, region='dr9-north')
                cat_south, fullcat_south = read_catalog(read_fullcat=True, region='dr9-south')
                cat_north['REGION'] = 'dr9-north'
                cat_south['REGION'] = 'dr9-south'
                fullcat_north['REGION'] = 'dr9-north'
                fullcat_south['REGION'] = 'dr9-south'
            elif args.ssl_version == 'v3' or args.ssl_version == 'v4':
                cat_north, fullcat_north = read_catalog(read_fullcat=True, region='dr9-north')
                cat_south, fullcat_south = read_catalog(read_fullcat=True, region='dr11-south')
                cat_north['REGION'] = 'dr9-north'
                cat_south['REGION'] = 'dr11-south'
                fullcat_north['REGION'] = 'dr9-north'
                fullcat_south['REGION'] = 'dr11-south'
            else:
                raise ValueError(f'Unsupported ssl_version {args.ssl_version}')
            cat = vstack((cat_north, cat_south))
            fullcat = vstack((fullcat_north, fullcat_south))
            del cat_north, cat_south, fullcat_north, fullcat_south
        else:
            cat, fullcat = read_catalog(region=args.region, annotate=args.annotate,
                                        cutoutdir=args.cutoutdir, ntest=args.ntest,
                                        wisesize=args.wisesize, lvd=args.lvd,
                                        zooniverse=args.zooniverse, ssl=args.ssl,
                                        ssl_version=args.ssl_version,
                                        photo_version=args.photo_version)

    if comm is not None:
        cat = comm.bcast(cat, root=0)
        fullcat = comm.bcast(fullcat, root=0)

    if args.annotated_montage and rank == 0:
        annotated_montage(cat, region=args.region, cutoutdir=args.cutoutdir, annotatedir=annotatedir,
                          photodir=photodir, ssl=args.ssl, ssl_version=args.ssl_version,
                          rescale=args.rescale, photo=args.photo, photo_version=args.photo_version,
                          wisesize=args.wisesize, lvd=args.lvd, zooniverse=args.zooniverse,
                          overwrite=args.overwrite)
        return

    if args.build_ssl and rank == 0:
        build_ssl_legacysurvey(cat, fullcat, width=args.width, ssl_version=args.ssl_version,
                               cutoutdir=args.cutoutdir, overwrite=args.overwrite,
                               verbose=args.verbose)
        return

    # no FITS cutouts needed for the Zooniverse project
    fits_cutouts = args.fits_cutouts
    ivar_cutouts = args.ivar_cutouts
    unwise_cutouts = False
    galex_cutouts = False
    draw_largest_ellipse = False

    if args.zooniverse:
        fits_cutouts = False
        draw_largest_ellipse = True
    elif args.wisesize:
        ivar_cutouts = True
        unwise_cutouts = True
        galex_cutouts = False # True
    else:
        pass

    if args.plan and rank == 0:
        if args.photo or args.gather_photo:
            width = None
        elif args.annotate:
            width = None
        else:
            mindiam = args.width * args.pixscale # [arcsec]
            diam, ba, pa, ref = choose_geometry(cat, mindiam=mindiam)

            pixscale, width = get_pixscale_and_width(
                diam, mindiam, rescale=args.rescale,
                default_width=args.width,
                default_pixscale=args.pixscale)

        plan(cat, width=width, layer=layer, size=size, cutoutdir=cutoutdir,
             annotatedir=annotatedir, photodir=photodir, mp=args.mp,
             annotate=args.annotate, photo=args.photo, fits_cutouts=fits_cutouts,
             unwise_cutouts=unwise_cutouts, galex_cutouts=galex_cutouts,
             overwrite=args.overwrite, verbose=args.verbose)
        return

    if args.gather_photo and rank == 0:
        gather_photo(cat, mp=args.mp, region=args.region, cutoutdir=cutoutdir,
                     photodir=photodir, photo_version=args.photo_version)
        return

    if args.photo:
        do_photo(cat, comm=comm, mp=args.mp, region=args.region,
                 cutoutdir=cutoutdir, photodir=photodir,
                 photo_version=args.photo_version,
                 overwrite=args.overwrite, verbose=args.verbose)
    elif args.annotate:
        do_annotate(cat, fullcat, default_pixscale=args.pixscale,
                    default_width=args.width, mp=args.mp,
                    comm=comm, base_cutoutdir=args.cutoutdir, cutoutdir=cutoutdir,
                    annotatedir=annotatedir, region=args.region, httpdir=args.httpdir,
                    overwrite=args.overwrite, fits_cutouts=fits_cutouts,
                    draw_largest_ellipse=draw_largest_ellipse,
                    annotate_central_only=args.annotate_central_only,
                    debug=args.debug, dry_run=args.dry_run, verbose=args.verbose)
    else:
        do_cutouts(cat, layer=layer, mp=args.mp, comm=comm, cutoutdir=cutoutdir,
                   base_cutoutdir=args.cutoutdir, default_pixscale=args.pixscale,
                   default_width=args.width, rescale=args.rescale,
                   overwrite=args.overwrite, dry_run=args.dry_run,
                   fits_cutouts=fits_cutouts, ivar_cutouts=ivar_cutouts,
                   unwise_cutouts=unwise_cutouts, galex_cutouts=galex_cutouts,
                   verbose=args.verbose)

if __name__ == '__main__':
    main()
