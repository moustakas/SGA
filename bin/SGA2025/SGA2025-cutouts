#!/usr/bin/env python

"""MPI wrapper to get a large number of image cutouts.

Working interactively in a login node, one would do something like:

  shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh --image dstndstn/cutouts:dvsro bash
  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1
  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1 --annotate

Alternatively, in production, one would do:

  salloc -N 1 -C cpu -A desi -t 04:00:00 --qos interactive --image=docker:dstndstn/cutouts:dvsro
  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=4 > \
    /pscratch/sd/i/ioannis/SGA2025/cutouts/SGA2025-cutouts-parent-north-native-JOBID.log 2>&1 &

  time srun --ntasks=32 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-shifter-env.sh \
    SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=4 --rescale > \
    /pscratch/sd/i/ioannis/SGA2025/cutouts/SGA2025-cutouts-parent-north-rescale-JOBID.log 2>&1 &

To build the ssl-legacysurvey catalog:
  SGA2025-shifter

  SGA2025-cutouts --outdir=/pscratch/sd/i/ioannis/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --ssl-legacysurvey


"""
import pdb # for debugging

import os, re, sys, time
import numpy as np
import fitsio
from astropy.table import Table
import multiprocessing

from astrometry.libkd.spherematch import match_radec

from SGA.io import custom_brickname, get_raslice
from SGA.util import radec_to_name, choose_geometry, parse_geometry


def _get_annotate_one(args):
    return get_annotate_one(*args)


def get_annotate_one(obj, objname, indir, outdir, overwrite=False, verbose=False):
    raslice = get_raslice(obj['RA'])

    if objname is None:
        brick = custom_brickname(obj['RA'], obj['DEC'])
        jpgfile = os.path.join(indir, raslice, brick[:6], f'{brick}.jpeg')
        pngfile = os.path.join(outdir, raslice, brick[:6], f'{brick}.png')
    else:
        jpgfile = os.path.join(indir, raslice, f'{objname}.jpeg')
        pngfile = os.path.join(outdir, raslice, f'{objname}.png')
    nobj = 1

    if overwrite is False:
        if os.path.isfile(pngfile):
            nobj = 0
            if verbose:
                print(f'Skipping existing annotated cutout {pngfile}')
    else:
        if not os.path.isfile(jpgfile):
            nobj = 0
            print(f'Missing input cutout {jpgfile}')

    return jpgfile, pngfile, nobj


def _annotate_one(args):
    return annotate_one(*args)


def annotate_one(jpgfile, pngfile, objname, commonname, pixscale,
                 mosaic_diam, primary, group, dry_run, rank, iobj):
    """Annotate one image.

    """
    import matplotlib.pyplot as plt
    import matplotlib.image as mpimg
    from astropy.wcs import WCS
    from astropy.io import fits

    def get_wcs(racenter, deccenter, width):
        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = racenter
        hdr['CRVAL2'] = deccenter
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600.
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600.
        return WCS(hdr)


    def draw_ellipse(diam, ba, pa, pixscale, xpix, ypix, color, linestyle, majorminor=True):
        from matplotlib.patches import Ellipse

        semimajor = diam / pixscale # [pixels]
        semiminor = ba * semimajor  # [pixels]
        theta = np.radians(90.-pa)
        x0 = xpix
        y0 = width - ypix

        ax.add_artist(Ellipse((x0, y0), semimajor, semiminor, angle=90.-pa,
                              facecolor='none', edgecolor=color, lw=1.5, ls=linestyle,
                              alpha=0.9, clip_on=True))

        if majorminor:
            # Draw the major and minor axes
            x1, y1 = x0 + semimajor/2. * np.cos(theta), y0 + semimajor/2. * np.sin(theta)
            x2, y2 = x0 - semimajor/2. * np.cos(theta), y0 - semimajor/2. * np.sin(theta)
            x3, y3 = x0 + semiminor/2. * np.sin(theta), y0 - semiminor/2. * np.cos(theta)
            x4, y4 = x0 - semiminor/2. * np.sin(theta), y0 + semiminor/2. * np.cos(theta)

            ax.plot([x1, x2], [y1, y2], lw=0.5, color=color, ls='-', clip_on=True)
            ax.plot([x3, x4], [y3, y4], lw=0.5, color=color, ls='-', clip_on=True)


    if not os.path.isfile(jpgfile):
        return

    bbox = dict(boxstyle='round', facecolor='k', alpha=0.5)
    ref_pixscale = 0.262
    barlen = 15 / pixscale # [pixels]
    barlabel = '15 arcsec'

    N = len(group)
    primary_ra, primary_dec = primary['RA'], primary['DEC']

    img = mpimg.imread(jpgfile)
    width = img.shape[0]
    wcs = get_wcs(primary_ra, primary_dec, width)

    ellipse_colors = {'RC3': 'yellow', 'SGA2020': 'dodgerblue', 'HYPERLEDA': 'red', 'LIT': 'green'}
    ellipse_linestyles = {'RC3': 'solid', 'SGA2020': 'dashed', 'HYPERLEDA': 'dashdot', 'LIT': 'dotted'}

    outdir = os.path.dirname(pngfile)
    if not os.path.isdir(outdir):
        os.makedirs(outdir)

    fig, ax = plt.subplots(figsize=(8, 8))
    im = ax.imshow(img, origin='lower')
    ax.set_xlim(0, width)
    ax.set_ylim(0, width)
    for imem, onegal in enumerate(group):
        ra = onegal['RA']
        dec = onegal['DEC']
        xpix, ypix = wcs.wcs_world2pix(ra, dec, 1)
        if xpix < 0 or ypix < 0 or xpix > width or ypix > width:
            continue

        for ref in ['RC3', 'SGA2020', 'HYPERLEDA', 'LIT']:
            diam, ba, pa = parse_geometry(Table(onegal), ref)
            if diam > 0.:
                #print(onegal['OBJNAME'], ref, xpix, ypix, diam[0], ba[0], pa[0])
                if onegal['OBJNAME'] == primary['OBJNAME']:
                    majorminor = True
                else:
                    majorminor = False

                draw_ellipse(diam[0], ba[0], pa[0], pixscale, xpix, ypix, color=ellipse_colors[ref],
                             linestyle=ellipse_linestyles[ref], majorminor=majorminor)
                if onegal['OBJNAME'] != primary['OBJNAME']:
                    if imem % 2 == 0:
                        xoffset = 0.2 * width
                    else:
                        xoffset = width - 0.2 * width

                    yoffset = (imem + 0.5) * width / N
                    if width-yoffset > width / 2:
                        va = 'top'
                    else:
                        va = 'bottom'

                    if np.abs(ypix-yoffset) < int(0.03*width):
                        yoffset += int(0.03*width)
                    ax.annotate('', xy=(xpix, width-ypix), xytext=(xoffset, width-yoffset),
                                annotation_clip=True, arrowprops={'arrowstyle': '-', 'color': 'white'})
                                #dict(facecolor='white', edgecolor='white', width=0.5,
                                #     headwidth=2, shrink=0.005, alpha=0.75))
                    ax.annotate(onegal['OBJNAME'], xy=(xoffset, width-yoffset), xytext=(xoffset, width-yoffset),
                                va=va, ha='center', color='white', bbox=bbox, fontsize=9,
                                annotation_clip=True)


    ax.invert_yaxis() # JPEG is flipped relative to my FITS WCS
    ax.axis('off')
    if primary['MORPH'].strip() == '':
        morph = primary["OBJTYPE"].strip()
    else:
        morph = primary["OBJTYPE"].strip() +'; '+re.sub(r'\s+', ' ', primary["MORPH"])

    txt = '\n'.join([commonname, #objname.replace('_', ' '),
                     morph, f'{primary_ra:.7f}, {primary_dec:.6f}'])
                     #r'$(\alpha,\delta)$='+f'({primary_ra:.7f}, {primary_dec:.6f})'])
    #txt = '\n'.join([commonname+f' {morph}', objname.replace('_', ' '),
    #                 r'$(\alpha,\delta)$='+f'({primary_ra:.7f}, {primary_dec:.6f})'])
    ax.text(0.03, 0.93, txt, transform=ax.transAxes, ha='left', va='center',
            color='white', bbox=bbox, linespacing=1.5, fontsize=10)

    # add the scale bar
    xpos, ypos = 0.07, 0.07
    dx = barlen / img.shape[0]
    ax.plot([xpos, xpos+dx], [ypos, ypos], transform=ax.transAxes,
            color='white', lw=2)
    ax.text(xpos + dx/2., ypos+0.02, barlabel, transform=ax.transAxes,
            ha='center', va='center', color='white')
    ax.text(1-xpos, ypos, str(iobj+1), transform=ax.transAxes,
            ha='right', va='center', color='white')

    fig.tight_layout()
    fig.savefig(pngfile, bbox_inches=0)#, dpi=200)
    plt.close()
    print(f'Wrote {pngfile}')
    #pdb.set_trace()


def do_annotate(allcat, cat, objname, commonname, diam, pixscale=0.262,
                comm=None, mp=1, indir='.', outdir='.', overwrite=False, 
                dry_run=False, verbose=False):
    """Wrapper to set up the full set of annotations.

    """
    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    t0 = time.time()
    if rank == 0:
        jpgfiles, pngfiles, groups = plan(
            cat, objname, comm=comm, outdir=outdir, 
            indir=indir, overwrite=overwrite, mp=mp, 
            verbose=verbose, annotate=True)
        print(f'Planning took {time.time() - t0:.2f} sec')
    else:
        jpgfiles, pngfiles, groups = [], [], []

    if comm:
        jpgfiles = comm.bcast(jpgfiles, root=0)
        pngfiles = comm.bcast(pngfiles, root=0)
        groups = comm.bcast(groups, root=0)
    sys.stdout.flush()

    # all done
    if len(jpgfiles) == 0 or len(np.hstack(jpgfiles)) == 0:
        return
        
    assert(len(groups) == size)

    print(f'Rank {rank} started at {time.asctime()}')
    sys.stdout.flush()

    indx = groups[rank]

    if np.isscalar(pixscale):
        in_pixscale = [pixscale] * len(indx)
    else:
        in_pixscale = pixscale

    # initial match
    allmatches = match_radec(cat[indx]['RA'].value, cat[indx]['DEC'].value,
                             allcat['RA'].value, allcat['DEC'].value,
                             2.*np.max(diam)/3600., indexlist=True, notself=False)

    mpargs = []
    for iobj in indx:
        primary = cat[iobj]
        # refine the search to this object's diameter
        m1, m2, _ = match_radec(primary['RA'], primary['DEC'], allcat[allmatches[iobj]]['RA'],
                                allcat[allmatches[iobj]]['DEC'], 2.*diam[iobj]/3600.)
        group = allcat[allmatches[iobj]][m2]
        #if primary['OBJNAME'] == 'IC 1259 NED01':
        #    pdb.set_trace()
        mpargs.append((jpgfiles[iobj], pngfiles[iobj], objname[iobj], commonname[iobj],
                       in_pixscale[iobj], diam[iobj], primary, group, dry_run, rank, iobj))
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            P.map(_annotate_one, mpargs)
    else:
        [annotate_one(*mparg) for mparg in mpargs]

    #print(f'  rank {rank} is done')
    sys.stdout.flush()

    if comm is not None:
        comm.barrier()

    if rank == 0 and not dry_run:
        print(f'All done at {time.asctime()}')
    

def _cutout_one(args):
    return cutout_one(*args)


def cutout_one(basefile, ra, dec, width, pixscale, layer, dry_run, rank, iobj):
    """
    pixscale = 0.262
    width = int(30 / pixscale)   # =114
    height = int(width / 1.3) # =87 [3:2 aspect ratio]

    shifterimg pull dstndstn/viewer-cutouts:latest
    shifter --image dstndstn/viewer-cutouts cutout --output cutout.jpg --ra 234.2915 --dec 16.7684 --size 256 --layer ls-dr9 --pixscale 0.262 --force

    """
    from cutout import cutout

    for suffix in ['.jpeg', '.fits']:
        outfile = basefile+suffix
        #outfile = f'"{basefile}{suffix}"'
        cmdargs = f'--output={outfile} --ra={ra} --dec={dec} --size={width} ' + \
            f'--layer={layer} --pixscale={pixscale} --force'
        if dry_run:
            if suffix == '.jpeg':
                print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')            
        else:
            if suffix == '.jpeg':
                outdir = os.path.dirname(basefile)
                if not os.path.isdir(outdir):
                    os.makedirs(outdir, exist_ok=True)
            try:
                cutout(ra, dec, outfile, size=width, layer=layer, pixscale=pixscale, force=True)
                if suffix == '.jpeg':
                    print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')
            except:
                if suffix == '.jpeg':
                    print(f'WARNING: Rank {rank}, object {iobj} off the footprint: cutout {cmdargs}')                


def _get_basefiles_one(args):
    return get_basefiles_one(*args)


def get_basefiles_one(obj, objname, outdir, overwrite=False, verbose=False):
    raslice = get_raslice(obj['RA'])

    if objname is None:
        brick = custom_brickname(obj['RA'], obj['DEC'])
        basefile = os.path.join(outdir, raslice, brick[:6], brick)
    else:
        basefile = os.path.join(outdir, raslice, objname)
    nobj = 1

    if overwrite is False:
        if os.path.isfile(basefile+'.fits') and os.path.isfile(basefile+'.jpeg'):
            nobj = 0
            if verbose:
                print(f'Skipping existing cutout {basefile}.')

    return basefile, obj['RA'], obj['DEC'], nobj


def plan(cat, objname, layer='ls-dr9', comm=None, indir='.', outdir='.', 
         mp=1, annotate=False, overwrite=False, verbose=False):
    """Build a plan!

    """
    t0 = time.time()
    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    if annotate:
        mpargs = [(obj, objname1, indir, outdir, overwrite, verbose) 
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_annotate_one, mpargs)
        else:
            out = [get_annotate_one(*mparg) for mparg in mpargs]
        out = list(zip(*out))
    
        jpgfiles = np.array(out[0], dtype=object)
        pngfiles = np.array(out[1], dtype=object)
        nobj = np.array(out[2], dtype=object)
    else:
        mpargs = [(obj, objname1, outdir, overwrite, verbose) 
                  for obj, objname1 in zip(cat, objname)]
        if mp > 1:
            with multiprocessing.Pool(mp) as P:
                out = P.map(_get_basefiles_one, mpargs)
        else:
            out = [get_basefiles_one(*mparg) for mparg in mpargs]
        out = list(zip(*out))
    
        basefiles = np.array(out[0], dtype=object)
        allra = np.array(out[1], dtype=object)
        alldec = np.array(out[2], dtype=object)
        nobj = np.array(out[3], dtype=object)

    iempty = np.where(nobj == 0)[0]
    if len(iempty) > 0:
        print(f'Skipping {len(iempty):,d} objects with existing cutouts.')

    itodo = np.where(nobj > 0)[0]
    if len(itodo) > 0:
        nobj = nobj[itodo]
        if annotate:
            print(f'Annotating {np.sum(nobj):,d} images.')
            jpgfiles = jpgfiles[itodo]
            pngfiles = pngfiles[itodo]
        else:
            print(f'Generating cutouts for {np.sum(nobj):,d} objects.')
            basefiles = basefiles[itodo]
            allra = allra[itodo]
            alldec = alldec[itodo]

        indices = np.arange(len(nobj))
        groups = np.array_split(indices, size) # unweighted distribution
    else:
        groups = [np.array([])]

    if annotate:
        return jpgfiles, pngfiles, groups
    else:
        return basefiles, allra, alldec, groups


def do_cutouts(cat, objname, layer='ls-dr9', width=152, pixscale=0.262, 
               comm=None, mp=1, outdir='.', overwrite=False, dry_run=False,
               verbose=False):

    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    t0 = time.time()
    if rank == 0:
        basefiles, allra, alldec, groups = plan(cat, objname, layer=layer, comm=comm, 
                                                outdir=outdir, overwrite=overwrite, mp=mp,
                                                verbose=verbose)
        print(f'Planning took {time.time() - t0:.2f} sec')
    else:
        basefiles, allra, alldec, groups = [], [], [], []

    if comm:
        basefiles = comm.bcast(basefiles, root=0)
        allra = comm.bcast(allra, root=0)
        alldec = comm.bcast(alldec, root=0)
        groups = comm.bcast(groups, root=0)
    sys.stdout.flush()
    
    # all done
    if len(basefiles) == 0 or len(np.hstack(basefiles)) == 0:
        return
        
    assert(len(groups) == size)

    print(f'Rank {rank} started at {time.asctime()}')
    sys.stdout.flush()

    indx = groups[rank]

    if np.isscalar(pixscale):
        in_pixscale = [pixscale] * len(indx)
    else:
        in_pixscale = pixscale

    if np.isscalar(width):
        in_width = [width] * len(indx)
    else:
        in_width = width

    mpargs = [(basefiles[iobj], allra[iobj], alldec[iobj], in_width[iobj], 
               in_pixscale[iobj], layer, dry_run, rank, iobj) for iobj in indx]
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            P.map(_cutout_one, mpargs)
    else:
        [cutout_one(*mparg) for mparg in mpargs]

    #print(f'  rank {rank} is done')
    sys.stdout.flush()

    if comm is not None:
        comm.barrier()

    if rank == 0 and not dry_run:
        print(f'All done at {time.asctime()}')


def read_catalog(catfile, ext=1, columns=None, rows=None):
    """Simple wrapper to read an input catalog.

    """
    if not os.path.isfile(catfile):
        print(f'Catalog {catfile} not found')
        return

    try:
        cat = Table(fitsio.read(catfile, ext=ext, rows=rows, columns=columns))
        print(f'Read {len(cat):,d} galaxies from {catfile}')
        return cat
    except:
        msg = f'Problem reading {args.catalog}'
        raise IOError(msg)


def get_pixscale_and_width(diam, mindiam, rescale=False, maxdiam_arcmin=5.,
                           default_width=152, default_pixscale=0.262):
    """Simple function to compute the pixel scale of the desired
    output images.

    """
    nobj = len(diam)

    if rescale:
        # scale the pixel scale so that larger objects "fit" in DEFAULT_WIDTH
        pixscale = default_pixscale * 2. * diam / mindiam   # [arcsec/pixel]
        width = np.zeros(nobj, int) + default_width # [pixels]
    else:
        # full-mosaic, native resolution width, except for objects
        # larger than XX arcmin
        pixscale = np.zeros(nobj) + default_pixscale # [arcsec/pixel]
        width = 2. * diam / pixscale # [pixels]
    
        maxdiam = maxdiam_arcmin * 60 # [arcsec]
        I = diam > maxdiam
        if np.any(I):
            pixscale[I] = default_pixscale * diam[I] / maxdiam
            width[I] = 2. * diam[I] / pixscale[I]
    
    width = width.astype(int)

    return pixscale, width


def build_ssl_legacysurvey(refcat, cat, region='north', width=152, bands=['g', 'r', 'z'],
                           cutoutdir='.', outdir='.', overwrite=False, verbose=False):
    """Build the hdf5 file needed by ssl-legacysurvey.

    nband = 3 (grz)

    """
    import h5py


    def get_fitsfiles(cat):
        I = []
        fitsfiles = []
        for ii, one in enumerate(cat):
            objname = radec_to_name(one['RA'], one['DEC'])[0].replace(' ', '_')
            fitsfile = os.path.join(cutoutdir, get_raslice(one['RA']), f'{objname}.fits')
            if os.path.isfile(fitsfile):
                I.append(ii)
                fitsfiles.append(fitsfile)
            else:
                print(f'Missing {fitsfile}')

        return np.array(fitsfiles), np.array(I)


    nrefcat = len(refcat)
    ncat = len(cat)
    nband = len(bands)

    h5file = os.path.join(outdir, f'ssl-{region}.hdf5')
    if os.path.isfile(h5file) and not overwrite:
        print(f'Skipping existing HDF5 file {h5file}')
        return

    refcatfiles, refcatindx = get_fitsfiles(refcat)
    catfiles, catindx = get_fitsfiles(cat)

    rows = np.hstack((refcat[refcatindx]['PARENT_ROW'].value, cat[catindx]['PARENT_ROW'].value))
    ras = np.hstack((refcat[refcatindx]['RA'].value, cat[catindx]['RA'].value))
    decs = np.hstack((refcat[refcatindx]['DEC'].value, cat[catindx]['DEC'].value))
    fitsfiles = np.hstack((refcatfiles, catfiles))

    F = h5py.File(h5file, 'w')
    F.create_dataset('row', data=rows)
    F.create_dataset('ra', data=ras)
    F.create_dataset('dec', data=decs)

    images = F.create_dataset('images', (nrefcat + ncat, nband, width, width))
    for iobj, fitsfile in enumerate(fitsfiles):
        # need to deal with missing bandpasses...
        img = fitsio.read(fitsfile)
        images[iobj, :] = img

    F.close()
    print(f'Wrote {h5file} with {nrefcat:,d} reference objects and {ncat:,d} objects to classify.')


def main():
    """Main wrapper.

    """
    import argparse    
    
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--catalog', type=str, default='sga2025-parent', choices=['sga2025-parent', 'sga2020'], help='Catalog to read.')
    parser.add_argument('--region', default='north', choices=['north', 'south'], type=str, help='Region to analyze (only for --catalog="sga2025-parent").')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--width', type=int, default=152, help='Default cutout width [pixels].')
    parser.add_argument('--pixscale', type=float, default=0.262, help='Default pixel scale [arcsec/pixel].')
    parser.add_argument('--version', default='v1.0', type=str, help='Version of the parent catalog to read (only for --catalog="sga2025-parent").')
    parser.add_argument('--outdir', default='./', type=str, help='Base output data directory.')

    parser.add_argument('--plan', action='store_true', help='Plan how many nodes to use and how to distribute the targets.')
    parser.add_argument('--annotate', action='store_true', help='Annotate the native-resolution cutouts.')
    parser.add_argument('--annotate-montage', action='store_true', help='Generate multipage montages of annotated images.')
    parser.add_argument('--dry-run', action='store_true', help='Generate but do not run commands.')
    parser.add_argument('--rescale', action='store_true', help='Scale the pixel size.')
    parser.add_argument('--ssl-legacysurvey', action='store_true', help='Build the hdf5 file needed by ssl-legacysurvey.')
    parser.add_argument('--verbose', action='store_true', help='Be verbose.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite any existing output files.')
    
    args = parser.parse_args()

    #print('Hack!')
    #sys.path.append('/global/homes/i/ioannis/code/git/SGA/py')

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
    except ImportError:
        comm = None

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    if comm is None:
        rank = 0
    else:
        rank = comm.rank

    (cat, allcat, objname, commonname, layer, indir, outdir,
     cutoutdir, pixscale, width, diam) = [[]] * 11
    if rank == 0:
        if args.annotate_montage:
            from glob import glob
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_pdf import PdfPages
            from matplotlib.image import imread

            pdffile = os.path.join(args.outdir, 'annotate-montage.pdf')
            if os.path.isfile(pdffile) and not args.overwrite:
                print(f'Output file {pdffile} exists.')
                return

            pngfiles = np.array(glob(os.path.join(args.outdir, args.region, 'annotate', '???', '*.png')))
            pngfiles = pngfiles[np.argsort(pngfiles)]
            #pngfiles = pngfiles[:16]
            allindx = np.arange(len(pngfiles))

            ncol = 4
            nrow = 4

            nperpage = ncol * nrow
            npage = int(np.ceil(len(pngfiles) / nperpage))
            print(f'Distributing {len(pngfiles):,d} annotated images to {npage:,d} pages.')

            pdf = PdfPages(pdffile)
            for ipage in range(npage):
                print(f'Building page {ipage+1:,d}/{npage:,d}')
                indx = allindx[ipage*nperpage:(ipage+1)*nperpage]
                fig, ax = plt.subplots(nrow, ncol, figsize=(2*ncol, 2*nrow))
                for iax, xx in enumerate(np.atleast_1d(ax).flat):
                    if iax < len(indx):
                        xx.imshow(imread(pngfiles[indx[iax]]), interpolation='None')
                    xx.axis('off')
                fig.subplots_adjust(wspace=0., hspace=0., bottom=0.05, top=0.95, left=0.05, right=0.95)
                pdf.savefig(fig, dpi=150)
                plt.close()
            pdf.close()
            print(f'Wrote {pdffile}')

            return


        if args.catalog == 'sga2025-parent':

            if 'NERSC' in os.environ:
                catfile = '/global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/' + \
                    f'SGA2025-parent-{args.region}-{args.version}.fits'
            else:
                catfile = '/Users/ioannis/research/projects/SGA/2025/parent/' + \
                    f'SGA2025-parent-{args.region}-{args.version}.fits'
            columns = ['OBJNAME', 'FILTERS', 'RA', 'DEC', 'OBJTYPE', 'MORPH', 'DIAM_LIT_REF',
                       'DIAM_LIT', 'BA_LIT', 'PA_LIT', 'DIAM_HYPERLEDA', 'BA_HYPERLEDA', 'PA_HYPERLEDA',
                       'DIAM_SGA2020', 'BA_SGA2020', 'PA_SGA2020', 'PARENT_ROW']

            F = fitsio.FITS(catfile)
            N = F[1].get_nrows()
            if False:
                S = 1000
                rng = np.random.default_rng(seed=1)
                rows = rng.choice(N, size=S, replace=False)
                rows = rows[np.argsort(rows)]
            else:
                rows = np.arange(N)

            cat = read_catalog(catfile, columns=columns, rows=rows)

            # when annotating, must make a copy *before* any cuts!
            if args.annotate:
                allcat = cat.copy()

            #cat = cat[np.isin(cat['OBJNAME'], ['NGC 2796', 'NGC 3104', 'Bootes IV Dwarf', 'Leo III', 'MESSIER 110'])]
            #cat = cat[cat['DIAM'] == 60.]

            #if False:
            #    refcat = cat[(cat['DIAM_HYPERLEDA'] > 5.) * (cat['FILTERS'] == 'grz')]
            #    m1, m2, _ = match_radec(refcat['RA'], refcat['DEC'], cat['RA'], cat['DEC'], 5./60)
            #    cat = cat[m2]

            #refcat = cat[(cat['DIAM_LIT'] < 5.) * (cat['DIAM_LIT_REF'] == 'RC3') * (cat['FILTERS'] == 'grz')]
            #m1, m2, _ = match_radec(cat['RA'], cat['DEC'], refcat['RA'], refcat['DEC'], 120/3600.)
            #cat = cat[m1]
            #cat = cat[np.argsort(cat['DIAM_LIT'])[::-1]]

            #cat = cat[(cat['OBJTYPE'] != 'GPair') * (cat['OBJTYPE'] != 'GTrpl') * cat['DIAM_LIT_REF'] == 'RC3') * (cat['FILTERS'] == 'grz')]
            #cat = cat[np.isin(cat['OBJNAME'], ['NGC 7318A', 'NGC 7318B'])]
            #cat = cat[:8]
            #print(f'Trimming to {len(cat):,d} objects')

            commonname = cat['OBJNAME']
            objname = np.char.replace(radec_to_name(cat['RA'], cat['DEC']), ' ', '_')
            #objname = np.char.replace(cat['OBJNAME'].value, ' ', '_')

            if True:
                print('HACK!')
                from glob import glob
                ff = glob(os.path.join(args.outdir, args.region, 'native', '???', '*.jpeg'))
                ff = np.char.replace(ff, '.jpeg', '')
                I = np.isin(objname, np.vectorize(os.path.basename)(ff))
                objname = objname[I]
                commonname = commonname[I]
                cat = cat[I]
            else:
                I = np.isin(cat['OBJNAME'], ['UGC 05806'])
                #I = np.isin(cat['OBJNAME'], ['IC 1259 NED01', 'IC 1259 NED02'])
                objname = objname[I]
                commonname = commonname[I]
                cat = cat[I]
                #cat = cat[np.isin(cat['OBJNAME'], ['NGC 7318A', 'NGC 7318B'])]


            if args.ssl_legacysurvey:
                # need to define a reference sample
                sslcols = ['OBJNAME', 'RA', 'DEC', 'PARENT_ROW']
                refcat = cat[:20][sslcols]
                cat = cat[20:][sslcols]
                cutoutdir = os.path.join(args.outdir, args.region, 'rescale')
            else:
                mindiam = args.width * args.pixscale # [arcsec]
                diam, ba, pa, ref = choose_geometry(cat, mindiam=mindiam)
    
                pixscale, width = get_pixscale_and_width(
                    diam, mindiam, rescale=args.rescale, 
                    default_width=args.width,
                    default_pixscale=args.pixscale)
    
                if args.annotate:
                    indir = os.path.join(args.outdir, args.region, 'native')
                    outdir = os.path.join(args.outdir, args.region, 'annotate')
                else:
                    layer = f'ls-dr9-{args.region}'
                    if args.region == 'south':
                        # FIXME - need DR10 CCDs file
                        #layer = f'ls-dr10-{args.region}'
                        pass
        
                    if args.rescale:
                        outdir = os.path.join(args.outdir, args.region, 'rescale')
                    else:
                        outdir = os.path.join(args.outdir, args.region, 'native')

        elif args.catalog == 'sga2020':
            catfile = '/global/cfs/cdirs/cosmo/data/sga/2020/SGA-2020.fits'
            columns = ['SGA_ID', 'GALAXY', 'RA', 'DEC']
            cat = read_catalog(catfile, ext='ELLIPSE', columns=columns)#, rows=np.arange(10))
            objname = [f'SGA2020-{sgaid:06d}' for sgaid in cat['SGA_ID']]

            layer = 'ls-dr9'

            #d26_pixels = cat['D26'] * 60 / args.pixscale # [pixels]
            #d26cut_arcmin = args.width * 1.5 * args.pixscale / 60
            #I = np.where(d26_pixels < (args.width * 1.5))[0] # no more than 50% larger than the default cutout width
            #I = rand.choice(I, 4096, replace=False)
            #print(f'Selecting {len(I):,d}/{len(cat):,d} SGA galaxies with cutout width < 1.5*{args.width} pixels (<{d26cut_arcmin:.2f} arcmin).')
            #out = cat[I]

    if args.annotate_montage:
        return

        
    if comm is not None:
        cat = comm.bcast(cat, root=0)
        allcat = comm.bcast(allcat, root=0)
        objname = comm.bcast(objname, root=0)
        commonname = comm.bcast(commonname, root=0)
        layer = comm.bcast(layer, root=0)
        outdir = comm.bcast(outdir, root=0)
        indir = comm.bcast(indir, root=0)
        cutoutdir = comm.bcast(cutoutdir, root=0)
        pixscale = comm.bcast(pixscale, root=0)
        width = comm.bcast(width, root=0)
        diam = comm.bcast(diam, root=0)

    if args.plan:
        if rank == 0:
            plan(cat, objname, layer=layer, comm=comm, indir=indir, outdir=outdir, 
                 mp=args.mp, annotate=args.annotate, overwrite=args.overwrite, 
                 verbose=args.verbose)
    elif args.ssl_legacysurvey:
        if rank == 0:
            build_ssl_legacysurvey(refcat, cat, region=args.region, width=args.width,
                                   cutoutdir=cutoutdir, outdir=args.outdir,
                                   overwrite=args.overwrite, verbose=args.verbose)
    else:
        if args.annotate:
            do_annotate(allcat, cat, objname, commonname, diam, pixscale=pixscale,
                        mp=args.mp, comm=comm, indir=indir, outdir=outdir, 
                        overwrite=args.overwrite, dry_run=args.dry_run, verbose=args.verbose)
        else:
            do_cutouts(cat, objname, layer=layer, width=width, pixscale=pixscale, 
                       mp=args.mp, comm=comm, outdir=outdir, overwrite=args.overwrite,
                       dry_run=args.dry_run, verbose=args.verbose)

if __name__ == '__main__':
    main()
