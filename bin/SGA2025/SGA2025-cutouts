#!/usr/bin/env python

"""MPI wrapper to get a large number of image cutouts.

This code only depends on Dustin's cutout container, not on any other software
(including the SGA product), i.e., it is self-contained.

shifter --image dstndstn/cutouts:dvsro bash
/global/homes/i/ioannis/code/git/SGA/bin/SGA2025/SGA2025-cutouts --outdir=$PSCRATCH/SGA2025-data/SGA2020-cutouts --mp=1 --catalog=sga2025-parent --region=north --dry-run

or 

salloc -N 1 -C cpu -A desi -t 04:00:00 --qos interactive --image=docker:dstndstn/cutouts:dvsro

srun --ntasks=1 shifter /usr/bin/python /global/homes/i/ioannis/code/git/SGA/bin/SGA2025/SGA2025-cutouts \
  --outdir=$PSCRATCH/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1 

srun --ntasks=1 shifter /usr/bin/python /global/homes/i/ioannis/code/git/SGA/bin/SGA2025/SGA2025-cutouts \
  --outdir=$PSCRATCH/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --rescale --mp=1 

time srun --ntasks=32 shifter /usr/bin/python /global/homes/i/ioannis/code/git/SGA/bin/SGA2025/SGA2025-cutouts \
  --outdir=$PSCRATCH/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=4 \
  > SGA2025-cutouts-parent-north-native-34740851.log 2>&1 &



srun --ntasks=1 shifter --env-file=$CFS/desicollab/users/ioannis/SGA/2025/scripts/SGA2025-cutouts-env.sh \
  /usr/bin/python /global/homes/i/ioannis/code/git/SGA/bin/SGA2025/SGA2025-cutouts \
  --outdir=$PSCRATCH/SGA2025/cutouts/parent --catalog=sga2025-parent --region=north --mp=1 

"""
import pdb # for debugging

import os, sys, time
import numpy as np
import fitsio
from astropy.table import Table
import multiprocessing
from glob import glob


def radec_to_name(target_ra, target_dec, prefix='SGA2025'):
    """Convert the right ascension and declination of an object into a
    disk-friendly "name", for reference in publications.  Length of
    `target_ra` and `target_dec` must be the same if providing an
    array or list.

    Parameters
    ----------
    target_ra: array of :class:`~numpy.float64`
        Right ascension in degrees of target object(s). Can be float, double,
        or array/list of floats or doubles.
    target_dec: array of :class:`~numpy.float64`
        Declination in degrees of target object(s). Can be float, double,
        or array/list of floats or doubles.

    Returns
    -------
    array of :class:`str`
        Names referring to the input target RA and DEC's. Array is the
        same length as the input arrays.

    Raises
    ------
    ValueError
        If any input values are out of bounds.

    Notes
    -----
    Written by A. Kremin (LBNL) for DESI. Taken entirely from
    desiutil.names.radec_to_desiname.

    """
    # Convert to numpy array in case inputs are scalars or lists
    target_ra, target_dec = np.atleast_1d(target_ra), np.atleast_1d(target_dec)

    base_tests = [('NaN values', np.isnan),
                  ('Infinite values', np.isinf),]
    inputs = {'target_ra': {'data': target_ra,
                            'tests': base_tests + [('RA not in range [0, 360)', lambda x: (x < 0) | (x >= 360))]},
              'target_dec': {'data': target_dec,
                             'tests': base_tests + [('Dec not in range [-90, 90]', lambda x: (x < -90) | (x > 90))]}}
    for coord in inputs:
        for message, check in inputs[coord]['tests']:
            if check(inputs[coord]['data']).any():
                raise ValueError(f"{message} detected in {coord}!")

    # Number of decimal places in final naming convention
    precision = 4

    # Truncate decimals to the given precision
    ratrunc = np.trunc((10.**precision) * target_ra).astype(int).astype(str)
    dectrunc = np.trunc((10.**precision) * target_dec).astype(int).astype(str)

    # Loop over input values and create the name as DESINAME as: DESI JXXX.XXXX+/-YY.YYYY
    # Here J refers to J2000, which isn't strictly correct but is the closest
    #   IAU compliant term
    names = []
    for ra, dec in zip(ratrunc, dectrunc):
        zra = ra.zfill(7)
        name = f'{prefix} J' + zra[:-precision] + '.' + zra[-precision:]
        # Positive numbers need an explicit "+" while negative numbers
        #   already have a "-".
        # zfill works properly with '-' but counts it in number of characters
        #   so need one more
        if dec.startswith('-'):
            zdec = dec.zfill(7)
            name += zdec[:-precision] + '.' + zdec[-precision:]
        else:
            zdec = dec.zfill(6)
            name += '+' + zdec[:-precision] + '.' + zdec[-precision:]
        names.append(name)

    return np.array(names)


def custom_brickname(ra, dec):
    brickname = '{:08d}{}{:07d}'.format(
        int(100000*ra), 'm' if dec < 0 else 'p',
        int(100000*np.abs(dec)))
    #brickname = '{:06d}{}{:05d}'.format(
    #    int(1000*ra), 'm' if dec < 0 else 'p',
    #    int(1000*np.abs(dec)))
    return brickname


def get_raslice(ra):
    return f'{int(ra):03d}'


def _cutout_one(args):
    return cutout_one(*args)


def cutout_one(basefile, ra, dec, width, pixscale, layer, dry_run, rank, iobj):
    """
    pixscale = 0.262
    width = int(30 / pixscale)   # =114
    height = int(width / 1.3) # =87 [3:2 aspect ratio]

    shifterimg pull dstndstn/viewer-cutouts:latest
    shifter --image dstndstn/viewer-cutouts cutout --output cutout.jpg --ra 234.2915 --dec 16.7684 --size 256 --layer ls-dr9 --pixscale 0.262 --force

    """
    from cutout import cutout

    for suffix in ['.jpeg', '.fits']:
        outfile = basefile+suffix
        #outfile = f'"{basefile}{suffix}"'
        cmdargs = f'--output={outfile} --ra={ra} --dec={dec} --size={width} ' + \
            f'--layer={layer} --pixscale={pixscale} --force'
        if dry_run:
            if suffix == '.jpeg':
                print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')            
        else:
            if suffix == '.jpeg':
                outdir = os.path.dirname(basefile)
                if not os.path.isdir(outdir):
                    os.makedirs(outdir, exist_ok=True)
            try:
                cutout(ra, dec, outfile, size=width, layer=layer, pixscale=pixscale, force=True)
                if suffix == '.jpeg':
                    print(f'Rank {rank}, object {iobj}: cutout {cmdargs}')
            except:
                print(f'WARNING: Rank {rank}, object {iobj} off the footprint: cutout {cmdargs}')                


def _get_basefiles_one(args):
    return get_basefiles_one(*args)


def get_basefiles_one(obj, objname, outdir, overwrite=False, verbose=False):
    raslice = get_raslice(obj['RA'])

    if objname is None:
        brick = custom_brickname(obj['RA'], obj['DEC'])
        basefile = os.path.join(outdir, raslice, brick[:6], brick)
    else:
        basefile = os.path.join(outdir, raslice, objname)
    nobj = 1

    if overwrite is False:
        if os.path.isfile(basefile+'.fits') and os.path.isfile(basefile+'.jpeg'):
            nobj = 0
            if verbose:
                print(f'Skipping existing object {basefile}.')

    return basefile, obj['RA'], obj['DEC'], nobj


def plan(cat, objname=None, layer='ls-dr9', comm=None, outdir='.', mp=1, 
         overwrite=False):

    from astropy.table import Table
                                
    t0 = time.time()
    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    if objname is None:
        objname = [None] * len(cat)

    verbose = True
    mpargs = [(obj, objname1, outdir, overwrite, verbose) for obj, objname1 in zip(cat, objname)]
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            out = P.map(_get_basefiles_one, mpargs)
    else:
        out = [get_basefiles_one(*mparg) for mparg in mpargs]
    out = list(zip(*out))

    basefiles = np.array(out[0], dtype=object)
    allra = np.array(out[1], dtype=object)
    alldec = np.array(out[2], dtype=object)
    nobj = np.array(out[3], dtype=object)

    iempty = np.where(nobj == 0)[0]
    if len(iempty) > 0:
        print(f'Skipping {len(iempty):,d} objects with existing cutouts.')

    itodo = np.where(nobj > 0)[0]
    if len(itodo) > 0:
        basefiles = basefiles[itodo]
        allra = allra[itodo]
        alldec = alldec[itodo]
        nobj = nobj[itodo]

        print(f'Generating cutouts for {np.sum(nobj):,d} objects.')
        indices = np.arange(len(basefiles))
        groups = np.array_split(indices, size) # unweighted distribution
    else:
        groups = [np.array([])]

    return basefiles, allra, alldec, groups


def do_cutouts(cat, objname=None, layer='ls-dr9', width=152, pixscale=0.262, 
               comm=None, mp=1, outdir='.', overwrite=False, dry_run=False):

    if comm is None:
        rank, size = 0, 1
    else:
        rank, size = comm.rank, comm.size

    t0 = time.time()
    if rank == 0:
        basefiles, allra, alldec, groups = plan(cat, objname, layer=layer, comm=comm, 
                                                outdir=outdir, overwrite=overwrite, mp=mp)
        print(f'Planning took {time.time() - t0:.2f} sec')
    else:
        basefiles, allra, alldec, groups = [], [], [], []

    if comm:
        basefiles = comm.bcast(basefiles, root=0)
        allra = comm.bcast(allra, root=0)
        alldec = comm.bcast(alldec, root=0)
        groups = comm.bcast(groups, root=0)
    sys.stdout.flush()
    
    # all done
    if len(basefiles) == 0 or len(np.hstack(basefiles)) == 0:
        return
        
    assert(len(groups) == size)

    print(f'Rank {rank} started at {time.asctime()}')
    sys.stdout.flush()

    indx = groups[rank]

    if np.isscalar(pixscale):
        in_pixscale = [pixscale] * len(indx)
    else:
        in_pixscale = pixscale

    if np.isscalar(width):
        in_width = [width] * len(indx)
    else:
        in_width = width

    mpargs = [(basefiles[iobj], allra[iobj], alldec[iobj], in_width[iobj], 
               in_pixscale[iobj], layer, dry_run, rank, iobj) for iobj in indx]
    if mp > 1:
        with multiprocessing.Pool(mp) as P:
            P.map(_cutout_one, mpargs)
    else:
        [cutout_one(*mparg) for mparg in mpargs]

    #print(f'  rank {rank} is done')
    sys.stdout.flush()

    if comm is not None:
        comm.barrier()

    if rank == 0 and not dry_run:
        print(f'All done at {time.asctime()}')


def read_catalog(catfile, ext=1, columns=None, rows=None):
    """Simple wrapper to read an input catalog.

    """
    if not os.path.isfile(catfile):
        print(f'Catalog {catfile} not found')
        return

    try:
        cat = Table(fitsio.read(catfile, ext=ext, rows=rows, columns=columns))
        print(f'Read {len(cat):,d} galaxies from {catfile}')
        return cat
    except:
        msg = f'Problem reading {args.catalog}'
        raise IOError(msg)


def choose_diameter(cat, mindiam=152*0.262):
    """Choose between DIAM and DIAM_LEDA.

    mindiam is ~40 arcsec

    """
    diam = np.zeros(len(cat)) + mindiam # [arcsec]

    I = np.logical_and(cat['DIAM'] < 0., cat['DIAM_LEDA'] > 0.)
    if np.any(I):
        diam[I] = cat[I]['DIAM_LEDA'] * 60. # [arcsec]

    I = np.logical_and(cat['DIAM'] > 0., cat['DIAM_LEDA'] < 0.)
    if np.any(I):
        diam[I] = cat[I]['DIAM'] * 60. # [arcsec]

    I = np.logical_and(cat['DIAM'] > 0., cat['DIAM_LEDA'] > 0.)
    if np.any(I):
        # ???
        diam[I] = cat[I]['DIAM_LEDA'] * 60. # [arcsec]

    # set a minimum floor
    I = diam < mindiam
    if np.any(I):
        diam[I] = mindiam

    # special-cases - north
    S = [
        'WISEA J151427.24+604725.4', # not in HyperLeda; basic-data diameter is 12.11 arcmin!
        ]
    I = np.isin(cat['OBJNAME'], S)
    if np.any(I):
        diam[I] = mindiam

    return diam

        
def main():
    """Main wrapper.

    """
    import argparse    
    
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')
    parser.add_argument('--width', type=int, default=152, help='Default cutout width [pixels].')
    parser.add_argument('--pixscale', type=float, default=0.262, help='Default pixel scale [arcsec/pixel].')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite any existing output files.')
    parser.add_argument('--plan', action='store_true', help='Plan how many nodes to use and how to distribute the targets.')
    parser.add_argument('--dry-run', action='store_true', help='Generate but do not run commands.')

    parser.add_argument('--rescale', action='store_true', help='Scale the pixel size.')

    parser.add_argument('--catalog', type=str, default='sga2025-parent', choices=['sga2025-parent', 'sga2020'], help='Catalog to read.')
    parser.add_argument('--version', default='v1.0', type=str, help='Version of the parent catalog to read (only for --catalog="sga2025-parent").')
    parser.add_argument('--region', default='north', choices=['north', 'south'], type=str, help='Region to analyze (only for --catalog="sga2025-parent").')

    parser.add_argument('--outdir', default='./', type=str, help='Base output data directory.')
    
    args = parser.parse_args()

    #print('Hack!')
    #sys.path.append('/global/homes/i/ioannis/code/git/SGA/py')

    try:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
    except ImportError:
        comm = None

    # https://docs.nersc.gov/development/languages/python/parallel-python/#use-the-spawn-start-method
    if args.mp > 1 and 'NERSC_HOST' in os.environ:
        import multiprocessing
        multiprocessing.set_start_method('spawn')

    if comm is None:
        rank = 0
    else:
        rank = comm.rank

    if rank == 0:
        if args.catalog == 'sga2025-parent':
            #from SGA.util import radec_to_name

            catfile = '/global/cfs/cdirs/desicollab/users/ioannis/SGA/2025/parent/' + \
                f'SGA2025-parent-{args.region}-{args.version}.fits'
            columns = ['OBJNAME', 'RA', 'DEC', 'DIAM', 'DIAM_LEDA']

            F = fitsio.FITS(catfile)
            N = F[1].get_nrows()
            if False:
                S = 1000
                rng = np.random.default_rng(seed=1)
                rows = rng.choice(N, size=S, replace=False)
                rows = rows[np.argsort(rows)]
            else:
                rows = np.arange(N)

            cat = read_catalog(catfile, columns=columns, rows=rows)

            #cat = cat[np.isin(cat['OBJNAME'], ['NGC 2796', 'NGC 3104', 'Bootes IV Dwarf', 'Leo III', 'MESSIER 110'])]
            #cat = cat[cat['DIAM'] == 60.]
            #cat = cat[cat['DIAM_LEDA'] > 5.]
            print(f'Trimming to {len(cat):,d} objects')

            objname = np.char.replace(radec_to_name(cat['RA'], cat['DEC']), ' ', '_')
            #objname = np.char.replace(cat['OBJNAME'].value, ' ', '_')

            layer = f'ls-dr9-{args.region}'
            if args.region == 'south':
                #layer = f'ls-dr10-{args.region}'
                pass

            mindiam = args.width * args.pixscale         # [arcsec]
            diam = choose_diameter(cat, mindiam=mindiam) # [arcsec]

            if args.rescale:
                # scale the pixel scale so larger objects "fit" in the input WIDTH
                outdir = os.path.join(args.outdir, args.region, 'rescale')

                pixscale = args.pixscale * diam / mindiam
                width = np.zeros(len(cat), int) + args.width
            else:
                # full-mosaic, native resolution, except for objects
                # larger than 5 arcmin
                outdir = os.path.join(args.outdir, args.region, 'native')

                pixscale = np.zeros(len(cat)) + args.pixscale
                width = diam / pixscale

                maxdiam = 5. * 60 # [arcsec]
                I = diam > maxdiam
                if np.any(I):
                    pixscale[I] = args.pixscale * diam[I] / maxdiam
                    width[I] = diam[I] / pixscale[I]

            width = width.astype(int)

        elif args.catalog == 'sga2020':
            catfile = '/global/cfs/cdirs/cosmo/data/sga/2020/SGA-2020.fits'
            columns = ['SGA_ID', 'GALAXY', 'RA', 'DEC']
            cat = read_catalog(catfile, ext='ELLIPSE', columns=columns)#, rows=np.arange(10))
            objname = [f'SGA2020-{sgaid:06d}' for sgaid in cat['SGA_ID']]

            layer = 'ls-dr9'

            #d26_pixels = cat['D26'] * 60 / args.pixscale # [pixels]
            #d26cut_arcmin = args.width * 1.5 * args.pixscale / 60
            #I = np.where(d26_pixels < (args.width * 1.5))[0] # no more than 50% larger than the default cutout width
            #I = rand.choice(I, 4096, replace=False)
            #print(f'Selecting {len(I):,d}/{len(cat):,d} SGA galaxies with cutout width < 1.5*{args.width} pixels (<{d26cut_arcmin:.2f} arcmin).')
            #out = cat[I]
    else:
        cat, objname, layer, outdir, pixscale, width = None, None, None, None, None, None
        
    if comm is not None:
        cat = comm.bcast(cat, root=0)
        objname = comm.bcast(objname, root=0)
        layer = comm.bcast(layer, root=0)
        outdir = comm.bcast(outdir, root=0)
        pixscale = comm.bcast(pixscale, root=0)
        width = comm.bcast(width, root=0)

    if args.plan:
        if rank == 0:
            plan(cat, objname, layer=layer, comm=comm, outdir=outdir, 
                 mp=args.mp, overwrite=args.overwrite)
    else:
        do_cutouts(cat, objname=objname, layer=layer, width=width, pixscale=pixscale, 
                   mp=args.mp, comm=comm, outdir=outdir, overwrite=args.overwrite,
                   dry_run=args.dry_run)

if __name__ == '__main__':
    main()
