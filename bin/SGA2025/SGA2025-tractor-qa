#!/usr/bin/env python
"""
SGA2025 Tractor QA â€” Refactored

Generates PDF QA documents organized by:
  - Track: lvd, not-lvd, skiptractor
  - Tier: pipeline failures, large shifts, clean
  - Group multiplicity: GM=1, GM=2, GM=3, GM>3

Usage:
  SGA2025-tractor-qa --region=dr11-south --version=v0.70 --final-sample \\
      --mindiam=0.5 --maxdiam=5.0 --track=all --mp=32

"""

import os
import math
from glob import glob
from dataclasses import dataclass
from typing import Optional, List, Tuple, Dict

import numpy as np
from astropy.table import Table, Column
import fitsio

import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.image import imread

from PIL import Image
Image.MAX_IMAGE_PIXELS = None

from SGA.SGA import (sga_dir, sga_data_dir, get_galaxy_galaxydir,
                     read_sample, DIAMCOLUMN, REFIDCOLUMN, SAMPLE,
                     REFCAT, SGA_version)
from SGA.ellipse import ELLIPSEBIT, ELLIPSEMODE
from SGA.io import get_raslice
from SGA.geometry import get_tractor_ellipse
from SGA.qa import overplot_ellipse
from SGA.logger import log


# ============================================================================
# Constants and Bitmasks
# ============================================================================

MAXDIAM_CUTOUT = 3.0  # arcmin - max diameter for cutout generation

# Convenience masks
PIPELINE_FAIL_BITS = ELLIPSEBIT['FAILGEO'] | ELLIPSEBIT['NOTRACTOR'] | ELLIPSEBIT['TRACTORPSF']
LARGE_SHIFT_BITS = ELLIPSEBIT['LARGESHIFT'] | ELLIPSEBIT['LARGESHIFT_TRACTOR']
NEAR_STAR_BITS = SAMPLE['NEARSTAR'] | SAMPLE['INSTAR']

# Annotation bits (shown in legend, not used for tier classification)
STRUCTURAL_BITS = {
    'BLENDED': ELLIPSEBIT['BLENDED'],
    'OVERLAP': ELLIPSEBIT['OVERLAP'],
    'SATELLITE': ELLIPSEBIT['SATELLITE'],
}

MODE_BITS = {
    'FIXGEO': ELLIPSEBIT['FIXGEO'],
    'MOMENTPOS': ELLIPSEBIT['MOMENTPOS'],
    'TRACTORGEO': ELLIPSEBIT['TRACTORGEO'],
    'NORADWEIGHT': ELLIPSEBIT['NORADWEIGHT'],
    'LESSMASKING': ELLIPSEBIT['LESSMASKING'],
    'MOREMASKING': ELLIPSEBIT['MOREMASKING'],
}

SAMPLE_ANNOTATION_BITS = {
    'NEARSTAR': SAMPLE['NEARSTAR'],
    'INSTAR': SAMPLE['INSTAR'],
    'GCLPNE': SAMPLE['GCLPNE'],
    'MCLOUDS': SAMPLE['MCLOUDS'],
}


# ============================================================================
# Classification Logic
# ============================================================================

@dataclass
class SampleClassification:
    """Classification result for a single object."""
    track: str        # 'lvd', 'not-lvd', 'skiptractor'
    tier: int         # 1=pipeline fail, 2=large shift, 3=clean
    gm_bin: str       # 'gm1', 'gm2', 'gm3', 'gm4plus'
    annotations: List[str]  # bits to show in legend
    tier_bits: List[str]    # bits that triggered tier 1 or 2


def classify_object(row, has_ellipsebit: bool) -> SampleClassification:
    """
    Classify a single catalog row into track/tier/gm_bin.

    Parameters
    ----------
    row : astropy Row
        Single row from catalog
    has_ellipsebit : bool
        True for ellipse catalog (v0.70), False for parent catalog (v0.80)

    Returns
    -------
    SampleClassification

    """
    sample_bits = row['SAMPLE']
    ellipse_bits = row['ELLIPSEBIT'] if has_ellipsebit else 0
    group_mult = row['GROUP_MULT']

    # Determine track
    is_lvd = (sample_bits & SAMPLE['LVD']) != 0
    is_skiptractor = has_ellipsebit and ((ellipse_bits & ELLIPSEBIT['SKIPTRACTOR']) != 0)

    if is_lvd:
        track = 'lvd'
    elif is_skiptractor:
        track = 'skiptractor'
    else:
        track = 'not-lvd'

    # Determine tier (only meaningful if has_ellipsebit)
    tier_bits = []
    if has_ellipsebit:
        near_star = (sample_bits & NEAR_STAR_BITS) != 0

        # Check pipeline failure bits (only if not near star)
        pipeline_fail = False
        if not near_star:
            if ellipse_bits & ELLIPSEBIT['FAILGEO']:
                tier_bits.append('FAILGEO')
                pipeline_fail = True
            if ellipse_bits & ELLIPSEBIT['NOTRACTOR']:
                tier_bits.append('NOTRACTOR')
                pipeline_fail = True
            if ellipse_bits & ELLIPSEBIT['TRACTORPSF']:
                tier_bits.append('TRACTORPSF')
                pipeline_fail = True

        # Check large shift bits
        # Note: LARGESHIFT_TRACTOR is expected/incidental if MOMENTPOS is set,
        # so it doesn't trigger tier 2 in that case (but still gets annotated)
        large_shift = False
        has_momentpos = (ellipse_bits & ELLIPSEBIT['MOMENTPOS']) != 0

        if ellipse_bits & ELLIPSEBIT['LARGESHIFT']:
            tier_bits.append('LARGESHIFT')
            large_shift = True
        if ellipse_bits & ELLIPSEBIT['LARGESHIFT_TRACTOR']:
            tier_bits.append('LARGESHIFT_TRACTOR')
            # Only triggers tier 2 if MOMENTPOS is NOT set
            if not has_momentpos:
                large_shift = True

        if pipeline_fail:
            tier = 1
        elif large_shift:
            tier = 2
        else:
            tier = 3
    else:
        # Parent catalog: no tier classification, everything is "clean"
        tier = 3

    # Group multiplicity bin
    if group_mult == 1:
        gm_bin = 'gm1'
    elif group_mult == 2:
        gm_bin = 'gm2'
    elif group_mult == 3:
        gm_bin = 'gm3'
    else:
        gm_bin = 'gm4plus'

    # Collect annotations
    annotations = []
    if has_ellipsebit:
        for name, bit in STRUCTURAL_BITS.items():
            if ellipse_bits & bit:
                annotations.append(name)
        for name, bit in MODE_BITS.items():
            if ellipse_bits & bit:
                annotations.append(name)
    for name, bit in SAMPLE_ANNOTATION_BITS.items():
        if sample_bits & bit:
            annotations.append(name)

    return SampleClassification(track, tier, gm_bin, annotations, tier_bits)


def classify_catalog(cat, has_ellipsebit: bool) -> Table:
    """
    Add classification columns to catalog.

    Adds columns: QA_TRACK, QA_TIER, QA_GM_BIN, QA_ANNOTATIONS, QA_TIER_BITS

    """
    n = len(cat)

    tracks = []
    tiers = []
    gm_bins = []
    annotations_list = []
    tier_bits_list = []

    for row in cat:
        cls = classify_object(row, has_ellipsebit)
        tracks.append(cls.track)
        tiers.append(cls.tier)
        gm_bins.append(cls.gm_bin)
        annotations_list.append(','.join(cls.annotations) if cls.annotations else '')
        tier_bits_list.append(','.join(cls.tier_bits) if cls.tier_bits else '')

    cat['QA_TRACK'] = Column(tracks, dtype='U12')
    cat['QA_TIER'] = Column(tiers, dtype=np.int16)
    cat['QA_GM_BIN'] = Column(gm_bins, dtype='U8')
    cat['QA_ANNOTATIONS'] = Column(annotations_list, dtype='U64')
    cat['QA_TIER_BITS'] = Column(tier_bits_list, dtype='U64')

    return cat


def filter_sample(cat, track: Optional[str], tier: Optional[int],
                  mindiam: float, maxdiam: float, diamcolumn: str) -> Table:
    """
    Filter catalog by track, tier, and diameter range.

    Parameters
    ----------
    cat : Table
        Classified catalog (must have QA_* columns)
    track : str or None
        'lvd', 'not-lvd', 'skiptractor', or None for all
    tier : int or None
        1, 2, 3, or None for all
    mindiam, maxdiam : float
        Diameter range in arcmin
    diamcolumn : str
        Column name for diameter ('D26' or 'DIAM')

    Returns
    -------
    Table
        Filtered catalog

    """
    mask = np.ones(len(cat), dtype=bool)

    # Diameter cut
    diam = cat[diamcolumn]
    mask &= (diam >= mindiam) & (diam < maxdiam)

    # Track filter
    if track is not None:
        mask &= (cat['QA_TRACK'] == track)

    # Tier filter
    if tier is not None:
        mask &= (cat['QA_TIER'] == tier)

    return cat[mask]


def partition_by_gm(cat, use_gmbins: bool = True) -> Dict[str, Table]:
    """
    Partition catalog by group multiplicity bin.

    Parameters
    ----------
    cat : Table
        Catalog with QA_GM_BIN column
    use_gmbins : bool
        If True, split into gm1/gm2/gm3/gm4plus
        If False, return all objects under 'gm_any'

    Returns
    -------
    dict
        Keys: 'gm1', 'gm2', 'gm3', 'gm4plus' (or 'gm_any')
        Values: filtered Table (may be empty)

    """
    if not use_gmbins:
        return {'gm_any': cat}

    result = {}
    for gm_bin in ['gm1', 'gm2', 'gm3', 'gm4plus']:
        mask = cat['QA_GM_BIN'] == gm_bin
        result[gm_bin] = cat[mask]
    return result


# ============================================================================
# Cutout and Image Handling
# ============================================================================

def read_coadds(galaxy, galaxydir, refid, ra=None, dec=None, diam=None,
                cutout_galaxy=None, cutout_galaxydir=None, cutout=False):
    """Read image and Tractor catalog for a galaxy."""
    from astropy.wcs import WCS

    if cutout:
        from SGA.sky import simple_wcs
        from SGA.cutouts import get_pixscale_and_width

        pixscale, width = get_pixscale_and_width(
            np.atleast_1d(diam), maxdiam_arcmin=MAXDIAM_CUTOUT)
        wcs = simple_wcs(ra, dec, width[0], pixscale[0])

        imagefile = os.path.join(os.path.dirname(cutout_galaxydir), f'{cutout_galaxy}.jpeg')
        if not os.path.isfile(imagefile):
            log.warning(f'Cutout for {cutout_galaxydir} not found')
            return Table(), Table(), None, None

        image = imread(imagefile)
        return Table(), Table(), image, wcs

    imagefile = os.path.join(galaxydir, f'{galaxy}-image.jpg')
    tractorfile = os.path.join(galaxydir, f'{galaxy}-tractor.fits')

    if not os.path.isfile(imagefile) and not os.path.isfile(tractorfile):
        log.warning(f'Missing pipeline outputs for {galaxydir}/{galaxy}')
        return Table(), Table(), None, None

    # Read Tractor catalog
    sga = Table()
    tractor = Table()
    if os.path.isfile(tractorfile):
        cols = ['bx', 'by', 'ra', 'dec', 'type', 'sersic', 'shape_r',
                'shape_e1', 'shape_e2', 'ref_cat', 'ref_id', 'flux_g',
                'flux_r', 'flux_i', 'flux_z']
        tractor = Table(fitsio.read(tractorfile, columns=cols))

        I = ((tractor['ref_cat'] == 'LG') | (tractor['ref_cat'] == REFCAT)) & \
            (tractor['ref_id'] == refid)
        if np.sum(I) > 0:
            sga = tractor[I]
    else:
        log.warning(f'Missing tractor catalog {tractorfile}')

    if not os.path.isfile(imagefile):
        log.critical(f'Image missing: {galaxydir}/{galaxy}')
        return Table(), Table(), None, None

    image = imread(imagefile)

    # Get WCS from FITS image
    wcs = None
    for band in ['g', 'r', 'i', 'z']:
        for ext in ['.fits.fz', '.fits']:
            fitsfile = os.path.join(galaxydir, f'{galaxy}-image-{band}{ext}')
            if os.path.isfile(fitsfile):
                hdr = fitsio.read_header(fitsfile, ext=1)
                wcs = WCS(hdr, naxis=2)
                break
        if wcs is not None:
            break

    return sga, tractor, image, wcs


def ensure_cutouts(sample, fullsample, region, datadir, cutoutdir, mp=1, no_groups=False):
    """
    Check for existing images and generate cutouts for missing ones.

    Modifies sample and fullsample in place to add 'CUTOUT' column.

    """
    galaxy, galaxydir = get_galaxy_galaxydir(
        sample, region=region, group=not no_groups, datadir=datadir)
    galaxy = np.atleast_1d(galaxy)
    galaxydir = np.atleast_1d(galaxydir)

    # Check which have images
    has_image = np.array([
        os.path.isfile(os.path.join(gdir, f'{gal}-image.jpg'))
        for gdir, gal in zip(galaxydir, galaxy)
    ])

    log.info(f'Found {np.sum(has_image):,d}/{len(sample):,d} objects with pipeline results.')

    sample['CUTOUT'] = np.zeros(len(sample), bool)
    fullsample['CUTOUT'] = np.zeros(len(fullsample), bool)

    if np.sum(~has_image) == 0:
        return

    # Mark objects needing cutouts
    group_names = sample['GROUP_NAME'][~has_image]
    sample['CUTOUT'] = np.isin(sample['GROUP_NAME'], group_names)
    fullsample['CUTOUT'] = np.isin(fullsample['GROUP_NAME'], group_names)

    # Check which cutouts already exist
    missing_sample = sample[~has_image]
    galaxy_missing, _ = get_galaxy_galaxydir(
        missing_sample, region=region, group=not no_groups, datadir=cutoutdir)
    raslices = get_raslice(missing_sample['GROUP_RA'])

    needs_cutout = np.array([
        not os.path.isfile(os.path.join(cutoutdir, region, raslice, f'{gal}.jpeg'))
        for gal, raslice in zip(np.atleast_1d(galaxy_missing), np.atleast_1d(raslices))
    ])

    n_needed = np.sum(needs_cutout)
    log.info(f'Generating cutouts for {n_needed:,d}/{np.sum(~has_image):,d} objects.')

    if n_needed > 0:
        from SGA.cutouts import do_cutouts

        layer = f'ls-{region}'
        if region == 'dr11-south':
            log.warning(f"Overriding layer={layer}-->ls-dr11-early-v2")
            layer = 'ls-dr11-early-v2'

        do_cutouts(
            missing_sample[needs_cutout],
            layer=layer,
            group=not no_groups,
            diamcolumn='GROUP_DIAMETER',
            fits_cutouts=False,
            maxdiam_arcmin=MAXDIAM_CUTOUT,
            mp=mp,
            cutoutdir=os.path.join(cutoutdir, region)
        )


# ============================================================================
# Annotation and Plotting
# ============================================================================

def format_annotations(annotations_str: str) -> str:
    """Format annotation string for display."""
    if not annotations_str:
        return ''
    return annotations_str.replace(',', ' | ')


def annotated_page(ax, obj, fullsample, galaxy, galaxydir,
                   cutout_galaxy, cutout_galaxydir,
                   region, datadir, cutoutdir, diamcolumn,
                   show_tractor_ellipse, show_initial_ellipse,
                   final_sample, no_groups, show_group):
    """
    Draw a single annotated panel for one object.

    """
    from astropy.wcs.utils import proj_plane_pixel_scales as get_pixscale

    # Get geometry columns based on catalog type
    if final_sample:
        objra, objdec = obj['RA'], obj['DEC']
        diam, ba, pa = obj['D26'] * 60., obj['BA'], obj['PA']
        geo_label = f'D(26)={diam:.1f}" b/a={ba:.2f} PA={pa:.1f}'

        objra0, objdec0 = obj['RA_INIT'], obj['DEC_INIT']
        diam0, ba0, pa0 = obj['DIAM_INIT'] * 60., obj['BA_INIT'], obj['PA_INIT']
        geo0_label = f'D(25)={diam0:.1f}" b/a={ba0:.2f} PA={pa0:.1f}'
    else:
        objra0, objdec0 = obj['RA'], obj['DEC']
        diam0, ba0, pa0 = obj['DIAM'] * 60., obj['BA'], obj['PA']
        geo0_label = f'D(25)={diam0:.1f}" b/a={ba0:.2f} PA={pa0:.1f}'
        objra, objdec = objra0, objdec0
        diam, ba, pa = diam0, ba0, pa0
        geo_label = None

    # Build upper-left text
    group_mult = obj['GROUP_MULT'] if 'GROUP_MULT' in obj.colnames else 1
    txt_ul_lines = [
        obj["OBJNAME"],
        f'{obj["GROUP_NAME"]} (M={group_mult})',
        f'({objra:.7f}, {objdec:.6f})',
    ]
    if show_initial_ellipse and final_sample:
        txt_ul_lines.append(geo0_label)
    if geo_label:
        txt_ul_lines.append(geo_label)

    # Add annotations
    if 'QA_ANNOTATIONS' in obj.colnames and obj['QA_ANNOTATIONS']:
        ann_str = format_annotations(obj['QA_ANNOTATIONS'])
        if ann_str:
            txt_ul_lines.append(f'[{ann_str}]')

    txt_ul = '\n'.join(txt_ul_lines)

    # Determine group center and diameter for image
    if obj['CUTOUT'] or no_groups:
        if final_sample:
            groupra, groupdec = obj['RA'], obj['DEC']
        else:
            groupra, groupdec = obj['GROUP_RA'], obj['GROUP_DEC']
        groupdiam = obj['GROUP_DIAMETER'] * 60.
    else:
        groupra, groupdec = obj['GROUP_RA'], obj['GROUP_DEC']
        groupdiam = obj['GROUP_DIAMETER'] * 60.

    # Read image
    sga, tractor, image, wcs = read_coadds(
        galaxy, galaxydir, refid=obj[REFIDCOLUMN],
        ra=groupra, dec=groupdec, diam=groupdiam,
        cutout_galaxy=cutout_galaxy, cutout_galaxydir=cutout_galaxydir,
        cutout=obj['CUTOUT']
    )

    if image is None:
        ax.text(0.5, 0.5, 'No image available', transform=ax.transAxes,
                ha='center', va='center', fontsize=12)
        ax.axis('off')
        return

    height, width, _ = image.shape
    pixscale = get_pixscale(wcs)[0] * 3600.  # arcsec/pixel

    ax.set_xlim(0, width)
    ax.set_ylim(0, height)
    ax.imshow(image, origin='lower', interpolation='none')
    ax.invert_yaxis()  # JPEG is flipped

    for spine in ax.spines.values():
        spine.set_color('white')

    # Plot Tractor sources
    if len(tractor) > 0:
        I = tractor['ref_cat'] == 'L4'
        if np.sum(I) > 0:
            alpha = 0.5 if np.sum(I) > 50 else 1.0
            s = 10 if np.sum(I) > 50 else 25
            ax.scatter(tractor['bx'][I], height - tractor['by'][I],
                       marker='x', s=s, color='red', alpha=alpha)

    # Draw initial ellipse
    if show_initial_ellipse:
        xpix0, ypix0 = wcs.wcs_world2pix(objra0, objdec0, 0)
        overplot_ellipse(diam0, ba0, pa0, xpix0, ypix0,
                         height_pixels=width, pixscale=pixscale,
                         ax=ax, color='white', linewidth=0.3 if final_sample else 1,
                         linestyle='-', draw_majorminor_axes=not final_sample, jpeg=True)

    # Draw final ellipse (if different)
    if final_sample:
        xpix, ypix = wcs.wcs_world2pix(objra, objdec, 0)
        overplot_ellipse(diam, ba, pa, xpix, ypix,
                         height_pixels=width, pixscale=pixscale,
                         ax=ax, color='cyan', linewidth=2, linestyle='-',
                         draw_majorminor_axes=True, jpeg=True)
        ax.scatter(xpix, height - ypix, marker='s', facecolor='none', s=40, color='cyan')

    # Draw Tractor ellipse
    txt_ll = ''
    txt_ur = ''
    if len(sga) > 0 and show_tractor_ellipse:
        r50 = sga['shape_r'][0]
        e1, e2 = sga['shape_e1'][0], sga['shape_e2'][0]
        tractor_diam, tractor_ba, tractor_pa = get_tractor_ellipse(r50, e1, e2)

        xpix_t, ypix_t = wcs.wcs_world2pix(sga['ra'][0], sga['dec'][0], 0)
        overplot_ellipse(2. * r50, tractor_ba, tractor_pa, xpix_t, ypix_t,
                         height_pixels=height, pixscale=pixscale,
                         ax=ax, color='yellow', linewidth=1, linestyle='--',
                         draw_majorminor_axes=True, jpeg=True)
        ax.scatter(sga['bx'], height - sga['by'], marker='s',
                   facecolor='none', s=40, color='yellow')

        typ = sga['type'][0]
        txt_ur = typ
        if typ != 'PSF':
            geo_tractor = f'r(50)={r50:.1f}" b/a={tractor_ba:.2f} PA={tractor_pa:.1f}'
            txt_ll = geo_tractor

    # For tiers 1-2, show the triggering bits in lower-left
    if 'QA_TIER' in obj.colnames and obj['QA_TIER'] in (1, 2):
        tier_bits_str = obj.get('QA_TIER_BITS', '')
        if tier_bits_str:
            tier_label = f"[{tier_bits_str.replace(',', ' | ')}]"
            if txt_ll:
                txt_ll = f"{tier_label}\n{txt_ll}"
            else:
                txt_ll = tier_label

    # Draw other group members if show_group
    if show_group and not no_groups:
        for otherobj in fullsample:
            if otherobj[REFIDCOLUMN] == obj[REFIDCOLUMN]:
                continue
            if otherobj['GROUP_NAME'] != obj['GROUP_NAME']:
                continue
            other_ra, other_dec = otherobj['RA'], otherobj['DEC']
            if final_sample and 'D26' in otherobj.colnames:
                other_diam = otherobj['D26'] * 60.
            else:
                other_diam = otherobj['DIAM'] * 60.
            other_ba = otherobj['BA']
            other_pa = otherobj['PA']

            xpix_o, ypix_o = wcs.wcs_world2pix(other_ra, other_dec, 0)

            # Draw ellipse with thin red curve
            overplot_ellipse(other_diam, other_ba, other_pa, xpix_o, ypix_o,
                             height_pixels=width, pixscale=pixscale,
                             ax=ax, color='red', linestyle='-', linewidth=0.5,
                             draw_majorminor_axes=False, jpeg=True)

            # Mark center with x
            ax.scatter(xpix_o, height - ypix_o, marker='x', s=25, color='red', linewidths=0.5)

    # Text labels
    ax.text(0.03, 0.97, txt_ul, transform=ax.transAxes, ha='left', va='top',
            color='white', linespacing=1.5, fontsize=8,
            bbox=dict(boxstyle='round', facecolor='k', alpha=0.5))

    if txt_ll and show_tractor_ellipse:
        ax.text(0.03, 0.03, txt_ll, transform=ax.transAxes, ha='left', va='bottom',
                color='white', linespacing=1.5, fontsize=8,
                bbox=dict(boxstyle='round', facecolor='k', alpha=0.5))

    if txt_ur and show_tractor_ellipse:
        ax.text(0.97, 0.97, txt_ur, transform=ax.transAxes, ha='right', va='top',
                color='white', linespacing=1.5, fontsize=8,
                bbox=dict(boxstyle='round', facecolor='k', alpha=0.5))

    ax.margins(0)
    ax.set_xticks([])
    ax.set_yticks([])


def generate_pdf(sample, fullsample, pdffile, region, datadir, cutoutdir,
                 diamcolumn, ncol=4, nrow=2, inches_per_panel=4.,
                 show_tractor_ellipse=True, show_initial_ellipse=True,
                 final_sample=False, no_groups=False, show_group=True,
                 verbose=False):
    """
    Generate PDF with annotated galaxy images.

    """
    import matplotlib as mpl

    # PDF optimization settings
    mpl.rcParams["pdf.compression"] = 9
    mpl.rcParams['path.simplify'] = True
    mpl.rcParams["path.simplify_threshold"] = 1.0
    mpl.rcParams["pdf.fonttype"] = 42
    mpl.rcParams["ps.fonttype"] = 42
    mpl.rcParams["pdf.use14corefonts"] = True

    # Get paths for all objects
    showsample = fullsample if not no_groups else sample

    galaxy, galaxydir = get_galaxy_galaxydir(
        showsample, region=region, group=not no_groups, datadir=datadir)
    galaxy = np.atleast_1d(galaxy)
    galaxydir = np.atleast_1d(galaxydir)

    # Handle cutouts
    I = showsample['CUTOUT'].value if 'CUTOUT' in showsample.colnames else np.zeros(len(showsample), bool)
    if np.any(I):
        cutout_galaxy = np.copy(galaxy)
        cutout_galaxydir = np.copy(galaxydir)
        cgalaxy, cgalaxydir = get_galaxy_galaxydir(
            showsample[I], region=region, group=not no_groups, datadir=cutoutdir)
        cutout_galaxy[I] = cgalaxy
        cutout_galaxydir[I] = cgalaxydir
    else:
        cutout_galaxy = [None] * len(showsample)
        cutout_galaxydir = [None] * len(showsample)

    nobj = len(showsample)
    nperpage = ncol * nrow
    npage = int(np.ceil(nobj / nperpage))

    pdf = PdfPages(pdffile)

    for ipage in range(npage):
        if (ipage + 1) % 64 == 0 or verbose:
            log.info(f'Building page {ipage+1:,d}/{npage:,d}')

        i_start = ipage * nperpage
        i_end = min((ipage + 1) * nperpage, nobj)

        fig, axes = plt.subplots(
            nrow, ncol,
            figsize=(inches_per_panel * ncol, inches_per_panel * nrow),
            gridspec_kw={'wspace': 0.02, 'hspace': 0.02},
            constrained_layout=True
        )
        axes = axes.ravel()

        for iax, ax in enumerate(axes):
            idx = i_start + iax
            if idx < nobj:
                obj = showsample[idx]
                annotated_page(
                    ax, obj, fullsample,
                    galaxy[idx], galaxydir[idx],
                    cutout_galaxy[idx], cutout_galaxydir[idx],
                    region, datadir, cutoutdir, diamcolumn,
                    show_tractor_ellipse, show_initial_ellipse,
                    final_sample, no_groups, show_group
                )
                # Add index label
                ax.text(0.97, 0.03, str(idx + 1), transform=ax.transAxes,
                        ha='right', va='bottom', color='white', fontsize=9,
                        bbox=dict(boxstyle='round', facecolor='k', alpha=0.5))
            else:
                ax.axis('off')

        pdf.savefig(fig, bbox_inches='tight')
        plt.close()

    pdf.close()
    log.info(f'Wrote {pdffile}')

    mpl.rcParams['path.simplify'] = False


# ============================================================================
# Output Directory and File Management
# ============================================================================

def get_output_dir(basedir: str, region: str, mindiam: float, maxdiam: float,
                   track: str, tier: int, gm_bin: str) -> str:
    """
    Get output directory path for a specific track/tier/gm combination.

    Does NOT create the directory - caller should create only if needed.

    """
    diam_str = f'diam_{mindiam:.1f}_{maxdiam:.1f}'
    return os.path.join(basedir, region, diam_str, track, f'tier{tier}_{gm_bin}')


def get_pdf_filename(outdir: str, track: str, tier: int, gm_bin: str,
                     region: str, subset: int = 1) -> str:
    """Generate PDF filename."""
    return os.path.join(outdir, f'qa-{track}-tier{tier}-{gm_bin}-{region}-{subset:03d}.pdf')


def get_txt_filename(outdir: str, track: str, tier: int, gm_bin: str,
                     region: str, subset: int = 1) -> str:
    """Generate text catalog filename."""
    return os.path.join(outdir, f'cat-{track}-tier{tier}-{gm_bin}-{region}-{subset:03d}.txt')


def get_viewer_filename(outdir: str, track: str, tier: int, gm_bin: str,
                        region: str, subset: int = 1) -> str:
    """Generate viewer FITS filename."""
    return os.path.join(outdir, f'viewer-{track}-tier{tier}-{gm_bin}-{region}-{subset:03d}.fits')


def write_txt_file(sample, txtfile: str, diamcolumn: str):
    """Write text file with object names for VI."""
    with open(txtfile, 'w') as f:
        for obj in sample:
            f.write(f'{obj["OBJNAME"]}\n')
    log.info(f'Wrote {txtfile}')


def write_viewer_file(sample, viewerfile: str, diamcolumn: str):
    """Write FITS file for Legacy Survey viewer overlay."""
    view = sample['OBJNAME', 'RA', 'DEC', diamcolumn, 'BA', 'PA'].copy()
    view.rename_columns(
        ['OBJNAME', 'RA', 'DEC', diamcolumn, 'BA', 'PA'],
        ['name', 'ra', 'dec', 'radius', 'abRatio', 'posAngle']
    )
    # Convert diameter to radius in arcsec
    view['radius'] = view['radius'] * 60. / 2.
    view.write(viewerfile, overwrite=True)
    log.info(f'Wrote {viewerfile}')


# ============================================================================
# Main QA Function
# ============================================================================

def qa_tractor(region='dr11-south', version=None, datadir=None,
               mindiam=0.5, maxdiam=5.0, track='all', tier='all',
               final_sample=False, no_groups=False, show_group=True,
               show_tractor_ellipse=True, show_initial_ellipse=True,
               use_gmbins=True,
               ncol=4, nrow=2, nperpdf=4096, mp=1, verbose=False,
               first=None, last=None, galaxylist=None):
    """
    Generate QA PDFs organized by track, tier, and group multiplicity.

    Parameters
    ----------
    region : str
        'dr9-north' or 'dr11-south'
    version : str
        Catalog version (e.g., 'v0.70')
    datadir : str
        Override $SGA_DATA_DIR
    mindiam, maxdiam : float
        Diameter range in arcmin
    track : str
        'all', 'lvd', 'not-lvd', or 'skiptractor'
    tier : str or int
        'all', 1, 2, or 3
    final_sample : bool
        If True, read ellipse catalog (D26); else parent catalog (DIAM)
    no_groups : bool
        If True, show individual objects not group cutouts
    show_group : bool
        If True, annotate other group members on image
    use_gmbins : bool
        If True, split by GM=1/2/3/4+; if False, use 'gm_any' for all
    ncol, nrow : int
        PDF page layout
    nperpdf : int
        Max objects per PDF file
    mp : int
        Multiprocessing workers for cutout generation

    """
    if datadir is None:
        datadir = sga_data_dir()
    cutoutdir = os.path.join(datadir, 'cutouts')

    if version is None:
        version = SGA_version()

    # Read catalog
    sample, fullsample = read_sample(
        region=region, first=first, last=last, galaxylist=galaxylist,
        version=version, no_groups=no_groups, final_sample=final_sample,
        mindiam=0., maxdiam=1e6  # We'll filter later
    )

    # Determine catalog type and diameter column
    has_ellipsebit = 'ELLIPSEBIT' in fullsample.colnames
    diamcolumn = 'D26' if final_sample else 'DIAM'

    log.info(f'Catalog type: {"ellipse" if has_ellipsebit else "parent"}, '
             f'diameter column: {diamcolumn}')

    # Classify all objects
    log.info('Classifying objects...')
    fullsample = classify_catalog(fullsample, has_ellipsebit)
    sample = classify_catalog(sample, has_ellipsebit)

    # Determine which tracks and tiers to process
    if track == 'all':
        tracks = ['lvd', 'not-lvd', 'skiptractor']
    else:
        tracks = [track]

    if tier == 'all':
        tiers = [1, 2, 3] if has_ellipsebit else [3]
    else:
        tiers = [int(tier)]

    # Set up output base directory
    qadir = os.path.join(sga_dir(), 'qa', f'qa-{version}')

    # Process each track/tier/gm combination
    for proc_track in tracks:
        for proc_tier in tiers:
            # Filter sample
            filtered = filter_sample(
                sample if no_groups else fullsample,
                track=proc_track, tier=proc_tier,
                mindiam=mindiam, maxdiam=maxdiam, diamcolumn=diamcolumn
            )

            if len(filtered) == 0:
                log.info(f'No objects in {proc_track}/tier{proc_tier} '
                         f'(diam {mindiam:.1f}-{maxdiam:.1f}), skipping.')
                continue

            # Get GROUP_PRIMARY subset for cutout checking
            filtered_primary = filtered[filtered['GROUP_PRIMARY']] if 'GROUP_PRIMARY' in filtered.colnames else filtered

            # Get fullsample subset for this track/tier
            filtered_fullsample = fullsample[np.isin(fullsample['GROUP_NAME'], filtered['GROUP_NAME'])]

            # Ensure cutouts exist for this subset only
            log.info(f'Checking images for {proc_track}/tier{proc_tier} ({len(filtered_primary):,d} groups)...')
            ensure_cutouts(filtered_primary, filtered_fullsample, region, datadir, cutoutdir, mp=mp, no_groups=no_groups)

            # Partition by group multiplicity
            gm_partitions = partition_by_gm(filtered, use_gmbins=use_gmbins)

            for gm_bin, gm_sample in gm_partitions.items():
                if len(gm_sample) == 0:
                    continue

                # Create output directory only now that we have objects
                outdir = get_output_dir(qadir, region, mindiam, maxdiam,
                                        proc_track, proc_tier, gm_bin)
                os.makedirs(outdir, exist_ok=True)

                nobj = len(gm_sample)

                log.info(f'{proc_track}/tier{proc_tier}/{gm_bin}: {nobj:,d} objects')

                # Sort by diameter
                gm_sample = gm_sample[np.argsort(gm_sample[diamcolumn])]

                # Propagate CUTOUT flags from filtered_fullsample
                gm_sample = gm_sample.copy()
                cutout_lookup = {name: cut for name, cut in zip(filtered_fullsample['GROUP_NAME'], filtered_fullsample['CUTOUT'])}
                gm_sample['CUTOUT'] = [cutout_lookup.get(name, False) for name in gm_sample['GROUP_NAME']]

                # Get corresponding fullsample for group annotations
                if no_groups:
                    gm_fullsample = filtered_fullsample[np.isin(filtered_fullsample['GROUP_NAME'], gm_sample['GROUP_NAME'])]
                else:
                    gm_fullsample = gm_sample

                # Split into PDFs
                npdf = int(np.ceil(nobj / nperpdf))
                for ipdf in range(npdf):
                    i_start = ipdf * nperpdf
                    i_end = min((ipdf + 1) * nperpdf, nobj)

                    this_sample = gm_sample[i_start:i_end]
                    this_fullsample = gm_fullsample[np.isin(
                        gm_fullsample['GROUP_NAME'], this_sample['GROUP_NAME'])]

                    # Generate filenames
                    pdffile = get_pdf_filename(
                        outdir, proc_track, proc_tier, gm_bin, region, ipdf + 1)
                    txtfile = get_txt_filename(
                        outdir, proc_track, proc_tier, gm_bin, region, ipdf + 1)
                    viewerfile = get_viewer_filename(
                        outdir, proc_track, proc_tier, gm_bin, region, ipdf + 1)

                    # Write auxiliary files
                    write_txt_file(this_fullsample, txtfile, diamcolumn)
                    write_viewer_file(this_fullsample, viewerfile, diamcolumn)

                    # Generate PDF
                    generate_pdf(
                        this_sample, this_fullsample, pdffile,
                        region=region, datadir=datadir, cutoutdir=cutoutdir,
                        diamcolumn=diamcolumn, ncol=ncol, nrow=nrow,
                        show_tractor_ellipse=show_tractor_ellipse,
                        show_initial_ellipse=show_initial_ellipse,
                        final_sample=final_sample, no_groups=no_groups,
                        show_group=show_group, verbose=verbose
                    )

    log.info('QA generation complete.')


# ============================================================================
# CLI
# ============================================================================

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
        description='Generate SGA2025 Tractor QA PDFs',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # All tracks/tiers for ellipse catalog, 0.5-5 arcmin
  %(prog)s --region=dr11-south --version=v0.70 --final-sample --mindiam=0.5 --maxdiam=5.0

  # Just LVD track
  %(prog)s --region=dr11-south --version=v0.70 --final-sample --track=lvd

  # Just pipeline failures (tier 1)
  %(prog)s --region=dr11-south --version=v0.70 --final-sample --tier=1

  # Parent catalog (no ELLIPSEBIT)
  %(prog)s --region=dr11-south --version=v0.80 --mindiam=1.0 --maxdiam=10.0
"""
    )

    parser.add_argument('--region', default='dr11-south',
                        choices=['dr9-north', 'dr11-south'],
                        help='Survey region')
    parser.add_argument('--version', type=str, default=None,
                        help='Catalog version (e.g., v0.70)')
    parser.add_argument('--datadir', type=str, default=None,
                        help='Override $SGA_DATA_DIR')

    parser.add_argument('--mindiam', type=float, default=0.5,
                        help='Minimum diameter in arcmin (default: 0.5)')
    parser.add_argument('--maxdiam', type=float, default=5.0,
                        help='Maximum diameter in arcmin (default: 5.0)')

    parser.add_argument('--track', type=str, default='all',
                        choices=['all', 'lvd', 'not-lvd', 'skiptractor'],
                        help='Track to process (default: all)')
    parser.add_argument('--tier', type=str, default='all',
                        help='Tier to process: 1, 2, 3, or all (default: all)')

    parser.add_argument('--final-sample', action='store_true',
                        help='Read ellipse catalog (D26) instead of parent (DIAM)')
    parser.add_argument('--no-groups', action='store_true',
                        help='Show individual objects, not group cutouts')
    parser.add_argument('--no-show-group', dest='show_group', action='store_false',
                        help='Do not annotate other group members')
    parser.add_argument('--no-gmbins', dest='use_gmbins', action='store_false',
                        help='Do not split by group multiplicity (use gm_any)')
    parser.add_argument('--hide-tractor-ellipse', dest='show_tractor_ellipse',
                        action='store_false',
                        help='Hide Tractor ellipse overlay')
    parser.add_argument('--hide-initial-ellipse', dest='show_initial_ellipse',
                        action='store_false',
                        help='Hide initial ellipse overlay')

    parser.add_argument('--ncol', type=int, default=4,
                        help='Columns per PDF page (default: 4)')
    parser.add_argument('--nrow', type=int, default=2,
                        help='Rows per PDF page (default: 2)')
    parser.add_argument('--nperpdf', type=int, default=4096,
                        help='Max objects per PDF (default: 4096)')
    parser.add_argument('--mp', type=int, default=1,
                        help='Multiprocessing workers (default: 1)')

    parser.add_argument('--first', type=int, help='First object index')
    parser.add_argument('--last', type=int, help='Last object index')
    parser.add_argument('--galaxylist', type=str, default=None,
                        help='Comma-separated list of galaxy names')

    parser.add_argument('--verbose', action='store_true',
                        help='Verbose output')

    args = parser.parse_args()

    qa_tractor(
        region=args.region,
        version=args.version,
        datadir=args.datadir,
        mindiam=args.mindiam,
        maxdiam=args.maxdiam,
        track=args.track,
        tier=args.tier,
        final_sample=args.final_sample,
        no_groups=args.no_groups,
        show_group=args.show_group,
        use_gmbins=args.use_gmbins,
        show_tractor_ellipse=args.show_tractor_ellipse,
        show_initial_ellipse=args.show_initial_ellipse,
        ncol=args.ncol,
        nrow=args.nrow,
        nperpdf=args.nperpdf,
        mp=args.mp,
        first=args.first,
        last=args.last,
        galaxylist=args.galaxylist,
        verbose=args.verbose,
    )
