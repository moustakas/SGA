#!/usr/bin/env python
"""Generate the figures for the SGA 2020 paper.

Load the legacyhalos code product, then, e.g.:
SGA-2020-figures --surface-brightness --sbmontage-gallery
etc.

Median r-K color:

nsafile = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.fits')
nsa = Table(fitsio.read(nsafile))
rk = -2.5 * np.log10(nsa['ELPETRO_FLUX'][:, 2]/nsa['ELPETRO_FLUX'][:, 6])
plt.clf() 
plt.hist(rk[np.isfinite(rk)], bins=100, range=(0, 5)) 
plt.xlim(0, 5) 
plt.axvline(x=3.4, color='k') 
plt.axvline(x=2.4, color='k') ; plt.savefig('junk.png')

"""
import os, sys, time, pdb
import argparse, subprocess
import numpy as np
import fitsio

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from astropy.table import Table, vstack, join

import legacyhalos.SGA
from legacyhalos.SGA import get_galaxy_galaxydir
from legacyhalos.SGA import DIAMCOLUMN, RACOLUMN, DECCOLUMN

paperdir = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'science', 'SGA-2020-paper')
figdir = os.path.join(paperdir, 'figures')
tabledir = os.path.join(paperdir, 'tables')

#figdir = os.path.join('/mnt', 'SGA', 'science', 'paper1', 'figures')
#figdir = os.path.join('/mnt', '20210115-aas-sga')
#figdir = os.path.join(os.getenv('HOME'), 'research', 'talks', '2021', '20210115-aas-sga')
#if not os.path.isdir(figdir):
#    figdir = os.path.join(os.getenv('HOME'), 'SGA', 'science', 'paper1', 'figures')
#    #figdir = os.path.join(os.getenv('HOME'), 'SGA', 'science', 'paper1', 'figures')
fonttype = os.path.join(os.getenv('LEGACYHALOS_CODE_DIR'), 'py', 'legacyhalos', 'data', 'Georgia-Italic.ttf')

url = 'https://portal.nersc.gov/project/cosmo/data/sga/2020/data/'
jpgurl = 'https://www.legacysurvey.org/viewer/jpeg-cutout?'

#os.environ['LEGACYHALOS_DIR'] = os.path.join(os.getenv('HOME'), 'research', 'projects', 'SGA')
#os.environ['LEGACYHALOS_DATA_DIR'] = figdir

def plot_style(font_scale=1.2, paper=False, talk=True):

    import seaborn as sns
    rc = {'font.family': 'serif'}#, 'text.usetex': True}
    #rc = {'font.family': 'serif', 'text.usetex': True,
    #       'text.latex.preamble': r'\boldmath'})
    palette, context = 'Set2', 'talk'
    
    if paper:
        context = 'paper'
        palette = 'deep'
        rc.update({'text.usetex': False})
    
    if talk:
        context = 'talk'
        palette = 'deep'
        #rc.update({'text.usetex': True})

    sns.set(context=context, style='ticks', font_scale=font_scale, rc=rc)
    sns.set_palette(palette, 12)

    colors = sns.color_palette()
    #sns.reset_orig()

    return sns, colors

# adapted from https://github.com/desihub/desiutil/blob/5735fdc34c4e77c7fda84c92c32b9ac41158b8e1/py/desiutil/plots.py#L735-L857
def ar_sky_cbar(ax, sc, label, extend=None, mloc=None):
    cbar = plt.colorbar(sc, ax=ax, location='bottom',
                        orientation="horizontal",
                        spacing="proportional",
                        extend=extend, extendfrac=0.025,
                        pad=0.1, 
                        fraction=0.035, aspect=40)
    cbar.ax.xaxis.set_ticks_position("bottom")
    cbar.set_label(label)#, labelpad=10)
    if mloc is not None:
        cbar.ax.xaxis.set_major_locator(ticker.MultipleLocator(mloc))

def plot_sky_binned(ra, dec, weights=None, data=None, plot_type='grid',
                    max_bin_area=5, clip_lo=None, clip_hi=None, verbose=False,
                    cmap='viridis', colorbar=True, label=None, ax=None,
                    return_grid_data=False, **kwargs):
    """Show objects on the sky using a binned plot.

    Bin values either show object counts per unit sky area or, if an array
    of associated data values is provided, mean data values within each bin.
    Objects can have associated weights.

    Requires that matplotlib is installed. When plot_type is
    "healpix", healpy must also be installed.

    Additional keyword parameters will be passed to :func:`init_sky`.

    Parameters
    ----------
    ra : array
        Array of object RA values in degrees. Must have the same shape as
        dec and will be flattened if necessary.
    dec : array
        Array of object Dec values in degrees. Must have the same shape as
        ra and will be flattened if necessary.
    weights : array, optional
        Optional of weights associated with each object.  All objects are
        assumed to have equal weight when this is None.
    data : array, optional
        Optional array of scalar values associated with each object. The
        resulting plot shows the mean data value per bin when data is
        specified.  Otherwise, the plot shows counts per unit sky area.
    plot_type : {'grid', 'healpix'}
        Must be either 'grid' or 'healpix', and selects whether data in
        binned in healpix or in (sin(Dec), RA).
    max_bin_area : :class:`float`, optional
        The bin size will be chosen automatically to be as close as
        possible to this value but not exceeding it.
    clip_lo : :class:`float` or :class:`str`, optional
        Clipping is applied to the plot data calculated as counts / area
        or the mean data value per bin. See :func:`prepare_data` for
        details.
    clip_hi : :class:`float` or :class:`str`, optional
        Clipping is applied to the plot data calculated as counts / area
        or the mean data value per bin. See :func:`prepare_data` for
        details.
    verbose : :class:`bool`, optional
        Print information about the automatic bin size calculation.
    cmap : colormap name or object, optional
        Matplotlib colormap to use for mapping data values to colors.
    colorbar : :class:`bool`, optional
        Draw a colorbar below the map when True.
    label : :class:`str`, optional
        Label to display under the colorbar.  Ignored unless colorbar is ``True``.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to use for drawing this map, or create default axes using
        :func:`init_sky` when ``None``.
    return_grid_data : :class:`bool`, optional
        If ``True``, return (ax, grid_data) instead of just ax.

    Returns
    -------
    :class:`~matplotlib.axes.Axes` or (ax, grid_data)
        The axis object used for the plot, and the grid_data if
        `return_grid_data` is ``True``.
    """
    from desiutil.plots import prepare_data

    ra = np.asarray(ra).reshape(-1)
    dec = np.asarray(dec).reshape(-1)
    if len(ra) != len(dec):
        raise ValueError('Arrays ra,dec must have same size.')

    plot_types = ('grid', 'healpix',)
    if plot_type not in plot_types:
        raise ValueError('Invalid plot_type, should be one of {0}.'.format(', '.join(plot_types)))

    if data is not None and weights is None:
        weights = np.ones_like(data)

    if plot_type == 'grid':
        # Convert the maximum pixel area to steradians.
        max_bin_area = max_bin_area * (np.pi / 180.) ** 2

        # Pick the number of bins in cos(DEC) and RA to use.
        n_cos_dec = int(np.ceil(2 / np.sqrt(max_bin_area)))
        n_ra = int(np.ceil(4 * np.pi / max_bin_area / n_cos_dec))
        # Calculate the actual pixel area in sq. degrees.
        bin_area = 360 ** 2 / np.pi / (n_cos_dec * n_ra)
        if verbose:
            print('Using {0} x {1} grid in cos(DEC) x RA'.format(n_cos_dec, n_ra),
                  'with pixel area {:.3f} sq.deg.'.format(bin_area))

        # Calculate the bin edges in degrees.
        # ra_edges = np.linspace(-180., +180., n_ra + 1)
        ra_edges = np.linspace(0.0, 360.0, n_ra + 1)
        dec_edges = np.degrees(np.arcsin(np.linspace(-1., +1., n_cos_dec + 1)))

        # Put RA values in the range [-180, 180).
        # ra = np.fmod(ra, 360.)
        # ra[ra >= 180.] -= 360.

        # Histogram the input coordinates.
        counts, _, _ = np.histogram2d(dec, ra, [dec_edges, ra_edges],
                                      weights=weights)

        if data is None:
            grid_data = counts / bin_area
        else:
            sums, _, _ = np.histogram2d(dec, ra, [dec_edges, ra_edges],
                                        weights=weights * data)
            # This ratio might result in some nan (0/0) or inf (1/0) values,
            # but these will be masked by prepare_data().
            settings = np.seterr(all='ignore')
            grid_data = sums / counts
            np.seterr(**settings)

        grid_data = prepare_data(grid_data, clip_lo=clip_lo, clip_hi=clip_hi)

        ax = plot_grid_map(grid_data, ra_edges, dec_edges,
                           cmap=cmap, colorbar=colorbar, label=label,
                           ax=ax, **kwargs)

    elif plot_type == 'healpix':

        import healpy as hp

        for n in range(1, 25):
            nside = 2 ** n
            bin_area = hp.nside2pixarea(nside, degrees=True)
            if bin_area <= max_bin_area:
                break
        npix = hp.nside2npix(nside)
        nest = False
        if verbose:
            print('Using healpix map with NSIDE={0}'.format(nside),
                  'and pixel area {:.3f} sq.deg.'.format(bin_area))

        pixels = hp.ang2pix(nside, np.radians(90 - dec), np.radians(ra), nest)
        counts = np.bincount(pixels, weights=weights, minlength=npix)
        if data is None:
            grid_data = counts / bin_area
        else:
            sums = np.bincount(pixels, weights=weights * data, minlength=npix)
            grid_data = np.zeros_like(sums, dtype=float)
            nonzero = counts > 0
            grid_data[nonzero] = sums[nonzero] / counts[nonzero]

        grid_data = prepare_data(grid_data)#, clip_lo=clip_lo, clip_hi=clip_hi)
        # Hack
        import numpy.ma as ma
        R = np.logical_or(grid_data == 0, grid_data <= clip_lo)
        grid_data[R] = ma.masked

        ax = plot_healpix_map(grid_data, nest=nest,
                              cmap=cmap, colorbar=colorbar, label=label,
                              ax=ax, **kwargs)

    if return_grid_data:
        return (ax, grid_data)
    else:
        return ax

def plot_healpix_map(data, nest=False, cmap='viridis', colorbar=True,
                     label=None, ax=None, **kwargs):
    """Plot a healpix map using an all-sky projection.

    Pass the data array through :func:`prepare_data` to select a subset to plot
    and clip the color map to specified values or percentiles.

    This function is similar to :func:`plot_grid_map` but is generally slower
    at high resolution and has less elegant handling of pixels that wrap around
    in RA, which are not drawn.

    Requires that matplotlib and healpy are installed.

    Additional keyword parameters will be passed to :func:`init_sky`.

    Parameters
    ----------
    data : array or masked array
        1D array of data associated with each healpix.  Must have a size that
        exactly matches the number of pixels for some NSIDE value. Use the
        output of :func:`prepare_data` as a convenient way to specify
        data cuts and color map clipping.
    nest : :class:`bool`, optional
        If ``True``, assume NESTED pixel ordering.  Otheriwse, assume RING pixel
        ordering.
    cmap : colormap name or object, optional
        Matplotlib colormap to use for mapping data values to colors.
    colorbar : :class:`bool`, optional
        Draw a colorbar below the map when ``True``.
    label : :class:`str`, optional
        Label to display under the colorbar.  Ignored unless colorbar is ``True``.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to use for drawing this map, or create default axes using
        :func:`init_sky` when ``None``.

    Returns
    -------
    :class:`~matplotlib.axes.Axes`
        The axis object used for the plot.
    """
    import healpy as hp
    from desiutil.plots import prepare_data
    from matplotlib.colors import Normalize, colorConverter
    from matplotlib.collections import PolyCollection

    data = prepare_data(data)
    if len(data.shape) != 1:
        raise ValueError('Invalid data array, should be 1D.')
    nside = hp.npix2nside(len(data))
    #
    # Create axes.
    #
    if ax is None:
        ax = init_sky(**kwargs)
    proj_edge = ax._ra_center - 180
    #
    # Find the projection edge.
    #
    while proj_edge < 0:
        proj_edge += 360
    #
    # Get pixel boundaries as quadrilaterals.
    #
    corners = hp.boundaries(nside, np.arange(len(data)), step=1, nest=nest)
    corner_theta, corner_phi = hp.vec2ang(corners.transpose(0, 2, 1))
    corner_ra, corner_dec = (np.degrees(corner_phi),
                             np.degrees(np.pi/2-corner_theta))
    #
    # Convert sky coords to map coords.
    #
    x, y = ax.projection_ra(corner_ra), ax.projection_dec(corner_dec)
    #
    # Regroup into pixel corners.
    #
    verts = np.array([x.reshape(-1, 4), y.reshape(-1, 4)]).transpose(1, 2, 0)
    #
    # Find and mask any pixels that wrap around in RA.
    #
    uv_verts = np.array([corner_phi.reshape(-1, 4),
                         corner_theta.reshape(-1, 4)]).transpose(1, 2, 0)
    theta_edge = np.unique(uv_verts[:, :, 1])
    phi_edge = np.radians(proj_edge)
    eps = 0.1 * np.sqrt(hp.nside2pixarea(nside))
    wrapped1 = hp.ang2pix(nside, theta_edge, phi_edge - eps, nest=nest)
    wrapped2 = hp.ang2pix(nside, theta_edge, phi_edge + eps, nest=nest)
    wrapped = np.unique(np.hstack((wrapped1, wrapped2)))
    data.mask[wrapped] = True
    #
    # Normalize the data using its vmin, vmax attributes, if present.
    #
    try:
        norm = Normalize(vmin=data.vmin, vmax=data.vmax)
    except AttributeError:
        norm = None
    #
    # Make the collection and add it to the plot.
    #
    good = np.where(~data.mask)[0]
    collection = PolyCollection(verts[good, :, :], array=data[good], cmap=cmap, norm=norm,
                                edgecolors='none')
    ax.add_collection(collection)
    ax.autoscale_view()

    if colorbar:
        bar = plt.colorbar(collection, ax=ax,
                           orientation='horizontal', spacing='proportional',
                           pad=0.11, fraction=0.05, aspect=50)
        if label:
            bar.set_label(label)

    return ax

def table_dwarfs(tex=None):

    dwarfsfile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'SGA-dwarfs.fits')
    dwarfs = Table(fitsio.read(dwarfsfile, upper=True))
    print('Read {} Local Group dwarfs from {}'.format(len(dwarfs), dwarfsfile))

    I = dwarfs['IGNORE']
    ignore = ', '.join(np.sort(dwarfs[I]['GALAXY'].data))
    ignore = ignore.replace('aI', 'a I').replace('aV', 'a V')
    ignore = ignore.replace('aX', 'a X').replace('sI', 's I').replace('ciI', 'ci I').replace('sV', 's V')
    ignore = ignore.replace('aB', 'a B').replace('oI', 'o I').replace('oT', 'o T').replace('oV', 'o V')
    ignore = ignore.replace('sdS', 's dS').replace('eI', 'e I').replace('aM', 'a M').replace('rI', 'r I').replace('n1', 'n 1')
    print()
    print('Ignore {} faint galaxies: {}'.format(np.sum(I), ignore))
    print('Min, max, median SB: {:.3f}, {:.3f}, {:.3f}'.format(
        np.min(dwarfs[I]['SB_D25']), np.max(dwarfs[I]['SB_D25']), 
        np.median(dwarfs[I]['SB_D25'])))

    J = dwarfs['RESOLVED']
    print()
    print('Ignore {} resolved galaxies: {}'.format(np.sum(J), ', '.join(np.sort(dwarfs[J]['GALAXY'].data))))

    #if tex:
    #    texfile = os.path.join(tabledir, tex)
    #    print('Writing {}'.format(texfile))
    #
    #    with open(texfile, 'w') as F:
    #        F.write('\begin{deluxetable}{ccccccc}[!h]\n')
    #        F.write('\tablecaption{Milky Way Dwarf Galaxies\label{table:dwarfs}}\n')
    #        F.write('\tablewidth{0pt}\n')
    #        F.write('\tablehead{\n')
    #        F.write('\colhead{} & \n')
    #        F.write('\colhead{} & \n')
    #        F.write('\colhead{$\mathbf{\lambda_{\rm eff}}$} & \n')
    #        F.write('\colhead{Area} & \n')
    #        F.write('\colhead{Depth} & \n')
    #        F.write('\colhead{Pixel Scale\tablenotemark{a}} & \n')
    #        F.write('\colhead{Image Quality} \\\n')
    #        F.write('\colhead{Survey} & \n')
    #        F.write('\colhead{Band} & \n')
    #        F.write('\colhead{($\micron$)} &\n')
    #        F.write('\colhead{(deg$^{2}$)} & \n')
    #        F.write('\colhead{(AB mag, $5\sigma$ PSF)} & \n')
    #        F.write('\colhead{(arcsec)} & \n')
    #        F.write('\colhead{(FWHM, arcsec)}\n')
    #        F.write('}\n')
    #        F.write('\startdata\n')
    #        F.write('\textit{WISE} & W4 & 22 & All-sky & 10.6 & 2.75 & 12 \\\n')
    #        F.write('\enddata\n')
    #        F.write('\tablenotetext{a}{Pixel scale of the image stacks generated as part of the \shortatlas; see \S\ref{sec:mosaics}.}\n')
    #        F.write('\end{deluxetable}\n')

def fig_sample_montage(sample, seed=1, png=None):
    """Show a random sampling of galaxies.

    """
    from legacyhalos.qa import addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'montage-galaxies')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    rand = np.random.RandomState(seed=seed)

    ncol = 7
    nrow = 6
    ngal = ncol * nrow

    # Pick XX random galaxies, uniformly selected in surface brightness.
    #r50 = tractor['SHAPE_R'].data
    #rmag = 22.5-2.5*np.log10(tractor['FLUX_R'].data)
    #sb = rmag + 2.5 * np.log10(np.pi * (60/2)**2) + 5*np.log10(r50/60)

    if False:
        good = np.where((sample['SMA_SB26'] != -1) * (sample['R_MAG_SB26'] != -1) * (sample['DEC'] < 30))[0]
        sample = sample[good]
    
        rmag = sample['R_MAG_SB26'].data
        r50 = sample['SMA_SB26'].data # [arcsec]
        sb = rmag + 2.5 * np.log10(2 * np.pi * r50**2)
        sample['SB'] = sb
    
        keep = np.where((rmag < 19) * (rmag > 13) * (r50 > 20) * (sb < 25) * (sb > 22))[0]
        print(len(keep))
        sample = sample[keep]
        print(np.min(sample['SB']), np.max(sample['SB']))

        nbin = 20
        _xbin = np.linspace(np.min(sample['SB']), np.max(sample['SB']), nbin)
        idx  = np.digitize(sample['SB'], _xbin)
    else:
        good = np.where((sample['GROUP_MULT'] == 1) * (sample['DEC'] < 30) *
                        (sample['SMA_SB26'] > 60) * (sample['SMA_SB26'] < 300) * # 1-10 arcmin
                        (sample['R_MAG_SB26'] > 12) * (sample['R_MAG_SB26'] < 20))[0]
        sample = sample[good]

        nbin = 10
        _xbin = np.linspace(np.min(sample['SMA_SB26']), np.max(sample['SMA_SB26']), nbin)
        idx  = np.digitize(sample['SMA_SB26'], _xbin)
        #_xbin = np.linspace(np.min(sample['GROUP_DIAMETER']), np.max(sample['GROUP_DIAMETER']), nbin)
        #idx  = np.digitize(sample['GROUP_DIAMETER'], _xbin)

    prob = np.zeros(len(sample))
    for kk in range(nbin):
        ww = idx == kk
        if np.sum(ww) > 0:
            prob[ww] = 1 / np.sum(ww)
    prob /= np.sum(prob)

    these = rand.choice(len(sample), ngal, p=prob, replace=False)
    #if seed == 5:
    #    these[8] = these[8] + 1 # SDSSJ222743.82+070833.3 is Galactic cirrus

    if False:
        srt = np.argsort(sample['SB'][these])
    else:
        srt = np.argsort(sample['SMA_SB26'][these])

    sample = sample[these[srt]]
    #print(sb.data)
    
    #print(sample['GALAXY', 'SMA_SB26', 'R_MAG_SB26', 'SB', 'GROUP_DIAMETER'])
    print(sample['GROUP_NAME', 'GROUP_DIAMETER', 'GROUP_MULT', 'SMA_SB26', 'R_MAG_SB26'])

    pixscale = 0.262
    barlen = np.ceil(60 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    gal, galdir = get_galaxy_galaxydir(sample)
    pngfiles = []
    for onegal, gal1, galdir1 in zip(sample, gal, galdir):
        jpgfile = os.path.join(galdir1, f'{gal1}-largegalaxy-image-grz.jpg')
        if not os.path.isfile(jpgfile):
            urlfile = url+'/'.join(jpgfile.split('/')[-3:])
            jpgfile = os.path.join(montagedir, f'{gal1}-largegalaxy-image-grz.jpg')
            if not os.path.isfile(jpgfile):
                cmd = f'wget -q -O {jpgfile} {urlfile}'
                print(cmd)
                subprocess.call(cmd.split())

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            addbar_to_png(jpgfile, barlen, barlabel, gal1.replace('_GROUP', ' Group'), pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        #cmd = 'montage -tile {}x{} -geometry 128x128 '.format(ncol, nrow)
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_hyperleda_rejects(sga, png=None):
    """Assortment of Hyperleda junk rejected by visual inspection."""

    from PIL import Image
    from SGA.io import read_hyperleda
    import astropy.units as u
    from astropy.io import fits
    from astropy.wcs import WCS
    from astropy.coordinates import SkyCoord
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'hyperleda-rejects')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 0.262
    barlen = np.ceil(30 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 4
    nrow = 3
    ngal = ncol * nrow

    os.environ['SGA_DIR'] = os.getenv('LEGACYHALOS_DIR')
    sample = read_hyperleda()
    #samplefile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'hyperleda', 'hyperleda-d25min10-18nov14.fits')
    #sample = Table(fitsio.read(samplefile, columns=['galaxy', 'pgc', 'ra', 'dec', 'pa', 'ba', 'd25', 'diam_ref'], upper=True))

    rejfile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'leda-spurious.txt')
    print(rejfile)
    #rejgal = np.loadtxt(rejfile, dtype=str)
    rejgal, reason = [], []
    with open(rejfile, 'r') as F:
        for line in F:
            words = line.split(' ')
            if words[0] == '#':
                continue
            rejgal.append(words[0].replace('\n', ''))
            if 'pre-fitting (' in line:
                words = words[:np.where(np.isin(words, 'pre-fitting'))[0][0]+1]
            if len(words) > 1 and words[1] != '':
                _reason = ' '.join(words[1:]).replace('\n', '')
                if 'HII' in _reason:
                    _reason = 'HII region'
                elif 'PoG' in _reason:
                    _reason = 'PoG'
                elif 'wrong diameter' in _reason:
                    _reason = 'wrong diameter'
                elif _reason == '':
                    _reason = 'none'
            else:
                _reason = 'none'
            _reason = _reason.strip()
            #if _reason == '':
            #    pdb.set_trace()
            reason.append(_reason)

    allrej = Table()
    allrej['GALAXY'] = rejgal
    allrej['REASON'] = reason

    _, U = np.unique(allrej['GALAXY'], return_index=True)
    allrej = allrej[U]

    # rejected galaxies not in Hyperleda
    I = ~np.isin(allrej['GALAXY'], sample['GALAXY'].data)
    extrarej = allrej[I]
    nodr8 = ['DR8' not in gal for gal in extrarej['GALAXY']]
    #print(extrarej[nodr8])

    #allreasons = rej['reason'].data
    #for reason in np.unique(rej['reason']):
    hyperrej = join(sample['GALAXY', 'RA', 'DEC', 'D25', 'BA', 'PA'], allrej, keys='GALAXY')

    _, U = np.unique(hyperrej['REASON'], return_index=True)
    hyperrej[U]['GALAXY', 'D25', 'REASON'].write('junk.txt', format='ascii.fast_tab', overwrite=True)

    #print(hyperrej[U][hyperrej[U]['D25'] > 0.5])

    #'IC2144', # reflection nebula - not in Hyperleda
    #'PGC061664', # way overestimated diameter (star+merger)

    I = hyperrej['D25'] > 1
    J = ['wrong diameter' in reason for reason in hyperrej['REASON'][I]]
    print(hyperrej[I][J])

    rejgal = [
        'PGC095115', # spurious
        'PGC1373079', # spurious (pair of stars)
        'PGC1192899', # two stars        
        'PGC1497763', # trio of stars
        #'PGC1231967', # trio of stars
        'SDSSJ020334.60-092540.0', # spurious / wrong diameter
        'PGC460281', # star / wrong diameter
        'PGC1453208', # trio of stars near medium star
        'PGC2500856', # star between two real galaxies
        #'PGC039027', # LSB?
        'PGC1111201', # PofG / part of PGC1111317
        'PGC071502', # spurious / part of ESO240-004
        'PGC093084', # HII region in NGC1507
        #'PGC129468', # duplicate"
        #'PGC432973', # duplicate / shred of PGC432946"
        'SDSSJ211630.38+001817.7', # shredded with PGC188224
    ]

    #rejgal = [
    #    'PGC1288721',   # wrong diameter (trio of galaxies)
    #    'PGC166101',    # totally spurious (and >2 arcmin!)
    #    'PGC3112871',   # wrong diameter (impacted by nearby star)
    #    'PGC3097828',   # spurious (reflection from a nearby star?)        
    #    'PGC1189991',   # spurious (triple of stars)
    #    #'PGC2133030',   # spurious (triple of stars)
    #    'PGC051602',    # REX   over-estimated diameter in Hyperleda
    #]

    # retain the order
    I = np.hstack([np.where(hyperrej['GALAXY'] == gal)[0] for gal in rejgal])
    #I = np.isin(hyperrej['GALAXY'], rejgal)

    samp = hyperrej[I]
    print(samp)

    # find the SGA sources near these rejects
    coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    coord_samp = SkyCoord(ra=samp['RA']*u.deg, dec=samp['DEC']*u.deg)

    sga_close = []
    for coord_samp1, d25 in zip(coord_samp, samp['D25']):
        sep = coord_samp1.separation(coord_sga)
        close = sep.arcsec < 2*d25*60
        if np.any(close):
            sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
        else:
            sga_close.append(Table())

    pngfiles = []
    for onegal, onesga in zip(samp, sga_close):
        jpgfile = os.path.join(montagedir, '{}-reject.jpg'.format(onegal['GALAXY']))
        width = int(2 * onegal['D25'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['RA'], onegal['DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = onegal['RA']
        hdr['CRVAL2'] = onegal['DEC']
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600
        wcs = WCS(hdr)

        if width > 500:
            lw = 4
        else:
            lw = 2
        print(onegal['GALAXY'], width, lw)

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size
                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                                    onegal['PA'], onegal['D25'] * 60.0, pixscale, 
                                    color='tomato', linewidth=lw)
                # add the SGA sources, if any
                if len(onesga) > 0:
                    for onesga1 in onesga:
                        xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                        draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                            onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                            color='dodgerblue', linewidth=lw)
                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            addbar_to_png(pngfile1, barlen, barlabel, onegal['GALAXY'], pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_sky(S, clip_lo=0, clip_hi=50, max_bin_area=10, mloc=10, png=None):

    import seaborn as sns
    import healpy as hp
    from astropy.coordinates import SkyCoord
    from astropy import units, constants
    from desiutil.plots import init_sky#, prepare_data, plot_sky_binned

    print(len(S))

    #sns, _ = plot_style(talk=True, font_scale=0.8)

    font = {'size': 14,} #'family': 'normal', 'weight': 'bold'}
    mpl.rc('font', **font)

    # AR DES
    def plot_des(ax, desfn=None, **kwargs):
        if desfn is None:
            desfn = os.path.join(os.getenv("DESI_ROOT"), "survey", "observations", "misc", "des_footprint.txt")
        ras, decs = np.loadtxt(desfn, unpack=True)
        ax.plot(ax.projection_ra(ras), ax.projection_dec(decs), **kwargs)
            
    # AR galactic, ecliptic plane
    def plot_gp_ep(ax, frame, npt=1000, **kwargs):
        """
        frame: "galactic" or "barycentricmeanecliptic"

        """ 
        cs =  SkyCoord(
            np.linspace(0, 360, npt) * units.degree,
            np.zeros(npt) * units.degree,
            frame=frame,
        )       
        ras, decs = cs.icrs.ra.degree, cs.icrs.dec.degree
        ii = ax.projection_ra(ras).argsort()
        _ = ax.plot(ax.projection_ra(ras[ii]), ax.projection_dec(decs[ii]), **kwargs)
    
    def custom_plot_sky_circles(ax, ra_center, dec_center, field_of_view, **kwargs):
        """
        similar to desiutil.plots.plot_sky_circles
        but with propagating **kwargs
        """
        if (isinstance(ra_center, int) | isinstance(ra_center, float)):
            ra_center, dec_center = np.array([ra_center]), np.array([dec_center])
        proj_edge = ax._ra_center - 180
        while proj_edge < 0:
            proj_edge += 360
        #
        angs = np.linspace(2 * np.pi, 0, 101)
        for ra, dec in zip(ra_center, dec_center):
            ras = ra + 0.5 * field_of_view / np.cos(np.radians(dec)) * np.cos(angs)
            decs = dec + 0.5 * field_of_view * np.sin(angs)
            for sel in [ras > proj_edge, ras <= proj_edge]:
                if sel.sum() > 0:
                    ax.fill(ax.projection_ra(ras[sel]), ax.projection_dec(decs[sel]), **kwargs)
    
    ras = S['RA'].data
    decs = S['DEC'].data
    cmap = 'twilight' # 'Blues' # 'vlag'
    #cmap = sns.color_palette(cmap, as_cmap=True)

    ## Make zero values truly white (cmap.Blue(0) = 0.97,0.98,1.0)
    #cmap = mpl.colormaps.get_cmap(cmap).copy()
    #cmap.set_bad(color='white')
    #cmap.set_under(color='white')
    #cmap.set_over(color='white')

    #nside = 16
    #nest = True
    #
    #bin_area = hp.nside2pixarea(nside, degrees=True)
    #print(bin_area)
    #
    #npix = hp.nside2npix(nside)
    #pixels = hp.ang2pix(nside, np.radians(90 - decs), np.radians(ras), nest=nest)
    #counts = np.bincount(pixels, weights=np.ones_like(ras), minlength=npix)
    #
    #grid_data = counts / bin_area
    #grid_data = prepare_data(grid_data, clip_lo=None, clip_hi=None)
    #
    ##cs = np.random.uniform(size=len(S))
    #sc = ax.scatter(ax.projection_ra(ras), ax.projection_dec(decs), s=1)#, c=cs)
    
    fig = plt.figure(figsize=(10, 7), dpi=300)
    ax = fig.add_subplot(111, projection='mollweide')

    ax = init_sky(galactic_plane_color='k', ecliptic_plane_color='none', ax=ax)

    ax, data = plot_sky_binned(ras, decs, plot_type='healpix', max_bin_area=max_bin_area, 
                               clip_lo=clip_lo, #clip_hi=clip_hi, 
                               verbose=True, ax=ax, 
                               cmap=cmap, return_grid_data=True, colorbar=False)
    import numpy.ma as ma
    print(ma.median(data), ma.mean(data), ma.std(data))

    ax.set_ylabel('Dec (degrees)')
    ax.set_xlabel('RA (degrees)')

    sc = ax.collections[2]
    ar_sky_cbar(ax, sc, r'Galaxy Surface Density (deg$^{-2}$)', extend='both', mloc=mloc)

    # AR DES, galactic, ecliptic plane
    #desfn = os.path.join(os.getenv("DESI_ROOT"), "survey", "observations", "misc", "des_footprint.txt")
    #plot_des(ax, desfn=desfn, c="orange", lw=0.5, alpha=1, zorder=1)
    #plot_gp_ep(ax, "galactic", c="k", lw=1, alpha=1, zorder=1)
    #plot_gp_ep(ax, "barycentricmeanecliptic", c="k", lw=0.25, alpha=1, ls="--", zorder=1)

    ## AR circle
    #custom_plot_sky_circles(ax, 0, 0, 2 * 20, color="g", facecolor="none")
    #custom_plot_sky_circles(ax, 290, 0, 2 * 20, color="b", alpha=0.5)
    
    #ax.set_axisbelow(True)

    fig.subplots_adjust(left=0.1, bottom=0.13, right=0.95, top=0.95)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)
        plt.close(fig)            

def fig_sky2(S, png=None):

    import copy
    from astrometry.util.util import anwcs_create_hammer_aitoff
    from astrometry.util.starutil_numpy import lbtoradec
    import matplotlib.cm as cm
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    sns, _ = plot_style(talk=True, font_scale=0.8)

    print(len(S))

    # initialize the projection
    zoom = 1
    W,H = 800,400
    #W,H = 1000,500
    #W,H = 2000,1000
    ra_center = 120. # 275.
    wcs = anwcs_create_hammer_aitoff(ra_center, 0., zoom, W, H, False)
    ok,S.x,S.y = wcs.radec2pixelxy(S['RA'], S['DEC'])

    sgacount = np.zeros(wcs.shape, np.int16)
    np.add.at(sgacount, (S.y.astype(int), S.x.astype(int)), 1)
    x,y = W//2, H//2
    ok,rr,dd = wcs.pixelxy2radec([x, x+1, x], [y, y, y+1])
    cosdec = np.cos(np.deg2rad(dd[0]))
    dr1 = (rr[1]-rr[0])*cosdec
    dd1 = dd[1]-dd[0]
    dr2 = (rr[2]-rr[0])*cosdec
    dd2 = dd[2]-dd[0]
    pixelarea = np.hypot(dr1,dd1) * np.hypot(dr2,dd2)

    # build the figure
    fig = plt.figure(figsize=(12,8))
    plt.subplots_adjust(left=0.05, right=0.95, bottom=0.08, top=0.95)

    dec_lo = -90
    ra_labels_dec = -12 # -30

    dec_gridlines = list(range(max(dec_lo,-80), 90, 10))
    dec_gridlines_ras = np.arange(ra_center-180, ra_center+180, 1)
    ra_gridlines = range(0, 360, 30)
    #ra_gridlines = range(0, 360, 30)
    ra_gridlines_decs = np.arange(dec_lo, 90, 1.)
    dec_gridlines_slope = []
    for d in dec_gridlines:
        rr = dec_gridlines_ras
        dd = np.zeros_like(rr) + d
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)
        dec_gridlines_slope.append((yy[-2]-yy[-1]) / (xx[-2] - xx[-1]))
    for r in ra_gridlines:
        dd = ra_gridlines_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)

    ra_gridlines2 = [ra_center-180, ra_center+180]
    ra_gridlines2_decs = np.arange(dec_lo, 91, 1.)
    for r in ra_gridlines2:
        dd = ra_gridlines2_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.5)

    ra_labels = ra_gridlines
    dec_labels = dec_gridlines
    dec_labels_ra = ra_center+180

    ok,xx,yy = wcs.radec2pixelxy(ra_labels, ra_labels_dec)
    for x,y,v in zip(xx, yy, ra_labels):
        plt.text(x, y, '%i'%(v%360), ha='center', va='top', alpha=1, fontsize=12)
    ok,xx,yy = wcs.radec2pixelxy(dec_labels_ra, dec_labels)
    for i,(x,y,v,slope) in enumerate(zip(xx, yy, dec_labels, dec_gridlines_slope)):
        dx = -20
        dy = dx * slope
        r = np.hypot(dx,dy)
        dx = dx * 15 / r
        dy = dy * 15 / r
        #print(v, 'dx,dy', dx, dy)
        plt.text(x+dx, y+dy, '%+i'%v, ha='center', va='center', alpha=1, fontsize=12)
        if v == 0:
            plt.text(x+dx*3, y+dy*3, 'Dec (deg)', ha='center', va='center', rotation=90)
        #if v == 50:
        #    #angle = np.rad2deg(np.arctan2(dy, dx))
        #    angle = np.rad2deg(np.arctan2(yy[i+1]-yy[i-1], xx[i+1]-xx[i-1]))
        #    plt.text(x+dx*3, y+dy*3, 'Dec (deg)', ha='center', va='center', rotation=angle)

    # Galactic plane
    if False:
        ll = np.linspace(0., 360., 720)
        bb = np.zeros_like(ll)
        rr,dd = lbtoradec(ll, bb)
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
    
        # Label
        ii = np.argmin(np.abs(rr - ra_center+5))
        angle = 185+np.rad2deg(np.arctan2(yy[ii+1]-yy[ii-1], xx[ii+1]-xx[ii-1]))
        #plt.text(xx[ii], yy[ii], 'Galactic Plane', ha='center', va='bottom', 
        #         rotation=angle)#, weight='bold')
    
        # Plot segments that are above min Dec and not discontinuous
        d = np.append([0], np.hypot(np.diff(xx), np.diff(yy)))
        ok = (d < 100) * (dd > dec_lo)
        istart = 0
        while istart < len(ok):
            while istart < len(ok) and ok[istart] == False:
                istart += 1
            iend = istart
            while iend < len(ok) and ok[iend] == True:
                iend += 1
            if iend != istart:
                #print('Plotting from', istart, 'to', iend, 'ok', ok[istart:iend])
                plt.plot(xx[istart:iend], yy[istart:iend], '-', color='0.6', lw=2)
            istart = iend

    #ok,x,y = wcs.radec2pixelxy(ra_center+8, -45)
    ok,x,y = wcs.radec2pixelxy(ra_center, -25)#-105)
    plt.text(x, y, 'RA (deg)', ha='center')

    plt.xticks([])
    plt.yticks([])
    plt.axis('equal');
    #ax = [0,W, 0.2*H, H]
    #plt.axis(ax)
    #plt.axis('equal')
    #plt.axis(ax)
    plt.gca().set_frame_on(False)

    # colorbar
    # Make zero values truly white (cmap.Blue(0) = 0.97,0.98,1.0)
    mycmap = 'Reds' # 'Blues'
    cmap = copy.copy(mpl.colormaps.get_cmap(mycmap))
    cmap.set_bad(color='white')
    density = (sgacount/pixelarea)
    density[sgacount==0] = np.nan

    im = plt.imshow(density, vmin=0, vmax=40, cmap=mycmap, alpha=0.7, origin='lower', interpolation='nearest');
    ax = plt.gca()

    #cax = plt.axes([0.15, 0.08, 0.7, 0.0805])

    div = make_axes_locatable(ax)
    #cax = div.new_horizontal(size="5%", pad=0.2) # pack_start=True
    cax = div.new_vertical(size="5%", pack_start=True, pad=0.2)
    fig.add_axes(cax)

    c = fig.colorbar(im, cax=cax, orientation='horizontal')
    c.set_label(r'Galaxy Surface Density (deg$^{-2}$)')

    fig.subplots_adjust(left=0.05, bottom=0.1, right=0.95, top=0.98)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)
        plt.close(fig)            

def fig_size_mag(sample, leda=True, png=None):
    """D(25) vs Bt from the parent sample and D(25) histogram. 

    """
    import corner

    sns, colors = plot_style(talk=True, font_scale=1.2)

    if leda:
        good = np.where((sample['D25_LEDA'] > 0) * (sample['MAG_LEDA'] > 0))[0]

        isleda = sample['SGA_ID'][good] < 2000000
        notleda = sample['SGA_ID'][good] >= 2000000

        mag_leda = sample['MAG_LEDA'][good][isleda]
        diam_leda = np.log10(sample['D25_LEDA'][good][isleda]) # [arcmin]

        mag_notleda = sample['MAG_LEDA'][good][notleda]
        diam_notleda = np.log10(sample['D25_LEDA'][good][notleda]) # [arcmin]

        xlabel = r'$b_{t}$ (Vega mag)'
        ylabel = r'$D_{\mathrm{L}}(25)$ (arcmin)'
        #ylabel = r'$D_{i}(25)$ (arcmin)'
    else:
        good = np.where((sample['RADIUS_SB26'] != -1) * (sample['R_MAG_SB26'] != -1))[0]
        mag = sample['R_MAG_SB26'][good]
        diam = np.log10(sample['RADIUS_SB26'][good]/60) # [arcmin]
        xlabel = r'$m_{r}(<R_{26})$ (AB mag)'
        ylabel = r'$R_{26}$ (arcmin)'
    
    xlim, ylim = (20, 7), (-1, 1.6)

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        else:
            return '{:.1f}'.format(10**x)

    fig = plt.figure(figsize=(14, 7))

    # https://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_hist.html
    #fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 7), sharey=True)
    gs = fig.add_gridspec(1, 2,  width_ratios=(2, 1.1), 
                          #left=0.1, right=0.9, bottom=0.1, top=0.9,
                          wspace=0.05)
    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1], sharey=ax1)
           
    corner.hist2d(mag_leda, diam_leda,
                  levels=[0.5, 0.75, 0.95, 0.995],
                  bins=100, smooth=True, color=colors[0], ax=ax1, # mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k'},
                 )
    #ax1.scatter(mag_leda[:2], diam_leda[:2], s=2, color=colors[0], alpha=0.5, # hack
    #            label='HyperLeda')
    ax1.scatter(mag_notleda, diam_notleda, s=2, color=colors[2], alpha=0.5)#
                #label='Supplemental')

    ax1.yaxis.set_major_formatter(major_formatter)
    ax1.set_yticks(np.log10([0.1, 0.2, 0.5, 1, 2, 5, 10, 25, 40]))
    #ax1.legend(loc='upper right', frameon=False)

    ax1.set_xlim(xlim)
    ax1.set_ylim(ylim)
    ax1.set_xlabel(xlabel)
    ax1.set_ylabel(ylabel)

    #big = np.where(sample['RADIUS_SB26'][good]/60 > 2)[0]
    #ingc = np.where(['NGC' in gg or 'UGC' in gg for gg in sample['GALAXY'][big]])[0]
    #ingc = np.where(['NGC' in gg for gg in sample['GALAXY'][good]])[0]
    #ax.scatter(rmag[ingc], radius[ingc], marker='s', edgecolors='k',
    #           s=10, alpha=1.0, lw=1, color='k')

    ax2.hist(diam_leda, orientation='horizontal', range=ylim, bins=75, 
             color=colors[0], label='HyperLeda')
    ax2.hist(diam_notleda, orientation='horizontal', range=ylim, bins=75, 
             color=colors[2], alpha=0.7, label='Supplemental')
    #ax1.axhline(y=np.log10(20/60), lw=2, ls='-', color='k')
    #ax2.axhline(y=np.log10(20/60), lw=2, ls='-', color='k', label=r'$D_{\mathrm{L}}(25)=20$ arcsec')
    ax2.set_xscale('log')
    ax2.set_xlabel('Number of Galaxies')
    #ax2.spines[['right', 'top']].set_visible(False)
    ax2.tick_params(axis='y', labelleft=False)
    ax2_twin = ax2.twinx()

    ax2_twin.yaxis.set_major_formatter(major_formatter)
    ax2_twin.set_yticks(np.log10([0.1, 0.2, 0.5, 1, 2, 5, 10, 25, 40]))
    #ax2_twin.set_xscale('log')
    ax2_twin.set_ylim(ylim)
    ax2_twin.set_ylabel(ylabel, rotation=270, labelpad=25)

    ax2.legend(loc='upper right', fontsize=14) # frameon=False, 
    #hh, ll = ax2.get_legend_handles_labels()
    #ax2.legend([hh[0], hh[1], hh[2]], [ll[0], ll[1], ll[2]], 
    #           loc='upper right', fontsize=14) # frameon=False, 

    fig.subplots_adjust(bottom=0.18, top=0.95, right=0.9, left=0.1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sga_properties(sga, png=None):
    """Corner plot of various properties

    """
    import corner as cn
    from matplotlib.ticker import MaxNLocator, AutoLocator

    sns, colors = plot_style(talk=True, font_scale=0.8)

    I = (sga['R_MAG_SB26'] > 0) * (sga['SMA_SB26'] > 0) #* (sga['D26'] > 0)
    print('Number of galaxies = {}/{}'.format(np.sum(I), len(sga)))
    _sga = sga[I]
    _sga['SB26'] = _sga['R_MAG_SB26'] + 2.5 * np.log10(np.pi * _sga['SMA_SB26']**2)
    #_sga['SB26'] = _sga['R_MAG_SB26'] + 2.5 * np.log10(np.pi * _sga['SMA_SB26']**2 * _sga['BA'])
    #_sga['SB26'] = _sga['R_MAG_SB26'] + 2.5 * np.log10(2 * np.pi * _sga['SMA_SB26']**2)
    #_sga['LOGR50'] = np.log10(_sga['R_SMA50'])
    _sga['LOGR26'] = np.log10(_sga['SMA_SB26']/60) # [arcmin]
    #_sga['LOGD26'] = np.log10(_sga['D26'])
    _sga['EPS'] = 1-_sga['BA']
    Xdata = _sga['R_MAG_SB26', 'LOGR26', 'SB26', 'PA', 'EPS'].to_pandas().values
    lims = [(21, 7), (-1.2, 1.0), (27, 20), (-10, 190), (-0.1, 1)]
    #print(lims)

    labels = (r'$r_{R(26)}$'+'\n(mag)', 
              r'$R(26)$'+'\n(arcmin)',
              r'$\langle\, \mu_{r,R(26)}\,\rangle$'+'\n(mag arcsec'+r'$^{-2}$)',
              #r'$D(\mu_{r}=26)$', 
              r'$\phi$'+'\n(degree)', 
              r'$\epsilon$')

    max_n_ticks = 4

    fig = cn.corner(Xdata, labels=labels, fill_contours=True, range=lims, 
                    labelpad=0.08, max_n_ticks=max_n_ticks,
                    smooth=0.8, top_ticks=True,
                    plot_density=True, levels=[0.5, 0.75, 0.95, 0.995],
                    contour_kwargs={'colors': 'k'},
                    #label_kwargs={'fontsize': 14}, 
                    show_titles=False,
                    #title_kwargs={'fontsize': 12},
                    hist_kwargs={'color': 'k', 'lw': 2},
                    color=colors[0], quiet=True)#, hist2d_kwargs={'quiet': True},)

    #fig.axes[0].yaxis.set_major_locator(AutoLocator())
    #fig.axes[0].set_yticklabels([100, 1000, 5000])
    #fig.axes[0].set_ylabel('Number of Galaxies')

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        else:
            return '{:.1f}'.format(10**x)

    for ii in range(len(labels)):
        ax = fig.axes[ii+ii*5]
        xx = ax.twiny()
        xx.set_xlim(lims[ii])
        xx.set_xlabel(labels[ii])
        xx.xaxis.set_major_locator(MaxNLocator(max_n_ticks, prune='lower'))
        [l.set_rotation(45) for l in xx.get_xticklabels()]
        [l.set_rotation(45) for l in xx.get_xticklabels(minor=True)]
        if ii == 1:
            xx.xaxis.set_major_formatter(major_formatter)
            xx.set_xticks(np.log10([0.2, 1, 4]))

    fig.axes[5].yaxis.set_major_formatter(major_formatter)
    fig.axes[5].set_yticks(np.log10([0.2, 1, 4]))

    fig.axes[21].xaxis.set_major_formatter(major_formatter)
    fig.axes[21].set_xticks(np.log10([0.2, 1, 4]))

    fig.subplots_adjust(bottom=0.15, top=0.9, right=0.95, left=0.12)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_redshifts(sga, png=None, png_sky=None, png_zhist=None):
    """DESI redshifts.

    To build the sga-bgspv-targets.fits catalog, run (on Perlmutter) with the
    DESI software stack:

      python sga-bgspv-targets.py

    """
    from matplotlib import gridspec
    import astropy.units as u
    from astropy.coordinates import SkyCoord
    from desiutil.plots import init_sky, prepare_data#, plot_sky_binned

    font = {'size': 14,} #'family': 'normal', 'weight': 'bold'}
    mpl.rc('font', **font)
    #sns, colors = plot_style(talk=True, font_scale=1.0)

    targfile = os.path.join(paperdir, 'data', 'sga-bgspv-targets.fits')
    targ = Table(fitsio.read(targfile))
    print('Read {:,d} targets from {}'.format(len(targ), targfile))

    zcatfile = os.path.join(paperdir, 'data', 'zall-pix-fuji.fits')
    zcols = ['TARGET_RA', 'TARGET_DEC', 'Z', 'ZWARN', 'ZCAT_PRIMARY']
    zcat = Table(fitsio.read(zcatfile, columns=zcols))
    zcat = zcat[zcat['ZCAT_PRIMARY'] * (zcat['ZWARN'] == 0)]
    print('Read {:,d} primary/good redshifts from {}'.format(len(zcat), zcatfile))

    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_zcat = SkyCoord(ra=zcat['TARGET_RA']*u.deg, dec=zcat['TARGET_DEC']*u.deg)

    rad = 1.0 * u.arcsec
    indx_zcat, indx_sga, d2d, _ = c_sga.search_around_sky(c_zcat, rad)
    print('Found {:,d}/{:,d} DESI-SGA matches within {}.'.format(len(indx_sga), len(sga), rad))

    PV = targ['TARG'] == 'PV'
    BGS = targ['TARG'] == 'BGS'
    BGSPV = targ['TARG'] == 'BGS-PV'
    ISGA = (targ['REF_CAT'] == 'L3') * np.logical_not(BGS)
    sgadesi = sga[np.isin(sga['SGA_ID'], targ['REF_ID'][ISGA])]

    #plt.clf()
    #plt.scatter(sga['RA'], sga['DEC'], s=1)
    #plt.scatter(sgadesi['RA'], sgadesi['DEC'], s=1)
    #plt.savefig('junk.png')

    # Panel (a)
    cmin, cmax = -1, 1.5

    if False:
        fig = plt.figure(figsize=(10, 6))
        ax1 = fig.add_subplot(111, projection='mollweide')
        #fig, (ax1, _) = plt.subplots(1, 2, figsize=(12, 7))
    else:
        fig = plt.figure(figsize=(14, 7))
        gs = gridspec.GridSpec(3, 2, width_ratios=[3, 2], height_ratios=[1, 0.2, 0.2])
        ax1 = plt.subplot(gs[0:1, 0], projection='mollweide')

    from matplotlib.axis import Tick
    Tick.set_zorder(ax1, 10) 

    ax1 = init_sky(ax=ax1, galactic_plane_color='k', ecliptic_plane_color='none')
    #xticks = ax1.get_xticklabels()
    #ax1.set_xticklabels([])
    ax1.scatter(ax1.projection_ra(sga['RA']), ax1.projection_dec(sga['DEC']), s=10, color='gray')#,
                #label='SGA-2020')
    ax1, data = plot_sky_binned(sgadesi['RA'], sgadesi['DEC'], plot_type='healpix', max_bin_area=10, 
                                clip_lo=0, #clip_hi=50,
                                return_grid_data=True, cmap='twilight', 
                                verbose=True, ax=ax1, colorbar=False)

    ar_sky_cbar(ax1, ax1.collections[3], r'Galaxy Surface Density (deg$^{-2}$)', 
                extend='both', mloc=20)

    #ax1.set_xticklabels(['1', '2', '1', '1', '1', '1', '1', '1', '1', '1', '1'])
    #pdb.set_trace()

    #SC = ax1.scatter(ax1.projection_ra(sgadesi['RA']), ax1.projection_dec(sgadesi['DEC']), 
    #                 c=np.log10(sgadesi['D26']))

    #if False:
    #    p = ax1.get_position().get_points().flatten()
    #    cax = fig.add_axes([p[0]+0.2*(p[2]-p[0]),p[1]+0.2*(p[3]-p[1]),0.3*(p[2]-p[0]),0.025])
    #
    #    cbarticks = np.linspace(cmin, cmax, 5)
    #    cbar_ylab = ['%.1f' % x for x in cbarticks]
    #    print(cbar_ylab)
    #
    #    cbar = plt.colorbar(SC, cax=cax, orientation='horizontal', ticklocation='bottom', extend='both', ticks=cbarticks)
    #    cbar.set_label(r'Size', fontsize=20)
    #    #cbar.ax.set_yticklabels(cbar_ylab)
    
    #tick_labels = np.array([150, 120, 90, 60, 30, 0, 330, 300, 270, 240, 210])
    #tick_labels = np.remainder(tick_labels+360+120, 360)
    #ax1.set_xticklabels(tick_labels)     # we add the scale on the x axis
    ax1.set_xlabel('RA (degrees)')#, fontsize=25)
    ax1.set_ylabel('Dec (degrees)')#, fontsize=25)    

    #ax1.scatter(sga['RA'], sga['DEC'], s=1)
    #ax1.scatter(sgadesi['RA'], sgadesi['DEC'], s=1)

    #fig.subplots_adjust(left=0.1, bottom=0.15, right=0.95, top=0.95)
    #
    #if png_sky:
    #    pngfile = os.path.join(figdir, png_sky)
    #    print('Writing {}'.format(pngfile))
    #    fig.savefig(pngfile)#, bbox_inches='tight', pad_inches=0.3)
    #    plt.close(fig)

    #return

    # Panel (b)
    sns, colors = plot_style(talk=True, font_scale=0.8)

    zmin1 = 0.0
    zmax1 = 0.5 # 2.0 # 4.5
    bins = 75

    I = sga['Z_LEDA'] > -1

    if False:
        fig, ax2 = plt.subplots(figsize=(6, 4))
        #ax2 = fig.add_axes([1.1, 0.1, 0.5, 1.0])
    else:
        ax2 = plt.subplot(gs[0:1, 1])

    ax2.hist(sga['Z_LEDA'][I], bins=bins, range=(zmin1, zmax1), color=colors[0], 
             label='HyperLeda (N={:,d})'.format(np.sum(I)))
    ax2.hist(zcat['Z'][indx_zcat], bins=bins, range=(zmin1, zmax1), color=colors[1], #colors[2], 
             alpha=0.7, label='DESI -- EDR (N={:,d})'.format(len(indx_zcat)))
    ax2.set_xlabel('Heliocentric Redshift')
    ax2.set_yscale('log')
    ax2.set_yticks([])
    #ax2.set_ylabel('Number of Galaxies')
    ax2.set_xlim(zmin1, zmax1)
    ax2.set_ylim(1, 2e5)
    ax2.margins(x=0)

    from matplotlib.patches import Patch
    P = Patch(alpha=0, color='white')
    hh, ll = ax2.get_legend_handles_labels()
    ax2.legend([hh[0], hh[1], P], 
               [ll[0], ll[1], 'DESI -- Year 5 (N={:,d})'.format(len(sgadesi))], 
               #[ll[0], ll[1], r'DESI -- Year 5 (N$\approx300,000$'],
               alignment='left', loc='upper right', fontsize=11) # frameon=False, 
    #ax2.legend(loc='upper right', fontsize=10)

    ax2_twin = ax2.twinx()
    ax2_twin.set_ylabel('Number of Galaxies', rotation=270, labelpad=20)
    ax2_twin.set_ylim(1, 2e5)
    ax2_twin.set_yscale('log')

    # inset
    if False:
        #M = (zcat['Z'][indx_zcat] > 0) * (sga['Z_LEDA'][indx_sga] > 0)
        M = sga['Z_LEDA'][indx_sga] > -1
        sns, _ = plot_style(talk=True, font_scale=0.5)
    
        ax2_inset = fig.add_axes([0.66, 0.6, 0.25, 0.27])
        ax2_inset.scatter(zcat['Z'][indx_zcat][M], sga['Z_LEDA'][indx_sga][M], s=1,
                          color=colors[0], marker='s', zorder=1, alpha=0.75)
        ax2_inset.plot([zmin1, zmax1], [zmin1, zmax1], lw=1, color='k', zorder=0)
        ax2_inset.set_xlabel('Redshift [DESI]')
        ax2_inset.set_ylabel('Redshift [HyperLeda]')
        ax2_inset.set_xlim(zmin1, zmax1) 
        ax2_inset.set_ylim(zmin1, zmax1)

    #fig.subplots_adjust(left=0.05, bottom=0.15, right=0.8, top=0.95)
    #if png_zhist:
    #    pngfile = os.path.join(figdir, png_zhist)
    #    print('Writing {}'.format(pngfile))
    #    fig.savefig(pngfile)#, bbox_inches='tight', pad_inches=0.3)
    #    plt.close(fig)

    fig.subplots_adjust(wspace=0.05)
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile, bbox_inches='tight', pad_inches=0.3)
        plt.close(fig)


def fig_coordinates(sga, png=None):
    """SGA vs HyperLeda coordinate comparisons.

    """
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    import astropy.units as u
    from astropy.coordinates import SkyCoord
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.0)

    montagedir = os.path.join(paperdir, 'data', 'montage-coordinates')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 0.262
    barlen = np.ceil(30 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 5
    nrow = 4
    ngal = ncol * nrow

    # https://cdsarc.u-strasbg.fr/ftp/cats/VII/155/mtypes.tex
    # E      & E    & -5  \\
    # E-S0   & L-:  & -3: \\
    # S0     & L    & -2  \\
    # IrrII  & I0   &  0: \\
    # S0/a   & S0/a &  0  \\
    # Sa     & Sa   &  1  \\
    # Sa-b   & Sab  &  2  \\
    # Sb     & Sb   &  3  \\
    # Sb-c   & Sbc  &  4  \\
    # Sc     & Scd: &  6: \\
    # Sc-Irr & Sdm: &  8: \\
    # IrrI   & Im   & 10  \\
    # S...       & S.      & 3? \\
    # S``early'' & S.(Sa?) & 1? \\
    # S``late''  & S.Sc?   & 5? \\

    morph = sga['MORPHTYPE'].data
    morph = np.char.replace(morph, 'SB', 'S')
    morph = np.char.replace(morph, 'SAB', 'S')
    umorph = set(morph)

    morphkey = {
        '0':        -10, # from openNGC; high surface-brightness
        '.LXS-*.':  -10, # NGC1382, early-type
        'S0':       -10,
        'E':         -4,
        'E?':        -4, # ??
        '.L?....':   -4, # ESO248-6
        '.E+..?.':   -4, # MCG-1-25-6
        '.E+4...':   -4, # ??
        '.E+..P*':   -4, # ??
        '.E...P*':   -4, # ??
        'E-S0':      -3, 
        'S0-a':       0, 
        'Sa':         1,
        'Sab':        2, 
        'Sb':         3,
        '.S..7..':    3, # UGC3694, mid-type
        '.SAR4..':    3, # ESO192-11
        '.SAR5P.':    3, # ESO079-13
        'Sbc':        4, 
        'S?':         5, # ??
        '.S?...':     5, # ??
        '.S?....':    5, # ??
        '.SAS5..':    5, # NGC6050
        'Sc':         6, 
        'Scd':        6, 
        'Sd':         7, 
        '.S.5?P':     7, # ESO159-16, late-type
        '.S.3..':     7, # NGC4858
        'Sm':         8, 
        'I':         10, 
        'IAB':       10, 
        'IB':        10,
        'dSph?':     10, 
        'dIrr':      10, 
        'Irr':       10, 
        '.S..8..':   10, # UGC4258
        '.S..6*.':   10, # UGC5482
        '.I..9P.':   10, # MCG-1-3-72
        '.IBS9..':   99, # ESO298-39, ESO288-40, late-type
        'DLX.0..':   99, # ESO302-15, dwarf
        'COMP':      99, # DR8, ignore
        'EXP':       99, # DR8, ignore
        'DEV':       99, # DR8, ignore
        'DUP':       99, # DR8, ignore
        'REX':       99, # DR8, ignore
        'PSF':       99, # DR8, ignore
        '':          99, # tend to be late-type dwarfs, ignore
        ' ':         99, # tend to be late-type dwarfs, ignore
        'dIrr/dSph': 99, 
        'dSph':      99, 
        'DE.1.P*':   99, # ESO201-10; globular?
        '.L..+P*':   99, # NGC7592 - missing companion/merger
    }

    sga['MORPH'] = np.zeros(len(sga), int)
    for thismorph in umorph:
        I = thismorph == morph
        sga['MORPH'][I] = morphkey[thismorph]

    c_leda = SkyCoord(sga['RA_LEDA']*u.deg, sga['DEC_LEDA']*u.deg)
    c_sga = SkyCoord(sga['RA']*u.deg, sga['DEC']*u.deg)
    _, sep2d, _ = c_leda.match_to_catalog_sky(c_sga)
    print('Mean, min, max delta-theta between SGA and HyperLeda coordinates={:.4f}, {:.4f}, {:.4f} arcsec.'.format(
        np.mean(sep2d.arcsec), np.min(sep2d.arcsec), np.max(sep2d.arcsec)))

    sga['SEP'] = sep2d.arcsec

    print('Galaxies where the coordinates differ by >3 arcsec:')
    I = (sep2d.arcsec > 3) * (sga['D25_LEDA'] > 1) * (sga['D26'] < 14) * (sga['D26_REF'] == 'SB26') * (sga['MORPH'] < 7) #* (sga['DEC'] < 50)
    samp = sga[I]
    samp = samp[np.argsort(samp['D26'])]
    print(len(samp))
    #print(samp['GALAXY', 'RA', 'DEC', 'RA_LEDA', 'DEC_LEDA', 'D25_LEDA', 'D26', 'D26_REF', 'MORPH', 'SEP'])

    if True:
        these = np.where(np.isin(samp['GALAXY'], 
                                 ['PGC132073', 'PGC039869', 'ESO192-11',
                                  'ESO302-012', 'PGC132135', 'NGC1382', 
                                  'PGC039869', 'ESO293-034', 'NGC1511', 'ESO234-042',
                                  'PGC009803', 'UGC11287', 'NGC4636',
                                  'PGC070657', 'NGC1705', 'NGC4020',
                                  'NGC4948', 'NGC4607', 'IC4213',
                                  'NGC6140', 
                                  #'NGC3190', 
                                  'NGC3521', 
                                  #'NGC2403', 
                                  #'NGC0247'
                                  ]))[0]
        samp = samp[these]
    else:
        rand = np.random.RandomState(seed=1)
        these = rand.choice(len(samp), ngal-3, replace=False)
        these = np.hstack((these, 
                           np.where(samp['GALAXY'] == 'NGC2403')[0], 
                           np.where(samp['GALAXY'] == 'ESO192-11')[0],
                           np.where(samp['GALAXY'] == 'PGC039869')[0],
                           ))
        samp = samp[these]
        samp[samp['GALAXY'] == 'PGC009037'] = sga[sga['GALAXY'] == 'NGC0247']
        samp[samp['GALAXY'] == 'PGC025426'] = sga[sga['GALAXY'] == 'ESO293-034']
        samp[samp['GALAXY'] == 'NGC4217'] = sga[sga['GALAXY'] == 'NGC1511']

    samp = samp[np.argsort(samp['D26'])]
    print(samp['GALAXY', 'RA', 'DEC', 'RA_LEDA', 'DEC_LEDA', 'D25_LEDA', 'D26', 'D26_REF', 'MORPH', 'SEP'])

    pngfiles = []
    for onegal  in samp:
        jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['GALAXY']))
        width = int(1.3 * onegal['D26'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['RA'], onegal['DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        rad = 5
        if width < 500:
            lw = 2
        elif width > 2000:
            lw = 7
        else:
            lw = 2

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size

                hdr = fits.Header()
                hdr['NAXIS'] = 2
                hdr['NAXIS1'] = imgsz[0]
                hdr['NAXIS2'] = imgsz[0]
                hdr['CTYPE1'] = 'RA---TAN'
                hdr['CTYPE2'] = 'DEC--TAN'
                hdr['CRVAL1'] = onegal['RA']
                hdr['CRVAL2'] = onegal['DEC']
                hdr['CRPIX1'] = imgsz[0]/2+0.5
                hdr['CRPIX2'] = imgsz[0]/2+0.5
                hdr['CD1_1'] = -pixscale/3600
                hdr['CD1_2'] = 0.0
                hdr['CD2_1'] = 0.0
                hdr['CD2_2'] = +pixscale/3600
                wcs = WCS(hdr)
        
                #draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                #                    onegal['PA'], onegal['D26'] * 60.0, pixscale, color='red')

                onesga = sga[sga['GROUP_NAME'] == onegal['GROUP_NAME']]
                for onesga1 in onesga:
                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA_LEDA'], onesga1['DEC_LEDA'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA_LEDA'], 
                                        onesga1['PA_LEDA'], onesga1['D25_LEDA'] * 60.0, pixscale, 
                                        color='tomato', linewidth=lw)
                    draw = ImageDraw.Draw(colorimg)
                    #draw.rectangle([xpos-rad, imgsz[1]-ypos-rad, xpos+rad, imgsz[1]-ypos+rad], outline='tomato')

                    semimajor = 0.5 * onesga1['D25_LEDA'] * 60 / pixscale # [pixels]
                    semiminor = onesga1['BA_LEDA'] * semimajor            # [pixels]
                    theta = np.radians(onesga1['PA_LEDA'])
                    xymajor = [xpos-semimajor*np.sin(theta), imgsz[1]-(ypos+semimajor*np.cos(theta)),
                               xpos+semimajor*np.sin(theta), imgsz[1]-(ypos-semimajor*np.cos(theta))]
                    xyminor = [xpos-semiminor*np.cos(theta), imgsz[1]-(ypos-semiminor*np.sin(theta)),
                               xpos+semiminor*np.cos(theta), imgsz[1]-(ypos+semiminor*np.sin(theta))]
                    draw.line(xymajor, fill='tomato', width=lw)
                    draw.line(xyminor, fill='tomato', width=lw)

                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                        color='dodgerblue', linewidth=lw)
                    #draw.ellipse([xpos-rad, imgsz[1]-ypos-rad, xpos+rad, imgsz[1]-ypos+rad], fill='dodgerblue')

                    semimajor = 0.5 * onesga1['D26'] * 60 / pixscale # [pixels]
                    semiminor = onesga1['BA'] * semimajor            # [pixels]
                    theta = np.radians(onesga1['PA'])
                    xymajor = [xpos-semimajor*np.sin(theta), imgsz[1]-(ypos+semimajor*np.cos(theta)),
                               xpos+semimajor*np.sin(theta), imgsz[1]-(ypos-semimajor*np.cos(theta))]
                    xyminor = [xpos-semiminor*np.cos(theta), imgsz[1]-(ypos-semiminor*np.sin(theta)),
                               xpos+semiminor*np.cos(theta), imgsz[1]-(ypos+semiminor*np.sin(theta))]
                    draw.line(xymajor, fill='dodgerblue', width=lw)
                    draw.line(xyminor, fill='dodgerblue', width=lw)

                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            label = onegal['GALAXY']
            #label = r'{} ($\Delta\theta={:.1f}"$)'.format(onegal['GALAXY'], onegal['SEP'])
            addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        
    
def fig_sga_vs_hyperleda(sga, png=None):
    """SGA improvements vs HyperLeda.

    """
    import corner as cn
    import astropy.units as u
    from astropy.coordinates import SkyCoord

    sns, colors = plot_style(talk=True, font_scale=1.1)

    I = (sga['D26_REF'] != 'LEDA') * (sga['SMA_SB25'] > 0)
    sga = sga[I]

    xpos, ypos = 0.06, 0.9

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        else:
            return '{:.1f}'.format(10**x)

    fig, ax = plt.subplots(2, 2, figsize=(12, 12))

    # coordinatess
    xylim = 20 * np.array([-1, 1])
    dra = np.cos(np.radians(sga['DEC'])) * (sga['RA'] - sga['RA_LEDA'])*3600
    ddec = (sga['DEC'] - sga['DEC_LEDA'])*3600

    c_leda = SkyCoord(sga['RA_LEDA']*u.deg, sga['DEC_LEDA']*u.deg)
    c_sga = SkyCoord(sga['RA']*u.deg, sga['DEC']*u.deg)
    _, sep2d, _ = c_leda.match_to_catalog_sky(c_sga)
    print('Median, mean+/-sigma, min, max delta-theta [SGA-Leda]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} arcsec.'.format(
        np.median(sep2d.arcsec), np.mean(sep2d.arcsec), np.std(sep2d.arcsec), np.min(sep2d.arcsec), 
        np.max(sep2d.arcsec)))

    cn.hist2d(dra, ddec, 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[0, 0], smooth=0.8,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    ax[0, 0].axhline(y=0, color=colors[3], lw=2, alpha=0.9)
    ax[0, 0].axvline(x=0, color=colors[3], lw=2, alpha=0.9)
    ax[0, 0].xaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].yaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].set_xlabel(r'$\Delta\,\mathrm{RA}$ (J2000, arcsec)')
    ax[0, 0].set_ylabel(r'$\Delta\,\mathrm{Dec}$ (J2000, arcsec)')
    ax[0, 0].text(xpos, ypos, '(a)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[0, 0].transAxes, alpha=1.0)

    # diameters
    xylim = [-0.9, 1.6]
    dsga = np.log10(2*sga['SMA_SB25']/60)
    dleda = np.log10(sga['D25_LEDA'])
    deltad = dsga - dleda
    print('Median, mean+/-sigma, min, max delta-D(25) [SGA-Leda]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} arcmin.'.format(
        np.median(deltad), np.mean(deltad), np.std(deltad), np.min(deltad), np.max(deltad)))

    cn.hist2d(dsga, dleda, 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[0, 1], smooth=0.8,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},#, 'mec': 'gray'},
              contour_kwargs={'colors': 'k'})
    ax[0, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.9)
    #ax[0, 1].plot(xylim, xylim-np.median(deltad), color=colors[3], lw=2, ls='--', alpha=0.9)
    ax[0, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax[0, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax[0, 1].set_xlabel(r'$D(25)$ (SGA, arcmin)')
    ax[0, 1].set_ylabel(r'$D_{\mathrm{L}}(25)$ (HyperLeda, arcmin)')
    ax[0, 1].xaxis.set_major_formatter(major_formatter)
    ax[0, 1].yaxis.set_major_formatter(major_formatter)
    ax[0, 1].set_xticks(np.log10([0.3, 1, 3, 10, 30]))
    ax[0, 1].set_yticks(np.log10([0.3, 1, 3, 10, 30]))
    ax[0, 1].text(xpos, ypos, '(b)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[0, 1].transAxes, alpha=1.0)

    # PA
    pasga, paleda = sga['PA'], sga['PA_LEDA']
    deltapa = pasga - paleda
    print('Median, mean+/-sigma, min, max delta-PA [SGA-Leda]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} degree.'.format(
        np.median(deltapa), np.mean(deltapa), np.std(deltapa), np.min(deltapa), np.max(deltapa)))

    xylim = [-10, 190]
    cn.hist2d(pasga, paleda, 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[1, 0], smooth=0.8,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    #ax[0, 1].scatter(sga['PA'], sga['PA_LEDA'], s=1)
    ax[1, 0].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.9)
    ax[1, 0].xaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].yaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].set_xlabel(r'$\phi$ (SGA, degree)')
    ax[1, 0].set_ylabel(r'$\phi$ (HyperLeda, degree)')
    ax[1, 0].text(xpos, ypos, '(c)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[1, 0].transAxes, alpha=1.0)

    # ellipticity
    esga, eleda = 1-sga['BA'], 1-sga['BA_LEDA']
    deltae = esga - eleda
    print('Median, mean+/-sigma, min, max delta-epsilon [SGA-Leda]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f}.'.format(
        np.median(deltae), np.mean(deltae), np.std(deltae), np.min(deltae), np.max(deltae)))

    xylim = [-0.1, 1.0]
    cn.hist2d(esga, eleda,
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[1, 1], smooth=0.8,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    #ax[1, 0].scatter(1-sga['BA'], 1-sga['BA_LEDA'], s=1)
    ax[1, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.9)
    ax[1, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].set_xlabel(r'$\epsilon$ (SGA)')
    ax[1, 1].set_ylabel(r'$\epsilon$ (HyperLeda)')
    ax[1, 1].text(xpos, ypos, '(d)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[1, 1].transAxes, alpha=1.0)

    fig.subplots_adjust(left=0.11, bottom=0.09, right=0.95, top=0.95, hspace=0.2, wspace=0.3)

    #pdb.set_trace()

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)
    
def fig_sga_vs_wxsc100(sga, png=None):
    """Comparison with WXSC largest 100 galaxies.

    """
    import pandas as pd
    import astropy.units as u
    from astropy.coordinates import SkyCoord
    import matplotlib as mpl

    sns, colors = plot_style(talk=True, font_scale=1.1)

    wxscfile = os.path.join(paperdir, 'data', 'wxsc100', 'Table_1.tbl')
    names = ['wxsc_id', 'galaxy', 'ra', 'dec', 'ba', 'pa', 
             'W1_radius', 'W1_mag', 'W1_mag_err',
             'W2_radius', 'W2_mag', 'W2_mag_err',
             'W3_radius', 'W3_mag', 'W3_mag_err',
             'W4_radius', 'W4_mag', 'W4_mag_err',
             'W1_W2', 'W1_W2_err', 'W2_W3', 'W2_W3_err']
    dtype = {'wxsc_id': str, 'galaxy': str, 'ra': np.float64, 'dec': np.float64, 
             'ba': np.float32, 'pa': np.float32, 
             'W1_radius': str, 'W1_mag': str, 'W1_mag_err': str,
             'W2_radius': str, 'W2_mag': str, 'W2_mag_err': str,
             'W3_radius': str, 'W3_mag': str, 'W3_mag_err': str,
             'W4_radius': str, 'W4_mag': str, 'W4_mag_err': str,
             'W1_W2': str, 'W1_W2_err': str, 'W2_W3': str, 'W2_W3_err': str}
    wxsc = pd.read_csv(wxscfile, delimiter='|', comment='#', na_values='null', skiprows=0, 
                       names=names, dtype=dtype, skip_blank_lines=True)#,
                       #warn_bad_lines=True, error_bad_lines=False)

    tab3 = Table.read(os.path.join(paperdir, 'data', 'wxsc100', 'Table_3_nonull.tbl'), format='ipac')

    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_wxsc = SkyCoord(ra=wxsc['ra'].values*u.deg, dec=wxsc['dec'].values*u.deg)

    rad = 10.0 * u.arcsec
    indx_wxsc, indx_sga, d2d, _ = c_sga.search_around_sky(c_wxsc, rad)
    print('Found {:,d}/{:,d} SGA-WXSC matches within {} arcsec.'.format(len(indx_wxsc), len(wxsc), rad))
    
    mwxsc = wxsc.iloc[indx_wxsc]
    msga = sga[indx_sga]
    msga['HUBBLE'] = tab3['Morph'][indx_wxsc]

    morphkey = {
        'E': -5,
        'E1pec': -5,
        'dE': -5,
        'E-S0': -3,
        'S0': -2,
        'dS0': -2,
        'S0/a': 0,
        'S0-a': 0,
        'Sa': 1,
        'SABa': 1,
        'Sab': 2,
        'Sa-b': 2,
        'Sb': 3,
        'SABb': 3,
        'SBb': 3,
        'Sbc': 4,
        'Sb-c': 4,
        'Sc': 5,
        'SABc': 5,
        'Scd': 6,
        'SBcd': 6,
        'Sc-d': 6,
        'Sd': 7,
        'Sdm': 8,
        'Sd-m' : 8,
        'S?' : 8,
        'Sm': 9,
        'SBm': 9,
        'Irr': 9,
        'Ir' : 9,
        'IB' : 9,
        'dsph': -5,
        'Sph': -5,
        'dIr': 9,
        'dIrr': 9,
        'dS0': -2,
        'dS0/a': 0,
        'dS0-a': 0,
        'dSa': 1,
        'dSab': 2,
        'dSa-b': 2,
        'dSb': 3,
        'dSbc': 4,
        'dSb-c': 4,
        'dSc': 5,
        'dScd': 6,
        'dSc-d': 6,
        'dSd': 7,
        'Sc-Irr': 8,}

    msga['HUBBLET'] = np.zeros(len(msga), int)
    for thismorph in set(msga['HUBBLE']):
        if thismorph == 'ZZZ': # NGC4217
            thismorph = 'Sb'
        I = np.where(thismorph == msga['HUBBLE'])[0]
        if thismorph in morphkey.keys():
            msga['HUBBLET'][I] = morphkey[thismorph]
        else:
            print(f'Missing {thismorph}')

    ms = 80
    col = colors[0]
    marker = 'o'
    xpos, ypos = 0.06, 0.88

    # discrete colorbar
    # https://stackoverflow.com/questions/14777066/matplotlib-discrete-colorbar
    cmap = plt.cm.jet  # define the colormap
    cmaplist = [cmap(i) for i in range(cmap.N)]
    
    # create the new map
    cmap = mpl.colors.LinearSegmentedColormap.from_list(
        'custom', cmaplist, cmap.N)
    
    bounds = np.arange(np.min(msga['HUBBLET']), np.max(msga['HUBBLET'])+1, 1)
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        else:
            return '{:.1f}'.format(10**x)

    fig, ax = plt.subplots(2, 2, figsize=(13, 10))

    xylim = 20 * np.array([-1, 1])
    dra = np.cos(np.radians(msga['DEC'])) * 3600*(msga['RA']-mwxsc['ra'].values)
    ddec = 3600*(msga['DEC']-mwxsc['dec'].values)

    c_wxsc = SkyCoord(mwxsc['ra'].values*u.deg, mwxsc['dec'].values*u.deg)
    c_sga = SkyCoord(msga['RA']*u.deg, msga['DEC']*u.deg)
    _, sep2d, _ = c_wxsc.match_to_catalog_sky(c_sga)
    print('Median, mean+/-sigma, min, max delta-theta [SGA-Wxsc]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} arcsec.'.format(
        np.median(sep2d.arcsec), np.mean(sep2d.arcsec), np.std(sep2d.arcsec), np.min(sep2d.arcsec), 
        np.max(sep2d.arcsec)))

    srt = np.argsort(sep2d.arcsec)[::-1]
    info = msga['GALAXY', 'RA', 'DEC'][srt]
    info['RA_WXSC'] = mwxsc['ra'].values[srt]
    info['DEC_WXSC'] = mwxsc['dec'].values[srt]
    info['SEP2D'] = sep2d.arcsec[srt]
    print(info[:10])

    I = np.where(np.logical_or(np.abs(dra) > 8, np.abs(ddec) > 8))[0]
    for ii in I:
        pass
        print(msga[ii]['GALAXY'], msga[ii]['RA'], msga[ii]['DEC'], 
              mwxsc.iloc[ii]['ra'], mwxsc.iloc[ii]['dec'], dra[ii], ddec[ii])
    #pdb.set_trace()

    ax[0, 0].scatter(dra, ddec, s=ms, marker=marker, c=msga['HUBBLET'], 
                     cmap=cmap, norm=norm, alpha=0.9, edgecolor='k')
    ax[0, 0].set_xlim(xylim)
    ax[0, 0].set_ylim(xylim)
    ax[0, 0].axhline(y=0, color='k', lw=2, alpha=0.7)
    ax[0, 0].axvline(x=0, color='k', lw=2, alpha=0.7)
    ax[0, 0].set_xlabel(r'$\Delta\,\mathrm{RA}$ (J2000, arcsec)')
    ax[0, 0].set_ylabel(r'$\Delta\,\mathrm{Dec}$ (J2000, arcsec)')
    ax[0, 0].xaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].yaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].text(xpos, ypos, '(a)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[0, 0].transAxes, alpha=1.0)

    cbax = fig.add_axes([0.9, 0.1, 0.03, 0.8])
    mpl.colorbar.ColorbarBase(cbax, cmap=cmap, norm=norm, label='Hubble Type',
                              spacing='proportional', ticks=bounds, 
                              boundaries=bounds, format='%1i')

    # annotate a few galaxies
    gals = ['NGC2403', 'NGC0247', 'NGC4395']
    xytexts = [(14, 7), (-15, 2), (8.5, -10)]
    has = ['center', 'center', 'center']
    for gal, xytext, ha in zip(gals, xytexts, has):
        N = msga['GALAXY'] == gal
        ax[0, 0].annotate(gal, (dra[N], ddec[N]), xytext=xytext, 
                          ha=ha, va='bottom', fontsize=14, 
                          arrowprops=dict(facecolor='k', shrink=0.1))#arrowstyle='-', ))

    xylim = [0.6, 1.7]
    dsga = np.log10(msga['D26'])
    dwxsc = np.log10(2*mwxsc['W1_radius'].values.astype('f4'))
    deltad = dsga - dwxsc

    print('Median, mean+/-sigma, min, max D(26) [SGA]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} arcmin.'.format(
        np.median(10**dsga), np.mean(10**dsga), np.std(10**dsga), np.min(10**dsga), np.max(10**dsga)))
    print('Median, mean+/-sigma, min, max D(26) [SGA-WXSC100]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} arcmin.'.format(
        np.median(deltad), np.mean(deltad), np.std(deltad), np.min(deltad), np.max(deltad)))

    srt = np.argsort(deltad)
    info = msga['GALAXY', 'RA', 'DEC', 'MORPHTYPE', 'HUBBLET'][srt]
    info['LOGDW1_WXSC'] = dwxsc[srt]
    info['LOG_D26_SGA'] = dsga[srt]
    info['DELTAD'] = deltad[srt]
    print(info[:10])
    I = info['HUBBLET'] >= 2
    J = info['HUBBLET'] < 2
    print('Spirals: : ', np.median(info['DELTAD'][I]), np.std(info['DELTAD'][I]))
    print('Ellipticals: : ', np.median(info['DELTAD'][J]), np.std(info['DELTAD'][J]))
    
    ax[0, 1].scatter(dsga, dwxsc, s=ms, marker=marker, c=msga['HUBBLET'], 
                     cmap=cmap, norm=norm, alpha=0.9, edgecolor='k')
    ax[0, 1].plot(xylim, xylim, color='k', lw=2, alpha=0.7)
    ax[0, 1].set_xlim(xylim)
    ax[0, 1].set_ylim(xylim)
    ax[0, 1].set_xlabel(r'$D(26)$ (SGA, arcmin)')
    ax[0, 1].set_ylabel(r'$2\times R_{\mathrm{W1}}$ (WXSC-100, arcmin)')
    #ax[0, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    #ax[0, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[0, 1].xaxis.set_major_formatter(major_formatter)
    ax[0, 1].yaxis.set_major_formatter(major_formatter)
    ax[0, 1].set_xticks(np.log10([5, 7, 10, 15, 25, 40]))
    ax[0, 1].set_yticks(np.log10([5, 7, 10, 15, 25, 40]))
    ax[0, 1].text(xpos, ypos, '(b)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[0, 1].transAxes, alpha=1.0)

    # PA
    pasga, pawxsc = msga['PA'], mwxsc['pa'].values
    deltapa = pasga - pawxsc
    from scipy.stats import sigmaclip
    cdeltapa, _, _ = sigmaclip(deltapa, low=3, high=3)
    print('Median, mean+/-sigma, min, max delta-PA [SGA-WXSC]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f} degree.'.format(
        np.median(cdeltapa), np.mean(cdeltapa), np.std(cdeltapa), np.min(cdeltapa), np.max(cdeltapa)))

    xylim = [-10, 190]
    ax[1, 0].scatter(pasga, pawxsc, marker=marker, c=msga['HUBBLET'], 
                     cmap=cmap, norm=norm, alpha=0.9, edgecolor='k')
    ax[1, 0].plot(xylim, xylim, color='k', lw=2, alpha=0.7)
    ax[1, 0].set_xlim(xylim)
    ax[1, 0].set_ylim(xylim)
    ax[1, 0].set_xlabel(r'$\phi$ (SGA, degree)')
    ax[1, 0].set_ylabel(r'$\phi$ (WXSC-100, degree)')
    ax[1, 0].xaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].yaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].text(xpos, ypos, '(c)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[1, 0].transAxes, alpha=1.0)

    # ellipticity
    esga, ewxsc = 1-msga['BA'], 1-mwxsc['ba'].values
    deltae = esga - ewxsc
    print('Median, mean+/-sigma, min, max delta-epsilon [SGA-WXSC]={:.4f}, {:.4f}+/-{:.4f}, {:.4f}, {:.4f}.'.format(
        np.median(deltae), np.mean(deltae), np.std(deltae), np.min(deltae), np.max(deltae)))

    xylim = [-0.1, 1.0]
    ax[1, 1].scatter(esga, ewxsc, marker=marker, c=msga['HUBBLET'], 
                     cmap=cmap, norm=norm, alpha=0.9, edgecolor='k')
    ax[1, 1].plot(xylim, xylim, color='k', lw=2, alpha=0.7)
    ax[1, 1].set_xlim(xylim)
    ax[1, 1].set_ylim(xylim)
    ax[1, 1].set_xlabel(r'$\epsilon$ (SGA)')
    ax[1, 1].set_ylabel(r'$\epsilon$ (WXSC-100)')
    ax[1, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].text(xpos, ypos, '(d)', ha='left', va='bottom', backgroundcolor='white',
                  transform=ax[1, 1].transAxes, alpha=1.0)

    fig.subplots_adjust(left=0.11, bottom=0.09, right=0.87, top=0.95, hspace=0.25, wspace=0.3)

    #pdb.set_trace()

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)
    
def fig_rich_groups(sga, png=None):
    """Gallery of the richest groups."""

    from PIL import Image
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'rich-groups')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 1.0 # 0.262
    barlen = np.ceil(60 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 1
    nrow = 1
    ngal = ncol * nrow

    #samp = sga[sga['GROUP_PRIMARY'] * (sga['GROUP_MULT'] > 10)]
    samp = sga[sga['GROUP_PRIMARY']]

    #PGC3100847
    samp = sga[sga['GROUP_PRIMARY'] * (sga['GROUP_NAME'] == 'NGC4406_GROUP')]
    print(samp)

    pngfiles = []
    for onegal  in samp:
        jpgfile = os.path.join(montagedir, '{}-rich.jpg'.format(onegal['GALAXY']))
        width = int(2 * onegal['GROUP_DIAMETER'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['GROUP_RA'], onegal['GROUP_DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = onegal['GROUP_RA']
        hdr['CRVAL2'] = onegal['GROUP_DEC']
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600
        wcs = WCS(hdr)

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size
                #draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                #                    onegal['PA'], onegal['D26'] * 60.0, pixscale, color='red')

                onesga = sga[sga['GROUP_NAME'] == onegal['GROUP_NAME']]
                for onesga1 in onesga:
                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, color='blue')
                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            addbar_to_png(pngfile1, barlen, barlabel, onegal['GROUP_NAME'].replace('_GROUP', ' Group'), 
                          pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_sb_mag(sga, frac=None, png=None):
    """Surface brightness vs r-band magnitude.
    
    """
    import corner
    from astropy.table import Table

    sns, _ = plot_style(talk=True, font_scale=1.2)

    def makeplot(mag, sb, xlim, ylim):
        fig, ax = plt.subplots(figsize=(8, 6))
        corner.hist2d(rmag, sb, levels=[0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                      bins=100, smooth=True, color='tan', ax=ax, # mpl.cm.get_cmap('viridis'),
                      plot_density=True, fill_contours=True, range=(xlim, ylim),
                      data_kwargs={'color': 'navy', 'alpha': 0.2, 'ms': 3},
                      contour_kwargs={'colors': 'k'}
                     )
               
        # overplot lines of constant size
        magarr = np.linspace(xlim[0], xlim[1], 50)
        for size, xpos, ypos in zip((5, 10, 25, 60, 100, 300),
                                    (None, None, None, None, None, None),
                                    (22.0, 22.0, 22.0, 22.0, 22.0, 23.0)):
            sbarr = magarr + 2.5 * np.log10(np.pi * size**2)
            ax.plot(magarr, sbarr, color='blue', lw=2, ls='--', alpha=0.8)
            
            if ypos:
                xpos = ypos - 2.5 * np.log10(np.pi * size**2)
            if xpos:
                ypos = xpos + 2.5 * np.log10(np.pi * size**2)
                
            ax.text(xpos, ypos, r'$R_{{26}}={0:g}^{{\prime\prime}}$'.format(size), 
                    ha='left', va='center', rotation=60, fontsize=16, alpha=1.0)
    
        # labels and all that
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        #ax.xmargins(0)
        ax.set_xlabel(r'$m_{r}$ (AB mag)')
        ax.set_ylabel(r'$\langle \mu_{r, R_{26}}\rangle$ (AB mag arcsec$^{-2}$)')
        
        fig.subplots_adjust(bottom=0.15, top=0.95, right=0.95, left=0.15)

        return fig

    ## parent plot
    #good = np.where((parent['SMA_SB26'] != -1) * (parent['R_MAG_SB26'] != -1))[0]
    #rmag = parent['R_MAG_SB26'][good]
    #radius = parent['SMA_SB26'][good] # [arcsec]
    #sb = parent + 2.5 * np.log10(np.pi * radius**2)
    #xlim = (8, 20)
    #ylim = (27, 21)
    #fig = makeplot(rmag, sb, xlim, ylim)
    #
    #if png:
    #    pngfile = os.path.join(figdir, png)
    #    print('Writing {}'.format(pngfile))
    #    fig.savefig(pngfile)#, bbox_inches='tight')
    #    plt.close(fig)

    # SGA plot
    good = np.where((sga['SMA_SB26'] != -1) * (sga['R_MAG_SB26'] != -1))[0]
    rmag = sga['R_MAG_SB26'][good]
    radius = sga['SMA_SB26'][good] # [arcsec]
    sb = rmag + 2.5 * np.log10(np.pi * radius**2)
    xlim = (20, 8)
    ylim = (26, 21)
    fig = makeplot(rmag, sb, xlim, ylim)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sbmontage(onegal, igal=0, colorlim=(0.0, 1.5), png=None):
    """Make one large figure with the surface brightness profile fitting results for
    a single galaxy.

    """
    import numpy.ma as ma

    from PIL import Image, ImageDraw, ImageFont
    from photutils.aperture import EllipticalAperture
    import matplotlib.patches as mpatches

    from astropy.visualization import ImageNormalize
    from astropy.visualization import AsinhStretch as Stretch
    from astropy.visualization import ZScaleInterval as Interval

    from legacyhalos.io import read_ellipsefit
    from legacyhalos.ellipse import ellipse_sbprofile, CogModel
    from legacyhalos.qa import _sbprofile_colors
    from legacyhalos.SGA import read_multiband, SBTHRESH, cog_model

    sns, _ = plot_style(talk=True, font_scale=1.4)
    
    # https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html
    #cmap = plt.cm.plasma
    #cmap = plt.cm.cividis
    cmap = plt.cm.inferno
    #cmap = plt.cm.viridis
    stretch = Stretch(a=0.9)
    interval = Interval(contrast=0.5, n_samples=10000)

    filesuffix = 'largegalaxy'

    #print(sample)
    galaxy, galaxydir = get_galaxy_galaxydir(onegal)
    #this = np.where(galaxy == thisgalaxy)[0][0]
    #onegal, galaxy, galaxydir = np.atleast_1d(sample)[this], np.atleast_1d(galaxy)[this], np.atleast_1d(galaxydir)[this]

    data, galaxyinfo = read_multiband(galaxy, galaxydir, filesuffix=filesuffix, verbose=True)

    galaxy_id = '{}'.format(data['galaxy_id'][igal])
    #galaxy_id = '1121465'
    #galaxy_indx = 1

    # Read the data and the ellipse-fitting results.
    ellipsefile = os.path.join(galaxydir, '{}-{}-{}-ellipse.fits'.format(galaxy, filesuffix, galaxy_id))
    ellipsefit = read_ellipsefit(galaxy, galaxydir, ellipsefitfile=ellipsefile, verbose=True)
    #ellipsefit = read_ellipsefit(galaxy, galaxydir, filesuffix=filesuffix, galaxy_id=galaxy_id, verbose=True)

    # old data model
    ellipsefit['eps_moment'] = ellipsefit['eps'] 
    ellipsefit['sma_g'] = ellipsefit['g_sma'] 
    ellipsefit['sma_r'] = ellipsefit['r_sma'] 
    ellipsefit['sma_z'] = ellipsefit['z_sma'] 
    ellipsefit['intens_g'] = ellipsefit['g_intens'] 
    ellipsefit['intens_r'] = ellipsefit['r_intens'] 
    ellipsefit['intens_z'] = ellipsefit['z_intens'] 
    ellipsefit['intens_err_g'] = ellipsefit['g_intens_err'] 
    ellipsefit['intens_err_r'] = ellipsefit['r_intens_err'] 
    ellipsefit['intens_err_z'] = ellipsefit['z_intens_err'] 

    scaledfont = True
    barlen_arcsec = 60.0 # [arcsec]
    barlen = np.ceil(barlen_arcsec / data['refpixscale']).astype(int) # [pixels]
    #barlen_kpc = barlen_arcsec * arcsec2kpc
    
    barlabel = '1 arcmin'
    #barlabel = '1 arcmin = {:.0f} kpc'.format(barlen_kpc)

    band = data['bands']
    nband = len(band)

    nplot = 12
    sma_lw = 2
    sma_alpha = 0.8

    #fig, ax = plt.subplots(1, 3, figsize=(8*3, 8), sharex=True)
    fig = plt.figure(figsize=(16, 16))
    gs1 = fig.add_gridspec(3, 1, bottom=0.04, top=0.96, left=0.0, right=0.35,
                           height_ratios=[1, 1, 1], hspace=0.03)

    ax0 = fig.add_subplot(gs1[0])
    with Image.open(os.path.join(galaxydir, '{}-{}-image-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Stack'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)
            
        if barlen and barlabel:
            width = np.round(sz[0]/150).astype('int')
            # Add a scale bar and label--
            x0, x1, y0, y1 = 0+fntsize*1.5, 0+fntsize*2+barlen, sz[1]-fntsize*2, sz[1]-fntsize*2.5
            draw.line((x0, y1, x1, y1), fill='white', width=width)
            ww = draw.textlength(barlabel, font=font)
            dx = ((x1-x0) - ww)//2
            #print(x0, x1, y0, y1, ww, x0+dx, sz)
            draw.text((x0+dx, y0), barlabel, font=font)

        # First display the data mosaic
        ax0.imshow(img, interpolation='nearest')
        ax0.xaxis.set_ticklabels([])
        ax0.yaxis.set_ticklabels([])
        ax0.xaxis.set_ticks([])
        ax0.yaxis.set_ticks([])

    # Now the model mosaic
    ax1 = fig.add_subplot(gs1[1])
    with Image.open(os.path.join(galaxydir, '{}-{}-model-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Model'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)

        ax1.imshow(img, interpolation='nearest')
        ax1.xaxis.set_ticklabels([])
        ax1.yaxis.set_ticklabels([])
        ax1.xaxis.set_ticks([])
        ax1.yaxis.set_ticks([])

    filt = 'r'
    dat = data['{}_masked'.format(filt)][igal]
    img = ma.masked_array(dat.data, dat.mask)
    mask = ma.masked_array(dat.data, ~dat.mask)

    try:
        norm = ImageNormalize(img, interval=interval, stretch=stretch)
    except:
        norm = ImageNormalize(img, interval=interval)

    ax2 = fig.add_subplot(gs1[2])
    ax2.imshow(dat, origin='lower', norm=norm, cmap=cmap, #cmap=cmap[filt],
               interpolation='nearest')
    txt = plt.text(0.08, 0.9, r'${}$-band Image'.format(filt), transform=ax2.transAxes, #fontweight='bold',
                   ha='left', va='center', color='k', fontsize=18)
    #txt.set_bbox(dict(facecolor='gray', alpha=0.5))

    #smas = np.linspace(0, ellipsefit['{}_sma'.format(filt)].max(), nplot)
    radkeys = ['SMA_SB{:0g}'.format(sbcut) for sbcut in SBTHRESH]
    smas = np.array(list(onegal[radkeys].as_array()[0])) / data['refpixscale'] # semi-major axis, pixels
    for sma, key in zip(smas, radkeys):
        this = np.argmin(np.abs(ellipsefit['{}_sma'.format(filt)]-sma))
        if key == 'SMA_SB26':
            col = 'dodgerblue'
            lw = 4
        else:
            col = 'k'
            lw = sma_lw
        ax2.add_patch(mpatches.Ellipse((ellipsefit['{}_x0'.format(filt)][this], ellipsefit['{}_y0'.format(filt)][this]),
                                       2*ellipsefit['{}_sma'.format(filt)][this],
                                       2*ellipsefit['{}_sma'.format(filt)][this]*(1-ellipsefit['{}_eps'.format(filt)][this]),
                                       angle=ellipsefit['{}_pa'.format(filt)][this]-90,
                                       color=col, lw=lw, alpha=sma_alpha, fill=False))#, label='Fitted isophote')

    for xx in (ax0, ax1, ax2):
        xx.xaxis.set_ticklabels([])
        xx.yaxis.set_ticklabels([])
        xx.xaxis.set_ticks([])
        xx.yaxis.set_ticks([])

    ## [1] vertical 3-panel showing the grz data and ellipse samples
    #for ii, filt in enumerate(band):
    #    xx = fig.add_subplot(gs1[ii])
    #    
    #    dat = data['{}_masked'.format(filt)][igal]
    #    img = ma.masked_array(dat.data, dat.mask)
    #    mask = ma.masked_array(dat.data, ~dat.mask)
    #
    #    try:
    #        norm = ImageNormalize(img, interval=interval, stretch=stretch)
    #    except:
    #        norm = ImageNormalize(img, interval=interval)
    #
    #    xx.imshow(dat, origin='lower', norm=norm, cmap=cmap, #cmap=cmap[filt],
    #               interpolation='nearest')
    #    plt.text(0.1, 0.9, filt, transform=xx.transAxes, fontweight='bold',
    #             ha='center', va='center', color='k', fontsize=26)
    #
    #    smas = np.linspace(0, ellipsefit['{}_sma'.format(filt)].max(), nplot)
    #    for sma in smas:
    #        this = np.argmin(np.abs(ellipsefit['{}_sma'.format(filt)]-sma))
    #        xx.add_patch(mpatches.Ellipse((ellipsefit['{}_x0'.format(filt)][this], ellipsefit['{}_y0'.format(filt)][this]),
    #                                       2*ellipsefit['{}_sma'.format(filt)][this],
    #                                       2*ellipsefit['{}_sma'.format(filt)][this]*(1-ellipsefit['{}_eps'.format(filt)][this]),
    #                                       ellipsefit['{}_pa'.format(filt)][this]-90,
    #                                       color='k', lw=sma_lw, alpha=sma_alpha, fill=False))#, label='Fitted isophote')
    #
    #    xx.xaxis.set_ticklabels([])
    #    xx.yaxis.set_ticklabels([])
    #    xx.xaxis.set_ticks([])
    #    xx.yaxis.set_ticks([])

    # [2] surface brightness and color profile
    gs2 = fig.add_gridspec(3, 1, bottom=0.08, top=0.93, left=0.42,
                           right=0.98, hspace=0.04, height_ratios=[2.9, 1.4, 2])
    
    minerr, use_ylim, plot_radius = 0.0, None, False
    
    sbprofile = ellipse_sbprofile(ellipsefit, minerr=minerr, sma_not_radius=~plot_radius,
                                  cut_on_cog=False)
    colors = _sbprofile_colors(makeiter=True)

    bands = ellipsefit['bands']
    refband = ellipsefit['refband']

    yminmax = [40, 0]
    xminmax = [1.0, 0]
    #xminmax = [1.0, 0]

    #fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True,
    #                               gridspec_kw = {'height_ratios':[2, 1]})
    ax1 = fig.add_subplot(gs2[0])
    ax2 = fig.add_subplot(gs2[1])#, sharex=ax1)
    for filt in bands:
        col = next(colors)

        mu = sbprofile['mu_{}'.format(filt)]
        muerr = sbprofile['muerr_{}'.format(filt)]
        if len(mu) == 0 or mu[0] == -1: # no good data
            continue
        radius = sbprofile['radius_{}'.format(filt)]**0.25

        ax1.fill_between(radius, mu-muerr, mu+muerr, label=r'${}$'.format(filt),
                         facecolor=col, edgecolor='k', lw=2, alpha=0.75)

        if np.nanmin(mu-muerr) < yminmax[0]:
            yminmax[0] = np.nanmin(mu-muerr)
        if np.nanmax(mu+muerr) > yminmax[1]:
            yminmax[1] = np.nanmax(mu+muerr)
        if np.nanmax(radius) > xminmax[1]:
            xminmax[1] = np.nanmax(radius)

        if filt == 'r':
            for col, ls in zip(['R_SMA50', 'SMA_SB26'], ['--', '-']):
                if col == 'SMA_SB26':
                    muint = 26.0
                else:
                    muint = np.interp(onegal[col][0]**0.25, radius, mu)
                ax1.plot([xminmax[0], onegal[col][0]**0.25], [muint, muint], color='gray', ls=ls)
                ax1.plot([onegal[col][0]**0.25, onegal[col][0]**0.25], [yminmax[1]+0.5, muint], color='gray', ls=ls)
            #ax1.axvline(x=onegal['R_SMA50']**0.25, color='gray', ls='-')
            #ax1.axvline(x=onegal['SMA_SB26']**0.25, color='gray', ls='--')

    ax1.set_ylabel(r'$\mu(r)$ (mag arcsec$^{-2}$)')
    #ax1.set_ylabel(r'Surface Brightness $\mu(a)$ (mag arcsec$^{-2}$)')

    ylim = [yminmax[0]-0.75, yminmax[1]+0.5]
    if ylim[0] < 17:
        ylim[0] = 17
    if ylim[1] > 33:
        ylim[1] = 33

    if use_ylim is not None:
        ax1.set_ylim(use_ylim)
    else:
        ax1.set_ylim(ylim)
    ax1.invert_yaxis()

    xlim = [xminmax[0], xminmax[1]*1.0]
    ax1.set_xlim(xlim)

    hh, ll = ax1.get_legend_handles_labels()
    if len(hh) > 0:
        leg1 = ax1.legend(loc='upper right', fontsize=18, frameon=True)
        #ax1.set_title('{} ({})'.format(onegal['GALAXY'][0], onegal['GROUP_NAME'][0].replace('_', ' ')))
        ax1.set_title(galaxyinfo[igal]['galaxy'][0])

    # Now the color-radius plot
    if sbprofile['radius_gr'][0] != -1:
        ax2.fill_between(sbprofile['radius_gr']**0.25,
                         sbprofile['gr'] - sbprofile['gr_err'],
                         sbprofile['gr'] + sbprofile['gr_err'],
                         label=r'$g - r$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    if sbprofile['radius_rz'][0] != -1:
        ax2.fill_between(sbprofile['radius_rz']**0.25,
                         sbprofile['rz'] - sbprofile['rz_err'],
                         sbprofile['rz'] + sbprofile['rz_err'],
                         label=r'$r - z$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    hh, ll = ax2.get_legend_handles_labels()
    if len(hh) > 0:
        ax2.legend(loc='upper right', fontsize=18, frameon=True)
        #ax2.legend(bbox_to_anchor=(0.25, 0.98))

    ax2.set_ylabel('Color (mag)')
    ax2.set_ylim(colorlim)
    ax2.set_xlim(xlim)
    #ax2.autoscale(False) # do not scale further

    for xx in (ax1, ax2):
        xx.margins(x=0)
        xx.xaxis.set_ticklabels([])
        ylim = xx.get_ylim()
        xx.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                        [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)

    #ax2.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #    transform=ax2.transAxes, fontsize=10)
    ax1.text(0.07, 0.1, 'PSF\n(2$\sigma$)', ha='center', va='center',
             transform=ax1.transAxes, fontsize=18)

    # [3] curve of growth
    ax3 = fig.add_subplot(gs2[2])#, sharex=ax2)
    colors = _sbprofile_colors()
    colors2 = iter(['navy', 'darkgreen', 'tomato'])
    marker = iter(['s', 'o', '^'])

    radkeys = ['SMA_SB{:0g}'.format(sbcut) for sbcut in SBTHRESH]
    sma_arcsec = np.array(list(onegal[radkeys].as_array()[0])) # semi-major axis, arcsec
    xplot_arcsec = np.linspace(0.01, 1.05*xlim[1]**4, 100)
    #xplot_arcsec = np.linspace(0.01, 1.3*np.max(sma_arcsec), 100)

    maxsma = 0
    eps = ellipsefit['eps']

    yfaint, ybright = 0, 50
    for filt in bands:
        col = next(colors) # iterate here in case we're missing a bandpass
        col2 = next(colors2)
        mark = next(marker)

        magkeysfilt = [radkey.replace('SMA_', '{}_MAG_'.format(filt.upper())) for radkey in radkeys]
        magerrkeysfilt = ['{}_ERR'.format(magkeyfilt) for magkeyfilt in magkeysfilt]
        cogmag = np.array(list(onegal[magkeysfilt].as_array()[0]))
        cogmagerr = np.sqrt((np.array(list(onegal[magerrkeysfilt].as_array()[0])))**2 + minerr**2)

        these = np.where((sma_arcsec > 0) * (cogmag > 0) * (cogmagerr > 0))[0]
        cog = cogmag[these]
        cogerr = cogmagerr[these]
        sma = sma_arcsec[these]

        magtot = onegal['{}_COG_PARAMS_MTOT'.format(filt.upper())][0]
        m0 = onegal['{}_COG_PARAMS_M0'.format(filt.upper())][0]
        alpha1 = onegal['{}_COG_PARAMS_ALPHA1'.format(filt.upper())][0]
        alpha2 = onegal['{}_COG_PARAMS_ALPHA2'.format(filt.upper())][0]
        chi2 = onegal['{}_COG_PARAMS_CHI2'.format(filt.upper())][0]
        #print(filt, magtot, m0, alpha1, alpha2)

        label = r'${}={:.2f}$'.format(filt, magtot)
        #label = r'${}={:.3f}\ (\chi^{{2}}_{{\nu}}={:.2f})$'.format(filt, magtot, chi2)
        #label = r'${}$'.format(filt)

        ax3.errorbar(sma**0.25, cog, cogerr, fmt=mark, color=col, label=label,
                     markersize=10, capthick=2, capsize=2)

        yplot_mag = cog_model(xplot_arcsec, magtot, m0, alpha1, alpha2)
        ax3.plot(xplot_arcsec**0.25, yplot_mag, color=col2, lw=2, ls='-', alpha=0.5)

        if np.max(sma) > maxsma:
            maxsma = np.max(sma)

        if cog.max() > yfaint:
            yfaint = cog.max()
        if cog.min() < ybright:
            ybright = cog.min()

    ax3.set_xlabel(r'(Semi-major axis / arcsec)$^{1/4}$')
    ax3.set_ylabel(r'm$(<r)$ (mag)')
    #ax3.margins(x=0)
    ax3.set_xlim(xlim)
        
    yfaint += 1.0 # 0.7
    ybright += -0.5 # -0.7
    ax3.set_ylim(yfaint, ybright)
    #ax3.xaxis.set_major_locator(ticker.MultipleLocator(0.5))

    if False:
        ax_twin = ax.twinx()
        ax_twin.set_ylim(yfaint, ybright)
        ax_twin.set_ylabel('Cumulative Flux (AB mag)')#, rotation=-90)

    if True:
        hh, ll = ax3.get_legend_handles_labels()
        if len(hh) > 0:
            leg1 = ax3.legend(loc='lower right', fontsize=14)#, ncol=3)

    ylim = ax3.get_ylim()
    ax3.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                     [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)
    #ax3.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #         transform=ax3.transAxes, fontsize=16)

        
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sbmontage_gallery(onegal, png):
    """Like fig_sbmontage but with fewer panels so the figures can be used in
    landscape mode for the poster gallery.

    """
    import numpy.ma as ma

    from PIL import Image, ImageDraw, ImageFont
    from photutils import EllipticalAperture
    import matplotlib.patches as mpatches

    from astropy.visualization import ImageNormalize
    from astropy.visualization import AsinhStretch as Stretch
    from astropy.visualization import ZScaleInterval as Interval

    from legacyhalos.io import read_ellipsefit
    from legacyhalos.ellipse import ellipse_sbprofile, CogModel
    from legacyhalos.qa import _sbprofile_colors
    from legacyhalos.SGA import read_multiband

    sns, _ = plot_style(talk=True, font_scale=1.4)
    
    # https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html
    #cmap = plt.cm.plasma
    #cmap = plt.cm.cividis
    cmap = plt.cm.inferno
    #cmap = plt.cm.viridis
    stretch = Stretch(a=0.9)
    interval = Interval(contrast=0.5, n_samples=10000)

    filesuffix = 'largegalaxy'

    #print(sample)
    galaxy, galaxydir = get_galaxy_galaxydir(onegal)
    #this = np.where(galaxy == thisgalaxy)[0][0]
    #onegal, galaxy, galaxydir = np.atleast_1d(sample)[this], np.atleast_1d(galaxy)[this], np.atleast_1d(galaxydir)[this]

    data, galaxyinfo = read_multiband(galaxy, galaxydir, filesuffix=filesuffix, verbose=True)

    igal = 0
    galaxy_id = '{}'.format(data['galaxy_id'][igal])
    #galaxy_id = '1121465'
    #galaxy_indx = 1

    # Read the data and the ellipse-fitting results.
    ellipsefit = read_ellipsefit(galaxy, galaxydir, filesuffix=filesuffix, galaxy_id=galaxy_id, verbose=True)

    scaledfont = True
    barlen_arcsec = 60.0 # [arcsec]
    barlen = np.ceil(barlen_arcsec / data['refpixscale']).astype(int) # [pixels]
    #barlen_kpc = barlen_arcsec * arcsec2kpc
    
    barlabel = '1 arcmin'
    #barlabel = '1 arcmin = {:.0f} kpc'.format(barlen_kpc)

    band = data['bands']
    nband = len(band)

    nplot = 12
    sma_lw = 2
    sma_alpha = 0.8

    #fig, ax = plt.subplots(1, 3, figsize=(8*3, 8), sharex=True)
    fig = plt.figure(figsize=(16, 9))
    gs1 = fig.add_gridspec(2, 1, bottom=0.04, top=0.96, left=0.0, right=0.35,
                           height_ratios=[1, 1], hspace=0.03)

    ax0 = fig.add_subplot(gs1[0])
    with Image.open(os.path.join(galaxydir, '{}-{}-image-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Stack'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)
            
        if barlen and barlabel:
            width = np.round(sz[0]/150).astype('int')
            # Add a scale bar and label--
            x0, x1, y0, y1 = 0+fntsize*1.5, 0+fntsize*2+barlen, sz[1]-fntsize*2, sz[1]-fntsize*2.5
            draw.line((x0, y1, x1, y1), fill='white', width=width)
            ww = draw.textlength(barlabel, font=font)
            dx = ((x1-x0) - ww)//2
            #print(x0, x1, y0, y1, ww, x0+dx, sz)
            draw.text((x0+dx, y0), barlabel, font=font)

        # First display the data mosaic
        ax0.imshow(img, interpolation='nearest')
        ax0.xaxis.set_ticklabels([])
        ax0.yaxis.set_ticklabels([])
        ax0.xaxis.set_ticks([])
        ax0.yaxis.set_ticks([])

    # Now the model mosaic
    ax1 = fig.add_subplot(gs1[1])
    with Image.open(os.path.join(galaxydir, '{}-{}-model-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Model'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)

        ax1.imshow(img, interpolation='nearest')
        ax1.xaxis.set_ticklabels([])
        ax1.yaxis.set_ticklabels([])
        ax1.xaxis.set_ticks([])
        ax1.yaxis.set_ticks([])

    for xx in (ax0, ax1):
        xx.xaxis.set_ticklabels([])
        xx.yaxis.set_ticklabels([])
        xx.xaxis.set_ticks([])
        xx.yaxis.set_ticks([])

    # [2] surface brightness and color profile
    gs2 = fig.add_gridspec(2, 1, bottom=0.12, top=0.93, left=0.42,
                           right=0.98, hspace=0.04, height_ratios=[2.9, 1.4])
    
    minerr, use_ylim, plot_radius = 0.0, None, False
    
    sbprofile = ellipse_sbprofile(ellipsefit, minerr=minerr, sma_not_radius=~plot_radius,
                                  cut_on_cog=False)
    colors = _sbprofile_colors(makeiter=True)

    bands = ellipsefit['bands']
    refband = ellipsefit['refband']

    yminmax = [40, 0]
    xminmax = [0.9, 0]
    #xminmax = [1, 0]

    ax1 = fig.add_subplot(gs2[0])
    ax2 = fig.add_subplot(gs2[1], sharex=ax1)
    for filt in bands:
        col = next(colors)

        mu = sbprofile['mu_{}'.format(filt)]
        muerr = sbprofile['muerr_{}'.format(filt)]
        if len(mu) == 0 or mu[0] == -1: # no good data
            continue
        radius = sbprofile['radius_{}'.format(filt)]**0.25

        ax1.fill_between(radius, mu-muerr, mu+muerr, label=r'${}$'.format(filt),
                         facecolor=col, edgecolor='k', lw=2, alpha=0.75)

        if np.nanmin(mu-muerr) < yminmax[0]:
            yminmax[0] = np.nanmin(mu-muerr)
        if np.nanmax(mu+muerr) > yminmax[1]:
            yminmax[1] = np.nanmax(mu+muerr)
        if np.nanmax(radius) > xminmax[1]:
            xminmax[1] = np.nanmax(radius)

    ax1.set_ylabel(r'$\mu(r)$ (mag arcsec$^{-2}$)')
    #ax1.set_ylabel(r'Surface Brightness $\mu(a)$ (mag arcsec$^{-2}$)')

    ylim = [yminmax[0]-0.75, yminmax[1]+0.5]
    if ylim[0] < 17:
        ylim[0] = 17
    if ylim[1] > 33:
        ylim[1] = 33

    if use_ylim is not None:
        ax1.set_ylim(use_ylim)
    else:
        ax1.set_ylim(ylim)
    ax1.invert_yaxis()

    xlim = [xminmax[0], xminmax[1]*1.0]
    ax1.set_xlim(xlim)

    hh, ll = ax1.get_legend_handles_labels()
    if len(hh) > 0:
        leg1 = ax1.legend(loc='upper right', fontsize=18, frameon=True)
        if onegal['GROUP_MULT'] > 1:
            ax1.set_title('{} ({})'.format(onegal['GALAXY'], onegal['GROUP_NAME'].replace('_', ' ')))
        else:
            ax1.set_title(onegal['GALAXY'])
        #ax1.set_title(galaxyinfo[igal]['galaxy'][0])

    # Now the color-radius plot
    if sbprofile['radius_gr'][0] != -1:
        ax2.fill_between(sbprofile['radius_gr']**0.25,
                         sbprofile['gr'] - sbprofile['gr_err'],
                         sbprofile['gr'] + sbprofile['gr_err'],
                         label=r'$g - r$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    if sbprofile['radius_rz'][0] != -1:
        ax2.fill_between(sbprofile['radius_rz']**0.25,
                         sbprofile['rz'] - sbprofile['rz_err'],
                         sbprofile['rz'] + sbprofile['rz_err'],
                         label=r'$r - z$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    hh, ll = ax2.get_legend_handles_labels()
    if len(hh) > 0:
        ax2.legend(loc='upper right', fontsize=18, frameon=True)
        #ax2.legend(bbox_to_anchor=(0.25, 0.98))

    ax2.set_ylabel('Color (mag)')
    ax2.set_ylim(-1, 2)
    ax2.set_xlim(xlim)
    #ax2.autoscale(False) # do not scale further

    for xx in (ax1, ax2):
        xx.margins(x=0)
        #xx.xaxis.set_ticklabels([])
        ylim = xx.get_ylim()
        xx.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                        [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)

    #ax2.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #    transform=ax2.transAxes, fontsize=10)
    ax1.text(0.07, 0.1, 'PSF\n(2$\sigma$)', ha='center', va='center',
             transform=ax1.transAxes, fontsize=18)

    ax2.set_xlabel(r'Semi-major axis $r^{1/4}$ (arcsec)$^{1/4}$')
        
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_nsa_completeness(sga, png=None):
    """Quantify the sample completeness by comparing against the NSA

    """
    import corner
    from glob import glob
    import healpy as hp
    import astropy.units as u
    from astropy.table import vstack
    from astropy.coordinates import SkyCoord
    from pydl.pydlutils.yanny import read_table_yanny
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.3)

    # http://nsatlas.org
    # https://www.sdss4.org/dr17/manga/manga-target-selection/nsa/
    nsafile = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.fits')
    nsadr9file = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.dr9.fits')
    nsanodr9file = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.nodr9.fits')
    if not os.path.isfile(nsadr9file):
        nsa = Table(fitsio.read(nsafile))
        print('Read {} galaxies from {}'.format(len(nsa), nsafile))
    
        # remove bad deblends
        comm = read_table_yanny(os.path.join(paperdir, 'data', 'nsa', 'nsa_comments.par'), 'COMMENT')
        bad = np.zeros(len(comm), bool)
        for ii, comment in enumerate(comm['comment']):
            comment = comment.lower()
            if 'bad' in comment or 'poor' in comment:
                bad[ii] = True
        bad = np.where(bad)[0]
        print('Removing {} bad or poor deblends'.format(len(bad)))

        nsa = nsa[np.logical_not(np.isin(nsa['NSAID'], comm['nsaid'][bad]))]
    
        # only keep objects in the LS/DR9 footprint
        randomfiles = glob(os.path.join(paperdir, 'data', 'randoms-1-*.fits'))
        rand = []
        for randomfile in randomfiles:
            print('Reading {}'.format(randomfile))
            rand1 = fitsio.read(randomfile, columns=['NOBS_G', 'NOBS_R', 'NOBS_Z'])
            I = np.where((rand1['NOBS_G'] > 0) * (rand1['NOBS_R'] > 0) * (rand1['NOBS_Z'] > 0))[0]
            rand.append(Table(fitsio.read(randomfile, columns=['RA', 'DEC'], rows=I)))
        rand = vstack(rand)
        print('Read {:,d} random points from {} randomfiles.'.format(len(rand), len(randomfiles)))

        c_nsa = SkyCoord(nsa['RA']*u.deg, nsa['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        rad = 2 * u.arcmin
        _, indx_nsa, d2d, _ = c_nsa.search_around_sky(c_rand, rad)
        indx_nsa = np.sort(np.unique(indx_nsa))
        print('Matched {}/{} NSA galaxies to a DR9 random point with NOBS_[GRZ]>1'.format(len(indx_nsa), len(nsa)))
    
        nsa_nodr9 = nsa[np.delete(np.arange(len(nsa)), indx_nsa)]

        #c_nsa2 = SkyCoord(nsa_nodr9['RA'][:10]*u.deg, nsa_nodr9['DEC'][:10]*u.deg)
        #_, sep2d, _ = c_nsa2.match_to_catalog_sky(c_rand)
        #print(sep2d.arcsec)
        #plt.clf() ; plt.scatter(rand['RA'], rand['DEC'], s=1) ; plt.ylim(-1., -0.5) ; plt.xlim(145.5, 146) ; plt.scatter(nsa_nodr9['RA'], nsa_nodr9['DEC'], s=50) ; plt.savefig('junk.png')
    
        nsa = nsa[indx_nsa]
        print(f'Writing {nsadr9file}')
        nsa.write(nsadr9file, overwrite=True)

        print(f'Writing {nsanodr9file}')
        nsa_nodr9.write(nsanodr9file, overwrite=True)

        pngfile = os.path.join(paperdir, 'data', 'nsa', 'qa-nsa-dr9-radec.png')
        print('Writing {}'.format(pngfile))
        fig, ax = plt.subplots(figsize=(10, 7))
        ax.scatter(sga['RA'], sga['DEC'], s=1, label='SGA')
        ax.scatter(nsa['RA'], nsa['DEC'], s=1, marker='s', alpha=0.5, label='NSA-DR9')
        ax.scatter(nsa_nodr9['RA'], nsa_nodr9['DEC'], s=10, marker='s', label='NSA - outside DR9')
        ax.set_xlabel('RA (degree)')
        ax.set_ylabel('Dec (degree)')
        ax.legend(fontsize=12)
        fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    nsa = Table(fitsio.read(nsadr9file, columns=['NSAID', 'IAUNAME', 'RA', 'DEC', 'Z', 
                                                 #'PETROTHETA', 'PETROTH50', 'PETROTH90', 
                                                 'SERSIC_TH50', 'SERSIC_BA', 'SERSIC_PHI', 'SERSIC_FLUX', 
                                                 'ELPETRO_FLUX_R', 'ELPETRO_BA', 'ELPETRO_PHI', 'ELPETRO_TH50_R'
                                                 ]))
    print('Read {} galaxies from {}'.format(len(nsa), nsadr9file))

    I = np.where(np.logical_or(nsa['ELPETRO_TH50_R'] < 0, nsa['ELPETRO_BA'] < 0))[0]
    nsa['ELPETRO_TH50_R'][I] = nsa['SERSIC_TH50'][I]
    nsa['ELPETRO_BA'][I] = nsa['SERSIC_BA'][I]
    nsa['ELPETRO_PHI'][I] = nsa['SERSIC_PHI'][I]
    nsa['ELPETRO_FLUX_R'][I] = nsa['SERSIC_FLUX'][I, 2]

    # testing stuff
    nsa_nodr9 = Table(fitsio.read(nsanodr9file, columns=['NSAID', 'IAUNAME', 'RA', 'DEC', 'Z']))
    print('Read {} galaxies from {}'.format(len(nsa_nodr9), nsanodr9file))

    # quick QA to determine the matching radius
    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_nsa = SkyCoord(ra=nsa['RA']*u.deg, dec=nsa['DEC']*u.deg)
    _, sep2d, _ = c_nsa.match_to_catalog_sky(c_sga)

    pngfile = os.path.join(paperdir, 'data', 'nsa', 'qa-nsa-sga2020-separation.png')
    print('Writing {}'.format(pngfile))
    fig, ax = plt.subplots(figsize=(10, 7))
    sep2d = sep2d.arcsec
    #sep2d[sep2d < 1e-1] = 1e-1
    #_ = ax.hist(sep2d, bins=100, cumulative=True, density=True, histtype='step')
    _ = ax.hist(np.log10(sep2d), bins=75, label='All Galaxies')#, cumulative=True, density=True, histtype='step')
    _ = ax.hist(np.log10(sep2d[nsa['ELPETRO_TH50_R']>30]), bins=75, label=r'$r_{50,EllPetro}>30$ arcsec')
    ax.axvline(x=np.log10(10), ls='--', color='k')
    ax.set_xlabel(r'$\log_{10}\,(\mathrm{NSA-SGA\ Separation})$ (arcsec)')
    ax.set_ylabel('Number of Galaxies')
    ax.set_yscale('log')
    ax.legend(fontsize=14)
    #ax.set_xlim(0, 100)
    #ax.axvline(x=rad.value, ls='-', color='k')
    fig.subplots_adjust(bottom=0.14, right=0.95, top=0.95, left=0.17)
    fig.savefig(pngfile)#, bbox_inches='tight')
    plt.close(fig)

    #nsa[nsa['ELPETRO_TH50_R'] < 0]
    #plt.clf() ; plt.scatter(np.log10(nsa['ELPETRO_TH50_R']/60), np.log10(sep2d), s=1) ; plt.savefig('junk.png')

    # now match
    if True:
        from pydl.pydlutils.spheregroup import spherematch
        rad = 10.0
        indx_nsa, indx_sga, sep = spherematch(nsa['RA'], nsa['DEC'], sga['RA'], sga['DEC'], rad/3600., maxmatch=1)
    else:
        rad = 10 * u.arcsec
        indx_nsa, indx_sga, d2d, _ = c_sga.search_around_sky(c_nsa, rad)
        indx_nsa, indx_sga, d2d, _ = c_sga.search_around_sky(c_nsa, rad)
        print(len(indx_nsa), len(np.unique(indx_nsa)))
    print('Found {:,d}/{:,d} unique SGA-NSA matches within {} arcsec.'.format(len(indx_nsa), len(nsa), rad))
    assert(len(indx_nsa) == len(np.unique(indx_nsa)))

    m_sga = sga[indx_sga]
    m_nsa = nsa[indx_nsa]

    # find the median scaling between D25_LEDA and PETROTHETA
    sersicfactor = np.median(60*m_sga['D25_LEDA'] / m_nsa['ELPETRO_TH50_R'])
    print('Median NSA(D25) = {:.4f} x ELPETRO_TH50_R'.format(sersicfactor))
    sersicfactor = 5.0

    #plt.clf() ; _=plt.hist(m_sga['D25_LEDA']/(m_nsa['ELPETRO_TH50_R']/60), bins=100, range=(0, 20)) ; plt.axvline(x=sersicfactor, color='k') ; plt.xlim(0, 20) ; plt.savefig('junk.png')
    #plt.clf() ; plt.scatter(m_sga['D25_LEDA'], m_sga['D25_LEDA']/(m_nsa['ELPETRO_TH50_R']/60), s=1) ; plt.axhline(y=sersicfactor, color='k') ;  plt.ylim(2, 10) ; plt.savefig('junk.png')

    # get the raw and corrected fraction of non-matches as a function of SERSIC_TH50
    lograd = np.log10(sersicfactor*nsa['ELPETRO_TH50_R']/60)
    match_lograd = np.log10(sersicfactor*m_nsa['ELPETRO_TH50_R']/60)
    minrad, maxrad, drad = -1.4, 1.3, 0.1
    ##minrad, maxrad = np.min(lograd), np.max(lograd)

    nhist = int(np.ceil((maxrad - minrad) / drad))
    histobins = np.histogram_bin_edges(match_lograd, bins=nhist, range=(minrad, maxrad))
    histobins = np.array([-1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4,
                          -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,
                          0.8,  0.9,  1. ,  1.1,  1.2,  1.3])
    bins = histobins[:-1]

    #bins = np.arange(minrad, maxrad, drad) # bin left edges
    numer, _ = np.histogram(match_lograd, bins=histobins)
    denom, _ = np.histogram(lograd, bins=histobins)
    #denom, _ = np.histogram(lograd, bins=len(bins), range=(minrad, maxrad+drad))

    good = denom > 0
    xfrac = bins[good]
    yfrac = numer[good] / denom[good] 
    for ii, (bb, nn, dd) in enumerate(zip(bins, numer, denom)):
        print(bb, 10**bb, nn, dd, nn/dd, dd-nn) # np.sum((lograd>bb)*(lograd<(bb+drad))))

    _logradcut = 0.0
    I = bins >= _logradcut
    print('There are {} NSA galaxies not in the SGA larger than {:.1f} arcmin.'.format(
        np.sum(denom[I]-numer[I]), 10**_logradcut))

    # --------------------------------------------------
    # NSA galaxies not in the SGA
    remake_montage = False
    if remake_montage:
        nsa_notin_sga = nsa[np.delete(np.arange(len(nsa)), indx_nsa)]

        srt = np.argsort(nsa_notin_sga['ELPETRO_TH50_R'])[::-1]
        nsa_notin_sga = nsa_notin_sga[srt]
        
        #I = np.log10(sersicfactor * nsa_notin_sga['ELPETRO_TH50_R'] / 60) >= logradcut
        #print('Trimming to {:,d}/{:,d} NSA galaxies with 4.5xSERSIC_TH50>{:.1f} arcmin not in the SGA'.format(
        #    np.sum(I), len(nsa_notin_sga), 10**logradcut))
        #nsa_notin_sga = nsa_notin_sga[I]
        #srt = np.argsort(nsa_notin_sga['ELPETRO_TH50_R'])[::-1]
        #nsa_notin_sga = nsa_notin_sga[srt]
        #print(nsa_notin_sga)
    
        montagedir = os.path.join(paperdir, 'data', 'nsa', 'nsa-notin-sga')
        if not os.path.isdir(montagedir):
            os.makedirs(montagedir, exist_ok=True)
        
        ncol = 10
        nrow = 10
        ngal = ncol * nrow
    
        pixscale = 5.0 # 0.262
        barlen = np.ceil(60 / pixscale) # [pixels]
        barlabel = '' # '30 arcsec'

        logradcut = 1.0

        # split into diameter bins
        for ibin in np.arange(len(bins)):
            minbin, maxbin = histobins[ibin], histobins[ibin+1]
            print(ibin, minbin, maxbin)
            if minbin < logradcut:
                continue

            binlabel = '{:.1f}-{:.1f}arcmin'.format(10**minbin, 10**maxbin)

            dnsa = np.log10(sersicfactor * nsa_notin_sga['ELPETRO_TH50_R'] / 60)
            B = np.where((dnsa >= minbin) * (dnsa < maxbin))[0]

            nsa_notin_sga_bin = nsa_notin_sga[B]

            # find near SGA sources, if any
            coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
            coord_nsa_notin_sga = SkyCoord(ra=nsa_notin_sga_bin['RA']*u.deg, dec=nsa_notin_sga_bin['DEC']*u.deg)
        
            # split into multiple pages
            Isplit = np.array_split(np.arange(len(nsa_notin_sga_bin)), np.ceil(len(nsa_notin_sga_bin)/ngal).astype(int))
            npage = len(Isplit)
            print(f'Splitting into {npage} pages with {ngal} galaxies per page.')

            for ipage, I in enumerate(Isplit):
                print('Working on page {}/{} with {} galaxies.'.format(ipage+1, npage, len(I)))

                sga_close = []
                for coord_nsa_notin_sga1, diam in zip(coord_nsa_notin_sga[I], sersicfactor*nsa_notin_sga_bin['ELPETRO_TH50_R'][I]):
                    sep = coord_nsa_notin_sga1.separation(coord_sga)
                    close = sep.arcsec < 2*diam
                    if np.any(close):
                        sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
                    else:
                        sga_close.append(Table())

                pngfiles = []
                for onegal, onesga in zip(nsa_notin_sga_bin[I], sga_close):
                    jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['NSAID']))
                    width = int(2 * sersicfactor * onegal['ELPETRO_TH50_R'] / pixscale)
                    if not os.path.isfile(jpgfile):
                        urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                            onegal['RA'], onegal['DEC'], pixscale, width, width)
                        cmd = f'wget -q -O {jpgfile} {urlfile}'
                        print(cmd)
                        subprocess.call(cmd.split())
            
                    pngfile1 = jpgfile.replace('.jpg', '.png')
                    if not os.path.isfile(pngfile1):
                        with Image.open(jpgfile) as colorimg:
                            imgsz = colorimg.size
            
                            hdr = fits.Header()
                            hdr['NAXIS'] = 2
                            hdr['NAXIS1'] = imgsz[0]
                            hdr['NAXIS2'] = imgsz[0]
                            hdr['CTYPE1'] = 'RA---TAN'
                            hdr['CTYPE2'] = 'DEC--TAN'
                            hdr['CRVAL1'] = onegal['RA']
                            hdr['CRVAL2'] = onegal['DEC']
                            hdr['CRPIX1'] = imgsz[0]/2+0.5
                            hdr['CRPIX2'] = imgsz[0]/2+0.5
                            hdr['CD1_1'] = -pixscale/3600
                            hdr['CD1_2'] = 0.0
                            hdr['CD2_1'] = 0.0
                            hdr['CD2_2'] = +pixscale/3600
                            wcs = WCS(hdr)
                    
                            try:
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['ELPETRO_BA'], 
                                                    onegal['ELPETRO_PHI'], sersicfactor*onegal['ELPETRO_TH50_R'], 
                                                    pixscale, color='red', linewidth=2)
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['ELPETRO_BA'], 
                                                    onegal['ELPETRO_PHI'], 2*onegal['ELPETRO_TH50_R'], 
                                                    pixscale, color='red', linewidth=2)
                            except:
                                pdb.set_trace()

                            # add the SGA sources, if any
                            if len(onesga) > 0:
                                for onesga1 in onesga:
                                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                                        color='dodgerblue', linewidth=2)
            
                            print(f'Writing {pngfile1}')
                            colorimg.save(pngfile1)
            
                        label = 'NSA ID: {}'.format(onegal['NSAID'].astype(str))
                        addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
                        #pdb.set_trace()
            
                    pngfiles.append(pngfile1)
            
                pngfile = os.path.join(paperdir, 'data', 'nsa', 'nsa-notin-sga-{}-{:02d}.png'.format(binlabel, ipage))
                print('Writing {}'.format(pngfile))
            
                cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
                cmd = cmd+' '.join([pngf for pngf in pngfiles])
                cmd = cmd+' {}'.format(pngfile)
                print(cmd)
                os.system(cmd)        
    
                pdb.set_trace()
    # --------------------------------------------------

    # make the QA -
    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        elif (x < 0) and (x >= -1):
            return '{:.1f}'.format(10**x)
        else:
            return '{:.2f}'.format(10**x)

    fig, ax = plt.subplots(figsize=(10, 7))

    xlim = (minrad, maxrad)
    ylim = (6.5, 26)
    I = np.where((nsa['ELPETRO_TH50_R'] > 0) * (nsa['ELPETRO_FLUX_R'] > 0))[0]
    corner.hist2d(np.log10(sersicfactor*nsa['ELPETRO_TH50_R'][I]/60), 
                  22.5-2.5*np.log10(nsa['ELPETRO_FLUX_R'][I]), 
                  levels=[0.1, 0.25, 0.5, 0.75, 0.95, 0.99],
                  #levels=[0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                  bins=75, smooth=True, ax=ax, color='k', #mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': 'k', 'alpha': 1.0, 'ms': 3, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k', 'alpha': 0.5}
                 )
    #ax.scatter(np.log10(m_nsa['ELPETRO_TH50_R']), m_nsa['BT'], s=1, color='red')
    #ax.scatter(np.log10(miss_nsa['ELPETRO_TH50_R']), miss_nsa['BT'], s=10, color=colors[2], marker='s', alpha=1)

    ax.set_xlabel(r'$\log_{10}\,(5\times r_{50,\mathrm{ElPetro}})$ [NSA, arcmin]')
    ax.set_ylabel(r'$m_{r,\mathrm{ElPetro}}$ [NSA]')
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(2))
    ax.xaxis.set_major_formatter(major_formatter)
    ax.set_xticks(np.log10([0.05, 0.2, 0.5, 1, 2, 5, 10, 19]))
    
    ax2 = ax.twinx()
    #for bb in bins:
    #    ax2.axvline(x=bb, color='orange', ls='-', alpha=1)
    ax2.axvline(x=np.log10(20/60), color=colors[2], ls='--', alpha=1)
    #ax2.axvline(x=np.log10(30/60), color=colors[0], ls='--', alpha=1)
    ax2.axhline(y=1.0, ls='--', lw=2, color=colors[2], alpha=1)
    ax2.step(xfrac+drad, yfrac, color=colors[3], ls='-', lw=3, where='pre')
    ax2.set_ylim(0, 1.05)
    ax2.set_ylabel('Fraction of SGA-NSA Matches')

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.subplots_adjust(bottom=0.14, right=0.85)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_z0mgs_completeness(sga, png=None):
    """Quantify the sample completeness by comparing against z0MGS."""

    import corner
    from glob import glob
    import astropy.units as u
    from astropy.table import vstack
    from astropy.coordinates import SkyCoord, match_coordinates_sky
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.3)

    # Find the subset of z0MGS targets which have grz imaging from DR9.
    z0mgsfile = os.path.join(paperdir, 'data', 'z0MGS-table4.fits')
    z0mgsdr9file = os.path.join(paperdir, 'data', 'z0MGS-table4.dr9.fits')
    if not os.path.isfile(z0mgsdr9file):
        z0mgs = Table(fitsio.read(z0mgsfile, ext=1))
        z0mgs.rename_column('_RAJ2000', 'RA')
        z0mgs.rename_column('_DEJ2000', 'DEC')
        print('Read {} objects from {}'.format(len(z0mgs), z0mgsfile))

        randomfiles = glob(os.path.join(paperdir, 'data', 'randoms-1-*.fits'))
        rand = []
        for randomfile in randomfiles:
            print('Reading {}'.format(randomfile))
            rand1 = fitsio.read(randomfile, columns=['NOBS_G', 'NOBS_R', 'NOBS_Z'])
            I = np.where((rand1['NOBS_G'] > 0) * (rand1['NOBS_R'] > 0) * (rand1['NOBS_Z'] > 0))[0]
            rand.append(Table(fitsio.read(randomfile, columns=['RA', 'DEC'], rows=I)))
        rand = vstack(rand)
        print('Read {:,d} random points from {} randomfiles.'.format(len(rand), len(randomfiles)))

        c_z0mgs = SkyCoord(z0mgs['RA']*u.deg, z0mgs['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        idx, d2d, _ = c_z0mgs.match_to_catalog_sky(c_rand)

        c_z0mgs = SkyCoord(z0mgs['RA']*u.deg, z0mgs['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        rad = 2 * u.arcmin
        _, indx_z0mgs, d2d, _ = c_z0mgs.search_around_sky(c_rand, rad)
        indx_z0mgs = np.sort(np.unique(indx_z0mgs))
        print('Matched {}/{} Z0MGS galaxies to a DR9 random point with NOBS_[GRZ]>1'.format(len(indx_z0mgs), len(z0mgs)))
    
        z0mgs_nodr9 = z0mgs[np.delete(np.arange(len(z0mgs)), indx_z0mgs)]

        z0mgs = z0mgs[indx_z0mgs]
        print(f'Writing {z0mgsdr9file}')
        z0mgs.write(z0mgsdr9file, overwrite=True)

        pngfile = os.path.join(paperdir, 'sandbox', 'qa-z0mgs-radec.png')
        print('Writing {}'.format(pngfile))
        fig, ax = plt.subplots(figsize=(10, 7))
        ax.scatter(sga['RA'], sga['DEC'], s=1, label='SGA')
        ax.scatter(z0mgs['RA'], z0mgs['DEC'], s=1, marker='s', alpha=0.5, label='z0MGS-DR9')
        ax.set_xlabel('RA (degree)')
        ax.set_ylabel('Dec (degree)')
        ax.legend(fontsize=12)
        fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    pdb.set_trace()

    # read the previously created matched catalog
    hecate = Table(fitsio.read(hecatedr9file, ext=1))
    print('Read {:,d} objects from {}'.format(len(hecate), hecatedr9file))

    #toss = np.where(np.isnan(hecate['R1']))[0]
    #pdb.set_trace()

    keep = np.where(np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    print('Removing {} HECATE objects with no diameters.'.format(len(hecate)-len(keep)))
    #keep = np.where(np.isfinite(hecate['BT']) * np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    #print('Removing {} HECATE objects with no diameters or magnitudes estimate.'.format(len(hecate)-len(keep)))
    hecate = hecate[keep]
    hecate['BA'] = hecate['R2'] / hecate['R1']

    # Match the catalogs, first by PGC.
    dwarfs_excluded = {
        'SagittariusdSph': 4689212,
        'SegueI': 4713559,
        'UrsaMajorII': 4713555,
        'BootesII': 4713552,
        'SegueII': 4713565,
        'Willman1': 4713556,
        'BootesI': 4713553,
        'Draco': 60095,
        'UrsaMinor': 54074,
        'SextansI': 88608,
        'UrsaMajorI': 4713554,
        'Hercules': 4713560,
        'LeoIV': 4713561,
        'LeoV': 4713563,
        'PiscesII': 5056949,
        'CanesVenaticiI': 4689223,
        'AndromedaXIV': 5056922,
        'AndromedaXIII': 5056925,
        'AndromedaII': 4601,
        'AndromedaXXIX': 5060430,
        'AndromedaXXII': 5057232,
        'AndromedaXVI': 5056927,
        'LeoT': 4713564,
        'ComaBerenices': -1, 
        'CanesVenaticiII': 4713558,
        'AndromedaXX': 5056920,
        'Antlia': 29194,
        'Carina': 19441,
        'AndromedaX': 5056921,
        'AndromedaIX': 4689222,
        'AndromedaXVII': 4608690,
        'AndromedaXXVII': 5057230,
        'AndromedaXXV': 5057228,
        'AndromedaI': 2666,
        'AndromedaIII': 2121,
        'AndromedaXV': 5056926,
        'AndromedaXII': 5056924,
        'AndromedaXI': 5056923,
        'AndromedaXXVI': 5057229,
        'AndromedaXIX': 5056919,
        'AndromedaXXI': 5057231,
        'AndromedaXVIII': 5056918,
        'AndromedaXXIV': 5057227,
        'AndromedaXXIII': 5057226,
        'AndromedaV': 3097824,
        'AndromedaVII': 2807155,
        'Aquarius': 65367,
        'Sculptor': 3589,
        'Fornax': 10074,}
    dwarfs_toadd = {
        'AndromedaVI': 2807158,
        'AndromedaXXVIII': 5060429,
        }
    for thisdwarf in dwarfs_toadd.keys():
        I = np.where(sga['GALAXY'] == thisdwarf)[0]
        if len(I) == 1:
            #print(f'Matching {thisdwarf}')
            sga['PGC'][I] = dwarfs_toadd[thisdwarf]

    openngc_toadd = {
        'IC0028': 169992,
        'IC0036': 138202,
        'IC0113': 3617669,
        'IC0233': 9622,    # incorrectly matches to CGCG388-033 rather than CGCG388-036 in Hyperleda
        'IC0254': 3642494, # incorrectly matches to NGC1065
        'IC0463': 3717953,
        'IC0495': 22841,
        'IC0694': 35326,
        'IC0729': 36627,
        'IC0828': 3797579,
        'IC0921': 2509643,
        'IC0931': 2508641,
        'IC1188B': 1533342,
        'IC1249': 59919,
        'IC1464A': 70345,
        'IC1586': 2813,
        'IC1632': 4205,
        'IC1640': 4299,
        'IC1726': 6441,
        'IC1758': 170024,
        'IC1798': 3637647,
        'IC2155': 4078729,
        'IC2186': 3089868, # incorrectly matches to IC2186 in Hyperleda
        'IC2249': 23202,
        'IC2519': 28660,
        'IC2614': 3764519,
        'IC2615': 33289,
        'IC2619': 33297,
        'IC2657': 3768035,
        'IC2676': 3471217,
        'IC2677': 4000604,
        'IC2690': 4272707,
        'IC2719': 3542421,
        'IC2753': 3471719,
        'IC2765': 1451814, # incorrectly matches to IC2769
        'IC2771': 4000783,
        'IC2775': 1410888,
        'IC2779': 1428682, # incorrectly matches to IC2779
        'IC2802': 1405555,
        'IC2807': 4278777,
        'IC2821': 3770960,
        'IC2838': 3090746,
        'IC2847': 3771421,
        'IC2858': 3771590,
        'IC2860': 3771626,
        'IC2886': 3543729,
        'IC2900': 5490323,
        'IC2909': 1394107,
        'IC2917': 1386736,
        'IC2946': 35984,
        'IC2993': 3088758, # incorrect coordinates / object in Hyperleda for IC2993
        'IC3110': 3088320,
        'IC3128B': 39557,
        'IC3179': 89585,
        'IC3249': 3787857,
        'IC3287': 4662912,
        'IC3304': 4325635,
        'IC3324': 3788758,
        'IC3345': 3789023,
        'IC3372': 89606,
        'IC3389': 3789672,
        'IC3396': 3789798,
        'IC3449': 89615,
        'IC3479': 89618,
        'IC3494': 1812401,
        'IC3528': 41882,
        'IC3558': 165253,
        'IC3565': 1787382,
        'IC3582': 1768338, # =WISEA J123636.95+261405.0; incorrect match in Hyperleda
        'IC3603': 3090633,
        'IC3610': 1790902,
        'IC3614': 1770479,
        'IC3649': 1642864,
        'IC3655': 1633163,
        'IC3657': 4337363,
        'IC3678': 1637920,
        'IC3723': 42914,
        'IC3751': 3088212,
        'IC3761': 1622809,
        'IC3771': 5168314,
        'IC3785': 3796270,
        'IC3817': 1676864,
        'IC3842': 3088021,
        'IC3847': 86330,
        'IC3870': 1668852,
        'IC3872': 3798227,
        'IC3897': 3088119,
        'IC3898': 3088328,
        'IC3928': 2165833,
        'IC3945': 3799582,
        'IC3948': 1698944,
        'IC3954': 3799842,
        'IC3978': 4350039,
        'IC3994': 4350163,
        'IC4018': 3800150,
        'IC4025': 3800326,
        'IC4031': 3800266,
        'IC4063': 6032708,
        'IC4085': 3088120,
        'IC4087': 3800931,
        'IC4110': 3801248,
        'IC4140': 3801648,
        'IC4147': 4662909,
        'IC4162': 6400595,
        'IC4184': 3088122,
        'IC4277': 4662915,
        'IC4284': 2287260,
        'IC4285': 2287732,
        'IC4300': 47912,
        'IC4516': 53274,
        'IC4568': 55746,
        'IC5126': 3947737,
        'IC5153': 3954514,
        'IC5299': 3978734,
        'IC5307': 214932, #=IC5306 in Hyperleda, which is wrong; actually WISEA J231822.02+101408.5
        'IC5341': 71981,
        'NGC0382': 3981, # terrible coordinates!
        'NGC0396': 99944,
        'NGC0526A': 5120, #=NGC0526
        'NGC0742': 7264,
        'NGC0826': 8230,
        'NGC1392': 13383,
        'NGC2288': 19714,
        'NGC2687A': 25031,
        'NGC2735A': 25402,
        'NGC3099': 29087,
        'NGC3439': 32634,
        'NGC4465': 41157,
        'NGC5581': 51282,
        'NGC5615': 51435,
        'NGC5679C': 52129, # confusion in the viewer
        'NGC5763': 52905,
        'NGC5896': 54367,
        'NGC6027D': 56580,
        'NGC6099': 57640,
        'NGC6141': 3498497,
        'NGC6452': 60876,
        'NGC6534': 61126,
        'NGC7405': 69907,
        'NGC7551': 3978375,
        'NGC7577': 70947,
        'NGC7598': 71011
        }
    check = []
    for thisgal in openngc_toadd.keys():
        I = np.where(sga['GALAXY'] == thisgal)[0]
        check.append(I)
        sga['PGC'][I] = openngc_toadd[thisgal]
    check = np.hstack(check)
    #pdb.set_trace()

    indx_sga, indx_hecate = [], []
    for I, pgc in enumerate(hecate['PGC']):
        J = np.where(pgc == sga['PGC'])[0]
        #if pgc == 70761:
        #    pdb.set_trace()
        if len(J) > 1:
            pdb.set_trace()
        if len(J) == 1:
            indx_hecate.append(I)
            indx_sga.append(J)
    indx_hecate = np.hstack(indx_hecate)
    indx_sga = np.hstack(indx_sga)
    print('Matched {}/{} HECATE galaxies to the SGA based on PGC number.'.format(
        len(indx_hecate), len(hecate)))

    # classify based on the montage visual inspections
    hecate['SGA_NOTES'] = np.zeros(len(hecate), int) # np.zeros(len(hecate), 'U20')
    for thisdwarf in dwarfs_excluded.keys():
        I = np.where(hecate['PGC'] == dwarfs_excluded[thisdwarf])[0]
        if len(I) != 1:
            #print(f'Skipping {thisdwarf}')
            #pdb.set_trace()
            pass
        hecate['SGA_NOTES'][I] += 2**0 # intentionally excluded dwarf

    spurgal = [
        # >1.6 arcmin
        'SDSSJ075442.90+472212.6', 'SDSSJ074540.08+204602.5', 'SDSSJ112014.08+092415.9',
        'SDSSJ025709.46+002421.5', '[IBG2003]J130047+280534', 'SDSSJ023647.34-001301.0',
        '[CTM2011]1040263', 'LAMOSTJ085931.49+445506.4', #'SDSSJ1049+5103',
        'SDSSJ075442.90+472212.6', 'PGC3097827', 'GAMA575344', 'SDSSJ041004.59-045626.3', 
        'SDSSJ095021.71+451957.5', 'AGC125044', # AGC125044 is Cirrus!
        'SDSSJ152444.99+401648.2', 'SDSSJ112535.23+542314.3', 
        # 1.0-1.6 arcmin
        'SDSSJ012626.40-002539.4', 'SDSSJ012651.26+203017.0', 'GAMA418176', 
        'SDSSJ144554.93+003437.6', '[RG2008]J163025.15+395443.9', 'GAMA177469',
        'SDSSJ232735.95+313026.5', 'PGC2800817', 'SDSSJ155520.30+091146.4',
        'PGC086618']
    #print('Flagging {} spurious HECATE galaxies with >1 arcmin.'.format(len(spurgal)))
    for gal in spurgal:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**1 # spurious in Hecate

    # real, but (sometimes very) wrong diameter; should be added to the catalog
    wrongdiam = [
        # >1.6 arcmin
        'AGC749279', 'AGC102561', 'SDSSJ004535.04-011221.9', 'PGC029167', 
        'SDSSJ111332.35+225056.9', 'PGC012625', 'PGC018515', 'SDSSJ161534.10+192734.8',
        'AGC334637', 'AGC336814', 'SDSSJ220611.97+010300.5', 'AGC113894',
        '2MASXJ07271454+5256550', 'PGC002635', 'PGC059944', 
        'PGC4080601', 
        # 1.0-1.6 arcmin
        'PGC055315', 'GAMA143116', 'PGC040476', 'SDSSJ031229.59+000242.1', 
        'AGC268225', 'GAMA086047', 'SDSSJ134211.37+180153.6', 'SDSSJ124959.36+451011.2', 
        'SDSSJ114345.66+661335.7', 'AGC238692', 'SDSSJ160116.48+185821.3', 
        'SDSSJ094353.03+490037.7', 'AGC188957', 'AGC225847', 'AGC336486', 
        'SDSSJ032310.22-004407.9', 'AGC215425', 'AGC189323', 'SDSSJ100519.69+511038.3',
        'AGC267971', 'SDSSJ031929.80+003938.7', 'SDSSJ001842.92+003016.4',
        'AGC323553', 'SDSSJ131641.09+301454.4', 'SDSSJ103917.89+372810.6', 
        'AGC322201', 'SDSSJ092603.64+560915.5', 'PGC138144', 'AGC333267',
        'AGC334490', 'SDSSJ095034.31+300927.5', 'AGC333442', 'LAMOSTJ012612.76+294146.3',
        'SDSSJ230314.76+045751.4', 'PGC052336', '[RG2008]J162824.61+392054.6',
        'SDSSJ162256.84-004843.5', 'PGC019078', 'SDSSJ144751.43+172337.1', 
        'ESO474-017', 'PGC4677061', 'PGC061508', 'SDSSJ145746.73-003828.8',
        'PGC015227', 'SDSSJ160959.42+264326.8', 'SDSSJ101821.81+144859.3',
        'WINGSJ011321.46+001504.1']
    #print('Flagging {} HECATE galaxies with incorrect (over-estimated) diameters >1 arcmin.'.format(len(wrongdiam)))
    for gal in wrongdiam:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**2 # very wrong diameter in Hecate

    shred = [
        # >1.6 arcmin
        'LAMOSTJ013040.21-035637.1', 'LAMOSTJ124211.85+323232.3', 'SDSSJ100818.18+315206.6',
        'SDSSJ131318.46+361210.6', 'PGC014118', 'SDSSJ114347.41+195830.2', 'LAMOSTJ142026.93+351032.3',
        'SDSSJ002024.55+004917.5', 'SDSSJ134748.65+402918.7', 'LAMOSTJ005442.06+213126.7',
        'SDSSJ231412.61+133454.6', 'LAMOSTJ003719.70+290838.1', 'SDSSJ231445.28+052457.9',
        'SDSSJ121855.02+142445.5', 'LAMOSTJ122300.91+155115.8', 
        # 1.0-1.6 arcmin
        'LAMOSTJ112914.16+203452.0', 'SDSSJ131238.07+123534.5', 'NGC6166B', 'SDSSJ143001.69+362129.5',
        'PGC095735', 'SDSSJ110310.51+275851.0', 'PGC032137', 
        'SDSSJ023038.41-034915.6', 'EVCC2264', 'PGC047447', '2MASXJ03422921-1328208',
        'SDSSJ131239.57+123645.0', 'LAMOSTJ091102.92+132455.3',
        'LAMOSTJ020628.06+270207.9', 'SDSSJ094829.55+332459.3', 'PGC3099123',
        '6dFJ0122428-363451', 'PGC093084', '2MASXJ21130957-5826044',
        'SDSSJ123421.43+081425.7', 'PGC3295899', 'SDSSJ115338.84+432720.0', 'PGC200231',
        '2MASXJ10330652-2625169', 'SDSSJ144822.72+182112.2', 'SDSSJ075237.34+502415.6',
        'SDSSJ145256.78+164334.8', '2MASXJ16080647+2529073', 'LAMOSTJ090559.16+184546.3',
        '2MASXJ14574467-0722033', 
        'SDSSJ152132.22+391207.0', '2MASXJ09474970+1551068', 'SDSSJ164802.45+261234.3',
        'PGC3084812', 'LAMOSTJ021112.67+254848.2', 'SDSSJ082027.55+564457.1',
        'PGC093106', 'GAMA084601', 'SDSSJ211444.79+105220.5', 'SDSSJ151806.36+424438.6', 
        'SDSSJ163813.00+415623.0', 'SDSSJ080138.73+154249.2',
        'SDSSJ082648.24+202140.3', 'PGC200388', 'PGC052728', '2MASXJ05571929-5222215',
        'SDSSJ014932.34+323510.2', 'SDSSJ132202.37+384343.7', 'SDSSJ155722.48+470943.9',
        'SDSSJ115742.61+321702.7', 'SDSSJ133955.41+282344.3', 'SDSSJ081200.34+192147.4',
        'SDSSJ140021.15+385504.2', 'SDSSJ111523.25+555826.6',
        'SDSSJ111523.25+555826.6', 'SDSSJ141013.85+481833.8', 'SDSSJ145736.82+295757.3',
        '2MASXJ21150892+1239317', 'SDSSJ122147.59+042938.4', 'LAMOSTJ091005.24+443651.3',
        'SDSSJ141843.21+214858.0', 'SDSSJ090919.38+330723.6', 'SDSSJ093654.40+374130.6',
        'NGC0664:[ZM98]0009', 'LAMOSTJ020913.56+253410.9']
    #print('Flagging {} HECATE galaxies as photometric shreds and >1 arcmin.'.format(len(shred)))
    for gal in shred:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**3 # photometric shred

    grzmissing = [
        # >1.6 arcmin
        'NGC2258', 'ESO567-026', 'NGC6555', 'NGC2889', 'ESO437-022', 'ESO108-021', 
        'ESO501-011', 'IC2586', 'NGC7485', 
        # 1.0-1.6 arcmin
        'PGC033167', 'ESO233-037', 'PGC035743', 'IC0416', 'UGC09668', 
        'PGC027066', 'ESO106-002', 'ESO567-010', 'UGC11581', 
        'ESO340-016', 'PGC065019', 'UGC03823', 'NGC6972', 'ESO437-040',
        'ESO501-024', 'ESO501-042', 'NGC2881', '2MASXJ03500035-0127578',
        'PGC032846', 'UGC00457', 'PGC018467', 'ESO340-019', 'PGC015573',
        'PGC027757', 'ESO342-012', 'ESO409-016', 'ESO437-029', 'ESO500-043',
        'ESO567-012', 'PGC027188', 'UGC10780', 'ESO344-003', '2MASXJ21094981-0850538',
        'PGC035744']
    #print('Flagging {} HECATE galaxies with missing LS/DR9 grz imaging and >1 arcmin.'.format(len(grzmissing)))
    for gal in grzmissing:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**4 # missing grz coverage

    m_sga = sga[indx_sga]
    m_hecate = hecate[indx_hecate]

    miss_sga = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
    miss_hecate = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]

    # quick QA of the separation for PGC-matched and PGC-non-matched galaxies
    c_m_hecate = SkyCoord(m_hecate['RA']*u.deg, m_hecate['DEC']*u.deg)
    c_m_sga = SkyCoord(m_sga['RA']*u.deg, m_sga['DEC']*u.deg)
    _, m_sep2d, _ = c_m_hecate.match_to_catalog_sky(c_m_sga)
    print('Mean and max separation between {} PGC-matched galaxies is {:.3f}+/-{:.3f}, {:.3f} arcsec.'.format(
        len(m_hecate), np.mean(m_sep2d.arcsec), np.std(m_sep2d.arcsec), np.max(m_sep2d.arcsec)))
    print('Objects where separation >10 arcsec.')
    I = m_sep2d.arcsec > 10
    info = m_sga[I]['GALAXY', 'PGC', 'RA', 'DEC', 'D26']
    info['SEP'] = m_sep2d.arcsec[I]
    print(info[np.argsort(info['SEP'])[::-1]])

    c_miss_hecate = SkyCoord(miss_hecate['RA']*u.deg, miss_hecate['DEC']*u.deg)
    c_miss_sga = SkyCoord(miss_sga['RA']*u.deg, miss_sga['DEC']*u.deg)
    _, miss_sep2d, _ = c_miss_hecate.match_to_catalog_sky(c_miss_sga)
    
    pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-sga2020-separation.png')
    print('Writing {}'.format(pngfile))
    fig, ax = plt.subplots(figsize=(10, 7))
    _ = ax.hist(np.log10(m_sep2d.arcsec), bins=75, label='PGC-matched')
    _ = ax.hist(np.log10(miss_sep2d.arcsec), bins=75, alpha=0.5, label='PGC not-matched')
    ax.set_xlabel(r'$\log_{10}\,(\mathrm{HECATE-SGA\ Separation})$ (arcsec)')
    ax.set_ylabel('Number of Galaxies')
    ax.set_yscale('log')
    ax.axvline(x=np.log10(10), ls='--', color='k')
    ax.legend(fontsize=14)
    fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95, left=0.17)
    fig.savefig(pngfile)#, bbox_inches='tight')
    plt.close(fig)

    # now try to match a few more using coordinates
    rad = 3.0
    if False:
        from pydl.pydlutils.spheregroup import spherematch
        indx_miss_hecate, indx_miss_sga, sep = spherematch(miss_hecate['RA'], miss_hecate['DEC'], miss_sga['RA'], 
                                                           miss_sga['DEC'], rad/3600., maxmatch=1)
    else:
        indx_miss_hecate, indx_miss_sga, d2d, _ = c_miss_sga.search_around_sky(c_miss_hecate, rad*u.arcsec)
    print('Found {:,d}/{:,d} additional SGA-HECATE matches within {} arcsec.'.format(
        len(indx_miss_hecate), len(miss_hecate), rad))
    assert(len(indx_hecate) == len(np.unique(indx_hecate)))

    m_sga = vstack((m_sga, miss_sga[indx_miss_sga]))
    m_hecate = vstack((m_hecate, miss_hecate[indx_miss_hecate]))

    miss_hecate.remove_rows(indx_miss_hecate)
    miss_sga.remove_rows(indx_miss_sga)

    print('Final sample: {}/{} ({:.2f}%) HECATE-SGA matches.'.format(
        len(m_hecate), len(hecate), 100*len(m_hecate)/len(hecate)))

    # get the raw and corrected fraction of non-matches as a function of SERSIC_TH50
    lograd = np.log10(2*hecate['R1'])
    match_lograd = np.log10(2*m_hecate['R1'])
    lograd_corrected = np.log10(2*hecate['R1'][hecate['SGA_NOTES'] == 0])
    minrad, maxrad, drad = -1.4, 1.2, 0.2
    ##minrad, maxrad = np.min(lograd), np.max(lograd)

    nhist = int(np.ceil((maxrad - minrad) / drad))
    #histobins = np.histogram_bin_edges(match_lograd, bins=nhist, range=(minrad, maxrad))
    histobins = np.array([-1.4, -1.2, -1. , -0.8, -0.6, -0.4,
                          -0.2, 0., 0.2, 0.4, 0.6, 0.8, 1., 1.2])
    #histobins = np.array([-1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4,
    #                      -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,
    #                      0.8,  0.9,  1. ,  1.1,  1.2,  1.3])
    bins = histobins[:-1]

    #bins = np.arange(minrad, maxrad, drad) # bin left edges
    numer, _ = np.histogram(match_lograd, bins=histobins)
    denom, _ = np.histogram(lograd, bins=histobins)
    #denom, _ = np.histogram(lograd, bins=len(bins), range=(minrad, maxrad+drad))
    denom_corrected, _ = np.histogram(lograd_corrected, bins=histobins)

    good = denom > 0
    xfrac = bins[good]
    yfrac = numer[good] / denom[good] 
    yfrac_corrected = numer[good] / denom_corrected[good] 
    for ii, (bb, nn, dd, dd_corr) in enumerate(zip(bins, numer, denom, denom_corrected)):
        print(bb, 10**bb, nn, dd, nn/dd, dd-nn, dd_corr, nn/dd_corr, dd-nn, dd_corr-nn)
        # np.sum((lograd>bb)*(lograd<(bb+drad))))

    # --------------------------------------------------
    # HECATE galaxies not in the SGA
    #_logradcut = 0.2
    #I = bins >= _logradcut
    #print('There are {} HECATE galaxies not in the SGA larger than {:.1f} arcmin.'.format(
    #    np.sum(denom[I]-numer[I]), 10**_logradcut))
    logradcut = 0.0

    hecate_notin_sga = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]
    srt = np.argsort(hecate_notin_sga['R1'])[::-1]
    hecate_notin_sga = hecate_notin_sga[srt]

    #print('Flagging {} HECATE galaxies which are intentionally-excluded dwarfs.'.format(
    #    np.sum(hecate_notin_sga['SGA_NOTES'] & 2**0 != 0)))

    I = np.log10(2 * hecate_notin_sga['R1']) >= logradcut
    J = (hecate_notin_sga['SGA_NOTES'] == 0) * (np.log10(2 * hecate_notin_sga['R1']) >= logradcut)

    Itot = np.log10(2 * hecate['R1']) >= logradcut
    Jtot = (hecate['SGA_NOTES'] == 0) * (np.log10(2 * hecate['R1']) >= logradcut)

    print('There are {}/{} ({:.2f}%) raw -- {}/{} ({:.2f}%) corrected -- HECATE galaxies not in the SGA larger than {:.1f} arcmin.'.format(
        np.sum(I), np.sum(Itot), 100*np.sum(I)/np.sum(Itot), np.sum(J), np.sum(Jtot), 100*np.sum(J)/np.sum(Jtot), 10**logradcut))

    #I = np.log10(2 * hecate_notin_sga['R1']) >= logradcut
    I = (np.log10(2 * hecate_notin_sga['R1']) >= logradcut) * (np.log10(2 * hecate_notin_sga['R1']) <= 0.2)
    qa = hecate_notin_sga[I]['PGC', 'R1', 'RA', 'DEC', 'SGA_NOTES', 'OBJNAME']
    qa = qa[np.argsort(qa['R1'])] # smallest to biggest
    qa['URL'] = ['https://www.legacysurvey.org/viewer-desi?ra={}&dec={}&layer=ls-dr9&zoom=14&sga-parent&sga'.format(
        ra, dec) for ra, dec in zip(qa['RA'], qa['DEC'])]
    #qa[::-1][198:]

    print('Galaxies with 2*R1 > 1 arcmin in HECATE missing from the SGA:')
    for bit, label in zip([1, 2, 4, 8, 16], ['Intentionally excluded dwarfs: ',
                                             'Spurious galaxies: ',
                                             'Incorrect diameter: ',
                                             'Photometric shred: ',
                                             'Gap in grz coverage: ']):
        print('  Bit {}: {} {}'.format(bit, label, np.sum(np.log10(2 * hecate_notin_sga[hecate_notin_sga['SGA_NOTES'] == bit]['R1'].data) >= 0)))

    # investigate the galaxies which are in the SGA but not in Hecate
    if False:
        sga_notin_hecate = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
        srt = np.argsort(sga_notin_hecate['D26'])[::-1]
        sga_notin_hecate = sga_notin_hecate[srt]['SGA_ID', 'GALAXY', 'RA', 'DEC', 'PGC', 'D25_LEDA', 'D26', 'Z_LEDA']
    
        I = ((sga_notin_hecate['Z_LEDA'] > -1) * (sga_notin_hecate['Z_LEDA'] <= 0.047))
        Itot = ((sga['Z_LEDA'] > -1) * (sga['Z_LEDA'] <= 0.047))
        print(np.sum(I), np.sum(Itot), np.sum(I) / np.sum(Itot))
        sga_notin_hecate[I]

    remake_montage = False
    if remake_montage:
        montagedir = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga')
        if not os.path.isdir(montagedir):
            os.makedirs(montagedir, exist_ok=True)
        
        pixscale = 1.0 # 0.262
        barlen = np.ceil(60 / pixscale) # [pixels]
        barlabel = '' # '30 arcsec'

        coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)

        # split into diameter bins
        for ibin in np.arange(len(bins)):
            minbin, maxbin = histobins[ibin], histobins[ibin+1]
            print(ibin, minbin, maxbin)
            if minbin < logradcut:
                continue

            binlabel = '{:.1f}-{:.1f}arcmin'.format(10**minbin, 10**maxbin)

            dhecate = np.log10(2 * hecate_notin_sga['R1'])
            if ibin == len(bins)-1:
                B = np.where(dhecate >= minbin)[0]
            else:
                B = np.where((dhecate >= minbin) * (dhecate < maxbin))[0]

            if len(B) == 0:
                pdb.set_trace()

            if len(B) >= 100:
                ncol, nrow = 10, 10
            elif len(B) >= 49 and len(B) < 100:
                ncol, nrow = 7, 7
            elif len(B) >= 25 and len(B) < 49:
                ncol, nrow = 5, 5
            else:
                ncol, nrow = 5, 5

            ngal = ncol * nrow

            hecate_notin_sga_bin = hecate_notin_sga[B]

            # find near SGA sources, if any
            coord_hecate_notin_sga = SkyCoord(ra=hecate_notin_sga_bin['RA']*u.deg, dec=hecate_notin_sga_bin['DEC']*u.deg)
        
            # split into multiple pages
            Isplit = np.array_split(np.arange(len(hecate_notin_sga_bin)), np.ceil(len(hecate_notin_sga_bin)/ngal).astype(int))
            npage = len(Isplit)
            print(f'Splitting into {npage} pages with {ngal} galaxies per page.')

            for ipage, I in enumerate(Isplit):
                print('Working on page {}/{} with {} galaxies.'.format(ipage+1, npage, len(I)))

                sga_close = []
                for coord_hecate_notin_sga1, diam in zip(coord_hecate_notin_sga[I], 2*60*hecate_notin_sga_bin['R1'][I]):
                    sep = coord_hecate_notin_sga1.separation(coord_sga)
                    close = sep.arcsec < 2*diam
                    if np.any(close):
                        sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
                    else:
                        sga_close.append(Table())

                pngfiles = []
                for onegal, onesga in zip(hecate_notin_sga_bin[I], sga_close):
                    #pdb.set_trace()
                    jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['OBJNAME']))
                    width = int(2.5 * 2*onegal['R1']*60 / pixscale)
                    if width == 0:
                        pdb.set_trace()

                    if not os.path.isfile(jpgfile):
                        urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                            onegal['RA'], onegal['DEC'], pixscale, width, width)
                        cmd = f'wget -q -O {jpgfile} {urlfile}'
                        print(cmd)
                        subprocess.call(cmd.split())
            
                    pngfile1 = jpgfile.replace('.jpg', '.png')
                    if not os.path.isfile(pngfile1):
                        with Image.open(jpgfile) as colorimg:
                            imgsz = colorimg.size
            
                            hdr = fits.Header()
                            hdr['NAXIS'] = 2
                            hdr['NAXIS1'] = imgsz[0]
                            hdr['NAXIS2'] = imgsz[0]
                            hdr['CTYPE1'] = 'RA---TAN'
                            hdr['CTYPE2'] = 'DEC--TAN'
                            hdr['CRVAL1'] = onegal['RA']
                            hdr['CRVAL2'] = onegal['DEC']
                            hdr['CRPIX1'] = imgsz[0]/2+0.5
                            hdr['CRPIX2'] = imgsz[0]/2+0.5
                            hdr['CD1_1'] = -pixscale/3600
                            hdr['CD1_2'] = 0.0
                            hdr['CD2_1'] = 0.0
                            hdr['CD2_2'] = +pixscale/3600
                            wcs = WCS(hdr)
                    
                            try:
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                                                    onegal['PA'], 2*onegal['R1']*60, 
                                                    pixscale, color='red', linewidth=2)
                            except:
                                pdb.set_trace()

                            # add the SGA sources, if any
                            if len(onesga) > 0:
                                for onesga1 in onesga:
                                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                                        color='dodgerblue', linewidth=2)
            
                            print(f'Writing {pngfile1}')
                            colorimg.save(pngfile1)
            
                        label = onegal['OBJNAME']
                        addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
                        #pdb.set_trace()
            
                    pngfiles.append(pngfile1)
            
                pngfile = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga-{}-{:02d}.png'.format(binlabel, ipage))
                print('Writing {}'.format(pngfile))
            
                cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 512x512 '.format(ncol, nrow)
                cmd = cmd+' '.join([pngf for pngf in pngfiles])
                cmd = cmd+' {}'.format(pngfile)
                print(cmd)
                os.system(cmd)        
    
                #pdb.set_trace()
    # --------------------------------------------------

    # make the QA -
    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        elif (x < 0) and (x >= -1):
            return '{:.1f}'.format(10**x)
        else:
            return '{:.2f}'.format(10**x)

    fig, ax = plt.subplots(figsize=(10, 7))

    xlim = (minrad, maxrad)
    ylim = (6, 26)
    I = np.isfinite(hecate['BT'])
    corner.hist2d(np.log10(2*hecate['R1'][I]), hecate['BT'][I],
                  levels=[0.1, 0.25, 0.5, 0.75, 0.95, 0.99],
                  #levels=[0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                  bins=75, smooth=True, ax=ax, color='k', #mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': 'k', 'alpha': 1.0, 'ms': 3, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k', 'alpha': 0.5}
                 )
    ax.set_xlabel(r'$\log_{10}\,(2\times R_{1})$ (HECATE, arcmin)')
    ax.set_ylabel(r'$b_{\mathrm{t}}$ (Vega, HECATE)')
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(2))
    ax.xaxis.set_major_formatter(major_formatter)
    ax.set_xticks(np.log10([0.05, 0.2, 0.5, 1, 2, 5, 9, 15]))
    ax.margins()
    
    ax2 = ax.twinx()
    for ii, bb in enumerate(bins):
        #ax2.axvline(x=bb, color='orange', ls='-', alpha=1)
        if bb > -10:#-0.6:
            ax2.text(xfrac[ii]+drad/2, yfrac_corrected[ii]+0.03, 
                     '{:,d}'.format(denom[ii]), ha='center', va='bottom', 
                     alpha=1.0, fontsize=10)
    #ax2.axvline(x=np.log10(20/60), color='gray', ls='-', alpha=0.7)
    #ax2.axvline(x=np.log10(30/60), color='gray', ls='-', alpha=0.7)
    ax2.axhline(y=1.0, ls='-', lw=2, color='gray', alpha=0.7)
    ax2.step(xfrac+drad, yfrac_corrected, color=colors[4], ls='-', lw=3, where='pre',
             label='Corrected Fraction')
    ax2.step(xfrac+drad, yfrac, color=colors[3], ls='--', lw=3, where='pre', 
             label='Raw Fraction')
    ax2.set_ylim(0, 1.1)
    hh, ll = ax2.get_legend_handles_labels()
    ax2.legend([hh[1], hh[0]], [ll[1], ll[0]], loc='lower right', fontsize=14) # frameon=False, 
    #ax2.legend(loc='lower right', fontsize=14)
    ax2.margins()
    ax2.set_ylabel('Fraction of SGA-HECATE Matches', rotation=270, labelpad=35)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_hecate_completeness(sga, png=None):
    """Quantify the sample completeness by comparing against HECATE."""

    import corner
    from glob import glob
    import astropy.units as u
    from astropy.table import vstack
    from astropy.coordinates import SkyCoord, match_coordinates_sky
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.3)

    # Find the subset of HECATE targets which have grz imaging from DR9.
    hecatefile = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.fits')
    hecatedr9file = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.dr9.fits')
    hecatenodr9file = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.nodr9.fits')
    if not os.path.isfile(hecatedr9file):
        hecate = Table(fitsio.read(hecatefile, ext=1))
        print('Read {} objects from {}'.format(len(hecate), hecatefile))

        ## match to the MW dwarf catalog, which we will handle below
        #dwarffile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'SGA-dwarfs.fits')
        #print('Reading {}'.format(dwarffile))
        #dwarfs = Table(fitsio.read(dwarffile))
        #
        #c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        #c_dwarfs = SkyCoord(dwarfs['RA']*u.deg, dwarfs['DEC']*u.deg)
        #
        #indx_hecate, indx_dwarfs, d2d, _ = c_dwarfs.search_around_sky(c_hecate, 120*u.arcsec)
        #miss_dwarfs = dwarfs[np.delete(np.arange(len(dwarfs)), indx_dwarfs)]
        #print('Note: HECATE is missing {}/{} of the MW Dwarfs from McConnachie+2012 within 1 arcmin'.format(len(miss_dwarfs), len(dwarfs)))

        #_, sep2d, _ = c_hecate.match_to_catalog_sky(c_dwarfs)
        #pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-mwdwarfs-separation.png')
        #print('Writing {}'.format(pngfile))
        #fig, ax = plt.subplots(figsize=(10, 7))    
        #_ = ax.hist(sep2d.arcmin, bins=100)#, range=(0, 30))
        #fig.savefig(pngfile)#, bbox_inches='tight')

        randomfiles = glob(os.path.join(paperdir, 'data', 'randoms-1-*.fits'))
        rand = []
        for randomfile in randomfiles:
            print('Reading {}'.format(randomfile))
            rand1 = fitsio.read(randomfile, columns=['NOBS_G', 'NOBS_R', 'NOBS_Z'])
            I = np.where((rand1['NOBS_G'] > 0) * (rand1['NOBS_R'] > 0) * (rand1['NOBS_Z'] > 0))[0]
            rand.append(Table(fitsio.read(randomfile, columns=['RA', 'DEC'], rows=I)))
        rand = vstack(rand)
        print('Read {:,d} random points from {} randomfiles.'.format(len(rand), len(randomfiles)))

        c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        idx, d2d, _ = c_hecate.match_to_catalog_sky(c_rand)

        c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        rad = 2 * u.arcmin
        _, indx_hecate, d2d, _ = c_hecate.search_around_sky(c_rand, rad)
        indx_hecate = np.sort(np.unique(indx_hecate))
        print('Matched {}/{} HECATE galaxies to a DR9 random point with NOBS_[GRZ]>1'.format(len(indx_hecate), len(hecate)))
    
        hecate_nodr9 = hecate[np.delete(np.arange(len(hecate)), indx_hecate)]

        hecate = hecate[indx_hecate]
        print(f'Writing {hecatedr9file}')
        hecate.write(hecatedr9file, overwrite=True)

        print(f'Writing {hecatenodr9file}')
        hecate_nodr9.write(hecatenodr9file, overwrite=True)

        pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-dr9-radec.png')
        print('Writing {}'.format(pngfile))
        fig, ax = plt.subplots(figsize=(10, 7))
        ax.scatter(sga['RA'], sga['DEC'], s=1, label='SGA')
        ax.scatter(hecate['RA'], hecate['DEC'], s=1, marker='s', alpha=0.5, label='HECATE-DR9')
        ax.scatter(hecate_nodr9['RA'], hecate_nodr9['DEC'], s=1, marker='s', label='HECATE - outside DR9')
        ax.set_xlabel('RA (degree)')
        ax.set_ylabel('Dec (degree)')
        ax.legend(fontsize=12)
        fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    # read the previously created matched catalog
    hecate = Table(fitsio.read(hecatedr9file, ext=1))
    print('Read {:,d} objects from {}'.format(len(hecate), hecatedr9file))

    #toss = np.where(np.isnan(hecate['R1']))[0]
    #pdb.set_trace()

    keep = np.where(np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    print('Removing {} HECATE objects with no diameters.'.format(len(hecate)-len(keep)))
    #keep = np.where(np.isfinite(hecate['BT']) * np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    #print('Removing {} HECATE objects with no diameters or magnitudes estimate.'.format(len(hecate)-len(keep)))
    hecate = hecate[keep]
    hecate['BA'] = hecate['R2'] / hecate['R1']

    # Match the catalogs, first by PGC.
    dwarfs_excluded = {
        'SagittariusdSph': 4689212,
        'SegueI': 4713559,
        'UrsaMajorII': 4713555,
        'BootesII': 4713552,
        'SegueII': 4713565,
        'Willman1': 4713556,
        'BootesI': 4713553,
        'Draco': 60095,
        'UrsaMinor': 54074,
        'SextansI': 88608,
        'UrsaMajorI': 4713554,
        'Hercules': 4713560,
        'LeoIV': 4713561,
        'LeoV': 4713563,
        'PiscesII': 5056949,
        'CanesVenaticiI': 4689223,
        'AndromedaXIV': 5056922,
        'AndromedaXIII': 5056925,
        'AndromedaII': 4601,
        'AndromedaXXIX': 5060430,
        'AndromedaXXII': 5057232,
        'AndromedaXVI': 5056927,
        'LeoT': 4713564,
        'ComaBerenices': -1, 
        'CanesVenaticiII': 4713558,
        'AndromedaXX': 5056920,
        'Antlia': 29194,
        'Carina': 19441,
        'AndromedaX': 5056921,
        'AndromedaIX': 4689222,
        'AndromedaXVII': 4608690,
        'AndromedaXXVII': 5057230,
        'AndromedaXXV': 5057228,
        'AndromedaI': 2666,
        'AndromedaIII': 2121,
        'AndromedaXV': 5056926,
        'AndromedaXII': 5056924,
        'AndromedaXI': 5056923,
        'AndromedaXXVI': 5057229,
        'AndromedaXIX': 5056919,
        'AndromedaXXI': 5057231,
        'AndromedaXVIII': 5056918,
        'AndromedaXXIV': 5057227,
        'AndromedaXXIII': 5057226,
        'AndromedaV': 3097824,
        'AndromedaVII': 2807155,
        'Aquarius': 65367,
        'Sculptor': 3589,
        'Fornax': 10074,}
    dwarfs_toadd = {
        'AndromedaVI': 2807158,
        'AndromedaXXVIII': 5060429,
        }
    for thisdwarf in dwarfs_toadd.keys():
        I = np.where(sga['GALAXY'] == thisdwarf)[0]
        if len(I) == 1:
            #print(f'Matching {thisdwarf}')
            sga['PGC'][I] = dwarfs_toadd[thisdwarf]

    openngc_toadd = {
        'IC0028': 169992,
        'IC0036': 138202,
        'IC0113': 3617669,
        'IC0233': 9622,    # incorrectly matches to CGCG388-033 rather than CGCG388-036 in Hyperleda
        'IC0254': 3642494, # incorrectly matches to NGC1065
        'IC0463': 3717953,
        'IC0495': 22841,
        'IC0694': 35326,
        'IC0729': 36627,
        'IC0828': 3797579,
        'IC0921': 2509643,
        'IC0931': 2508641,
        'IC1188B': 1533342,
        'IC1249': 59919,
        'IC1464A': 70345,
        'IC1586': 2813,
        'IC1632': 4205,
        'IC1640': 4299,
        'IC1726': 6441,
        'IC1758': 170024,
        'IC1798': 3637647,
        'IC2155': 4078729,
        'IC2186': 3089868, # incorrectly matches to IC2186 in Hyperleda
        'IC2249': 23202,
        'IC2519': 28660,
        'IC2614': 3764519,
        'IC2615': 33289,
        'IC2619': 33297,
        'IC2657': 3768035,
        'IC2676': 3471217,
        'IC2677': 4000604,
        'IC2690': 4272707,
        'IC2719': 3542421,
        'IC2753': 3471719,
        'IC2765': 1451814, # incorrectly matches to IC2769
        'IC2771': 4000783,
        'IC2775': 1410888,
        'IC2779': 1428682, # incorrectly matches to IC2779
        'IC2802': 1405555,
        'IC2807': 4278777,
        'IC2821': 3770960,
        'IC2838': 3090746,
        'IC2847': 3771421,
        'IC2858': 3771590,
        'IC2860': 3771626,
        'IC2886': 3543729,
        'IC2900': 5490323,
        'IC2909': 1394107,
        'IC2917': 1386736,
        'IC2946': 35984,
        'IC2993': 3088758, # incorrect coordinates / object in Hyperleda for IC2993
        'IC3110': 3088320,
        'IC3128B': 39557,
        'IC3179': 89585,
        'IC3249': 3787857,
        'IC3287': 4662912,
        'IC3304': 4325635,
        'IC3324': 3788758,
        'IC3345': 3789023,
        'IC3372': 89606,
        'IC3389': 3789672,
        'IC3396': 3789798,
        'IC3449': 89615,
        'IC3479': 89618,
        'IC3494': 1812401,
        'IC3528': 41882,
        'IC3558': 165253,
        'IC3565': 1787382,
        'IC3582': 1768338, # =WISEA J123636.95+261405.0; incorrect match in Hyperleda
        'IC3603': 3090633,
        'IC3610': 1790902,
        'IC3614': 1770479,
        'IC3649': 1642864,
        'IC3655': 1633163,
        'IC3657': 4337363,
        'IC3678': 1637920,
        'IC3723': 42914,
        'IC3751': 3088212,
        'IC3761': 1622809,
        'IC3771': 5168314,
        'IC3785': 3796270,
        'IC3817': 1676864,
        'IC3842': 3088021,
        'IC3847': 86330,
        'IC3870': 1668852,
        'IC3872': 3798227,
        'IC3897': 3088119,
        'IC3898': 3088328,
        'IC3928': 2165833,
        'IC3945': 3799582,
        'IC3948': 1698944,
        'IC3954': 3799842,
        'IC3978': 4350039,
        'IC3994': 4350163,
        'IC4018': 3800150,
        'IC4025': 3800326,
        'IC4031': 3800266,
        'IC4063': 6032708,
        'IC4085': 3088120,
        'IC4087': 3800931,
        'IC4110': 3801248,
        'IC4140': 3801648,
        'IC4147': 4662909,
        'IC4162': 6400595,
        'IC4184': 3088122,
        'IC4277': 4662915,
        'IC4284': 2287260,
        'IC4285': 2287732,
        'IC4300': 47912,
        'IC4516': 53274,
        'IC4568': 55746,
        'IC5126': 3947737,
        'IC5153': 3954514,
        'IC5299': 3978734,
        'IC5307': 214932, #=IC5306 in Hyperleda, which is wrong; actually WISEA J231822.02+101408.5
        'IC5341': 71981,
        'NGC0382': 3981, # terrible coordinates!
        'NGC0396': 99944,
        'NGC0526A': 5120, #=NGC0526
        'NGC0742': 7264,
        'NGC0826': 8230,
        'NGC1392': 13383,
        'NGC2288': 19714,
        'NGC2687A': 25031,
        'NGC2735A': 25402,
        'NGC3099': 29087,
        'NGC3439': 32634,
        'NGC4465': 41157,
        'NGC5581': 51282,
        'NGC5615': 51435,
        'NGC5679C': 52129, # confusion in the viewer
        'NGC5763': 52905,
        'NGC5896': 54367,
        'NGC6027D': 56580,
        'NGC6099': 57640,
        'NGC6141': 3498497,
        'NGC6452': 60876,
        'NGC6534': 61126,
        'NGC7405': 69907,
        'NGC7551': 3978375,
        'NGC7577': 70947,
        'NGC7598': 71011
        }
    check = []
    for thisgal in openngc_toadd.keys():
        I = np.where(sga['GALAXY'] == thisgal)[0]
        check.append(I)
        sga['PGC'][I] = openngc_toadd[thisgal]
    check = np.hstack(check)
    #pdb.set_trace()

    indx_sga, indx_hecate = [], []
    for I, pgc in enumerate(hecate['PGC']):
        J = np.where(pgc == sga['PGC'])[0]
        #if pgc == 70761:
        #    pdb.set_trace()
        if len(J) > 1:
            pdb.set_trace()
        if len(J) == 1:
            indx_hecate.append(I)
            indx_sga.append(J)
    indx_hecate = np.hstack(indx_hecate)
    indx_sga = np.hstack(indx_sga)
    print('Matched {}/{} HECATE galaxies to the SGA based on PGC number.'.format(
        len(indx_hecate), len(hecate)))

    # classify based on the montage visual inspections
    hecate['SGA_NOTES'] = np.zeros(len(hecate), int) # np.zeros(len(hecate), 'U20')
    for thisdwarf in dwarfs_excluded.keys():
        I = np.where(hecate['PGC'] == dwarfs_excluded[thisdwarf])[0]
        if len(I) != 1:
            #print(f'Skipping {thisdwarf}')
            #pdb.set_trace()
            pass
        hecate['SGA_NOTES'][I] += 2**0 # intentionally excluded dwarf

    spurgal = [
        # >1.6 arcmin
        'SDSSJ075442.90+472212.6', 'SDSSJ074540.08+204602.5', 'SDSSJ112014.08+092415.9',
        'SDSSJ025709.46+002421.5', '[IBG2003]J130047+280534', 'SDSSJ023647.34-001301.0',
        '[CTM2011]1040263', 'LAMOSTJ085931.49+445506.4', #'SDSSJ1049+5103',
        'SDSSJ075442.90+472212.6', 'PGC3097827', 'GAMA575344', 'SDSSJ041004.59-045626.3', 
        'SDSSJ095021.71+451957.5', 'AGC125044', # AGC125044 is Cirrus!
        'SDSSJ152444.99+401648.2', 'SDSSJ112535.23+542314.3', 
        # 1.0-1.6 arcmin
        'SDSSJ012626.40-002539.4', 'SDSSJ012651.26+203017.0', 'GAMA418176', 
        'SDSSJ144554.93+003437.6', '[RG2008]J163025.15+395443.9', 'GAMA177469',
        'SDSSJ232735.95+313026.5', 'PGC2800817', 'SDSSJ155520.30+091146.4',
        'PGC086618']
    #print('Flagging {} spurious HECATE galaxies with >1 arcmin.'.format(len(spurgal)))
    for gal in spurgal:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**1 # spurious in Hecate

    # real, but (sometimes very) wrong diameter; should be added to the catalog
    wrongdiam = [
        # >1.6 arcmin
        'AGC749279', 'AGC102561', 'SDSSJ004535.04-011221.9', 'PGC029167', 
        'SDSSJ111332.35+225056.9', 'PGC012625', 'PGC018515', 'SDSSJ161534.10+192734.8',
        'AGC334637', 'AGC336814', 'SDSSJ220611.97+010300.5', 'AGC113894',
        '2MASXJ07271454+5256550', 'PGC002635', 'PGC059944', 
        'PGC4080601', 
        # 1.0-1.6 arcmin
        'PGC055315', 'GAMA143116', 'PGC040476', 'SDSSJ031229.59+000242.1', 
        'AGC268225', 'GAMA086047', 'SDSSJ134211.37+180153.6', 'SDSSJ124959.36+451011.2', 
        'SDSSJ114345.66+661335.7', 'AGC238692', 'SDSSJ160116.48+185821.3', 
        'SDSSJ094353.03+490037.7', 'AGC188957', 'AGC225847', 'AGC336486', 
        'SDSSJ032310.22-004407.9', 'AGC215425', 'AGC189323', 'SDSSJ100519.69+511038.3',
        'AGC267971', 'SDSSJ031929.80+003938.7', 'SDSSJ001842.92+003016.4',
        'AGC323553', 'SDSSJ131641.09+301454.4', 'SDSSJ103917.89+372810.6', 
        'AGC322201', 'SDSSJ092603.64+560915.5', 'PGC138144', 'AGC333267',
        'AGC334490', 'SDSSJ095034.31+300927.5', 'AGC333442', 'LAMOSTJ012612.76+294146.3',
        'SDSSJ230314.76+045751.4', 'PGC052336', '[RG2008]J162824.61+392054.6',
        'SDSSJ162256.84-004843.5', 'PGC019078', 'SDSSJ144751.43+172337.1', 
        'ESO474-017', 'PGC4677061', 'PGC061508', 'SDSSJ145746.73-003828.8',
        'PGC015227', 'SDSSJ160959.42+264326.8', 'SDSSJ101821.81+144859.3',
        'WINGSJ011321.46+001504.1']
    #print('Flagging {} HECATE galaxies with incorrect (over-estimated) diameters >1 arcmin.'.format(len(wrongdiam)))
    for gal in wrongdiam:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**2 # very wrong diameter in Hecate

    shred = [
        # >1.6 arcmin
        'LAMOSTJ013040.21-035637.1', 'LAMOSTJ124211.85+323232.3', 'SDSSJ100818.18+315206.6',
        'SDSSJ131318.46+361210.6', 'PGC014118', 'SDSSJ114347.41+195830.2', 'LAMOSTJ142026.93+351032.3',
        'SDSSJ002024.55+004917.5', 'SDSSJ134748.65+402918.7', 'LAMOSTJ005442.06+213126.7',
        'SDSSJ231412.61+133454.6', 'LAMOSTJ003719.70+290838.1', 'SDSSJ231445.28+052457.9',
        'SDSSJ121855.02+142445.5', 'LAMOSTJ122300.91+155115.8', 
        # 1.0-1.6 arcmin
        'LAMOSTJ112914.16+203452.0', 'SDSSJ131238.07+123534.5', 'NGC6166B', 'SDSSJ143001.69+362129.5',
        'PGC095735', 'SDSSJ110310.51+275851.0', 'PGC032137', 
        'SDSSJ023038.41-034915.6', 'EVCC2264', 'PGC047447', '2MASXJ03422921-1328208',
        'SDSSJ131239.57+123645.0', 'LAMOSTJ091102.92+132455.3',
        'LAMOSTJ020628.06+270207.9', 'SDSSJ094829.55+332459.3', 'PGC3099123',
        '6dFJ0122428-363451', 'PGC093084', '2MASXJ21130957-5826044',
        'SDSSJ123421.43+081425.7', 'PGC3295899', 'SDSSJ115338.84+432720.0', 'PGC200231',
        '2MASXJ10330652-2625169', 'SDSSJ144822.72+182112.2', 'SDSSJ075237.34+502415.6',
        'SDSSJ145256.78+164334.8', '2MASXJ16080647+2529073', 'LAMOSTJ090559.16+184546.3',
        '2MASXJ14574467-0722033', 
        'SDSSJ152132.22+391207.0', '2MASXJ09474970+1551068', 'SDSSJ164802.45+261234.3',
        'PGC3084812', 'LAMOSTJ021112.67+254848.2', 'SDSSJ082027.55+564457.1',
        'PGC093106', 'GAMA084601', 'SDSSJ211444.79+105220.5', 'SDSSJ151806.36+424438.6', 
        'SDSSJ163813.00+415623.0', 'SDSSJ080138.73+154249.2',
        'SDSSJ082648.24+202140.3', 'PGC200388', 'PGC052728', '2MASXJ05571929-5222215',
        'SDSSJ014932.34+323510.2', 'SDSSJ132202.37+384343.7', 'SDSSJ155722.48+470943.9',
        'SDSSJ115742.61+321702.7', 'SDSSJ133955.41+282344.3', 'SDSSJ081200.34+192147.4',
        'SDSSJ140021.15+385504.2', 'SDSSJ111523.25+555826.6',
        'SDSSJ111523.25+555826.6', 'SDSSJ141013.85+481833.8', 'SDSSJ145736.82+295757.3',
        '2MASXJ21150892+1239317', 'SDSSJ122147.59+042938.4', 'LAMOSTJ091005.24+443651.3',
        'SDSSJ141843.21+214858.0', 'SDSSJ090919.38+330723.6', 'SDSSJ093654.40+374130.6',
        'NGC0664:[ZM98]0009', 'LAMOSTJ020913.56+253410.9']
    #print('Flagging {} HECATE galaxies as photometric shreds and >1 arcmin.'.format(len(shred)))
    for gal in shred:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**3 # photometric shred

    grzmissing = [
        # >1.6 arcmin
        'NGC2258', 'ESO567-026', 'NGC6555', 'NGC2889', 'ESO437-022', 'ESO108-021', 
        'ESO501-011', 'IC2586', 'NGC7485', 
        # 1.0-1.6 arcmin
        'PGC033167', 'ESO233-037', 'PGC035743', 'IC0416', 'UGC09668', 
        'PGC027066', 'ESO106-002', 'ESO567-010', 'UGC11581', 
        'ESO340-016', 'PGC065019', 'UGC03823', 'NGC6972', 'ESO437-040',
        'ESO501-024', 'ESO501-042', 'NGC2881', '2MASXJ03500035-0127578',
        'PGC032846', 'UGC00457', 'PGC018467', 'ESO340-019', 'PGC015573',
        'PGC027757', 'ESO342-012', 'ESO409-016', 'ESO437-029', 'ESO500-043',
        'ESO567-012', 'PGC027188', 'UGC10780', 'ESO344-003', '2MASXJ21094981-0850538',
        'PGC035744']
    #print('Flagging {} HECATE galaxies with missing LS/DR9 grz imaging and >1 arcmin.'.format(len(grzmissing)))
    for gal in grzmissing:
        I = np.where(hecate['OBJNAME'] == gal)[0]
        if len(I) != 1:
            pdb.set_trace()
        hecate['SGA_NOTES'][I] += 2**4 # missing grz coverage

    m_sga = sga[indx_sga]
    m_hecate = hecate[indx_hecate]

    miss_sga = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
    miss_hecate = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]

    # quick QA of the separation for PGC-matched and PGC-non-matched galaxies
    c_m_hecate = SkyCoord(m_hecate['RA']*u.deg, m_hecate['DEC']*u.deg)
    c_m_sga = SkyCoord(m_sga['RA']*u.deg, m_sga['DEC']*u.deg)
    _, m_sep2d, _ = c_m_hecate.match_to_catalog_sky(c_m_sga)
    print('Mean and max separation between {} PGC-matched galaxies is {:.3f}+/-{:.3f}, {:.3f} arcsec.'.format(
        len(m_hecate), np.mean(m_sep2d.arcsec), np.std(m_sep2d.arcsec), np.max(m_sep2d.arcsec)))
    print('Objects where separation >10 arcsec.')
    I = m_sep2d.arcsec > 10
    info = m_sga[I]['GALAXY', 'PGC', 'RA', 'DEC', 'D26']
    info['SEP'] = m_sep2d.arcsec[I]
    print(info[np.argsort(info['SEP'])[::-1]])

    c_miss_hecate = SkyCoord(miss_hecate['RA']*u.deg, miss_hecate['DEC']*u.deg)
    c_miss_sga = SkyCoord(miss_sga['RA']*u.deg, miss_sga['DEC']*u.deg)
    _, miss_sep2d, _ = c_miss_hecate.match_to_catalog_sky(c_miss_sga)
    
    pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-sga2020-separation.png')
    print('Writing {}'.format(pngfile))
    fig, ax = plt.subplots(figsize=(10, 7))
    _ = ax.hist(np.log10(m_sep2d.arcsec), bins=75, label='PGC-matched')
    _ = ax.hist(np.log10(miss_sep2d.arcsec), bins=75, alpha=0.5, label='PGC not-matched')
    ax.set_xlabel(r'$\log_{10}\,(\mathrm{HECATE-SGA\ Separation})$ (arcsec)')
    ax.set_ylabel('Number of Galaxies')
    ax.set_yscale('log')
    ax.axvline(x=np.log10(10), ls='--', color='k')
    ax.legend(fontsize=14)
    fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95, left=0.17)
    fig.savefig(pngfile)#, bbox_inches='tight')
    plt.close(fig)

    # now try to match a few more using coordinates
    rad = 3.0
    if False:
        from pydl.pydlutils.spheregroup import spherematch
        indx_miss_hecate, indx_miss_sga, sep = spherematch(miss_hecate['RA'], miss_hecate['DEC'], miss_sga['RA'], 
                                                           miss_sga['DEC'], rad/3600., maxmatch=1)
    else:
        indx_miss_hecate, indx_miss_sga, d2d, _ = c_miss_sga.search_around_sky(c_miss_hecate, rad*u.arcsec)
    print('Found {:,d}/{:,d} additional SGA-HECATE matches within {} arcsec.'.format(
        len(indx_miss_hecate), len(miss_hecate), rad))
    assert(len(indx_hecate) == len(np.unique(indx_hecate)))

    m_sga = vstack((m_sga, miss_sga[indx_miss_sga]))
    m_hecate = vstack((m_hecate, miss_hecate[indx_miss_hecate]))

    miss_hecate.remove_rows(indx_miss_hecate)
    miss_sga.remove_rows(indx_miss_sga)

    print('Final sample: {}/{} ({:.2f}%) HECATE-SGA matches.'.format(
        len(m_hecate), len(hecate), 100*len(m_hecate)/len(hecate)))

    # get the raw and corrected fraction of non-matches as a function of SERSIC_TH50
    lograd = np.log10(2*hecate['R1'])
    match_lograd = np.log10(2*m_hecate['R1'])
    lograd_corrected = np.log10(2*hecate['R1'][hecate['SGA_NOTES'] == 0])
    minrad, maxrad, drad = -1.4, 1.2, 0.2
    ##minrad, maxrad = np.min(lograd), np.max(lograd)

    nhist = int(np.ceil((maxrad - minrad) / drad))
    #histobins = np.histogram_bin_edges(match_lograd, bins=nhist, range=(minrad, maxrad))
    histobins = np.array([-1.4, -1.2, -1. , -0.8, -0.6, -0.4,
                          -0.2, 0., 0.2, 0.4, 0.6, 0.8, 1., 1.2])
    #histobins = np.array([-1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4,
    #                      -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,
    #                      0.8,  0.9,  1. ,  1.1,  1.2,  1.3])
    bins = histobins[:-1]

    #bins = np.arange(minrad, maxrad, drad) # bin left edges
    numer, _ = np.histogram(match_lograd, bins=histobins)
    denom, _ = np.histogram(lograd, bins=histobins)
    #denom, _ = np.histogram(lograd, bins=len(bins), range=(minrad, maxrad+drad))
    denom_corrected, _ = np.histogram(lograd_corrected, bins=histobins)

    good = denom > 0
    xfrac = bins[good]
    yfrac = numer[good] / denom[good] 
    yfrac_corrected = numer[good] / denom_corrected[good] 
    for ii, (bb, nn, dd, dd_corr) in enumerate(zip(bins, numer, denom, denom_corrected)):
        print(bb, 10**bb, nn, dd, nn/dd, dd-nn, dd_corr, nn/dd_corr, dd-nn, dd_corr-nn)
        # np.sum((lograd>bb)*(lograd<(bb+drad))))

    # --------------------------------------------------
    # HECATE galaxies not in the SGA
    #_logradcut = 0.2
    #I = bins >= _logradcut
    #print('There are {} HECATE galaxies not in the SGA larger than {:.1f} arcmin.'.format(
    #    np.sum(denom[I]-numer[I]), 10**_logradcut))
    logradcut = 0.0

    hecate_notin_sga = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]
    srt = np.argsort(hecate_notin_sga['R1'])[::-1]
    hecate_notin_sga = hecate_notin_sga[srt]

    #print('Flagging {} HECATE galaxies which are intentionally-excluded dwarfs.'.format(
    #    np.sum(hecate_notin_sga['SGA_NOTES'] & 2**0 != 0)))

    I = np.log10(2 * hecate_notin_sga['R1']) >= logradcut
    J = (hecate_notin_sga['SGA_NOTES'] == 0) * (np.log10(2 * hecate_notin_sga['R1']) >= logradcut)

    Itot = np.log10(2 * hecate['R1']) >= logradcut
    Jtot = (hecate['SGA_NOTES'] == 0) * (np.log10(2 * hecate['R1']) >= logradcut)

    print('There are {}/{} ({:.2f}%) raw -- {}/{} ({:.2f}%) corrected -- HECATE galaxies not in the SGA larger than {:.1f} arcmin.'.format(
        np.sum(I), np.sum(Itot), 100*np.sum(I)/np.sum(Itot), np.sum(J), np.sum(Jtot), 100*np.sum(J)/np.sum(Jtot), 10**logradcut))

    #I = np.log10(2 * hecate_notin_sga['R1']) >= logradcut
    I = (np.log10(2 * hecate_notin_sga['R1']) >= logradcut) * (np.log10(2 * hecate_notin_sga['R1']) <= 0.2)
    qa = hecate_notin_sga[I]['PGC', 'R1', 'RA', 'DEC', 'SGA_NOTES', 'OBJNAME']
    qa = qa[np.argsort(qa['R1'])] # smallest to biggest
    qa['URL'] = ['https://www.legacysurvey.org/viewer-desi?ra={}&dec={}&layer=ls-dr9&zoom=14&sga-parent&sga'.format(
        ra, dec) for ra, dec in zip(qa['RA'], qa['DEC'])]
    #qa[::-1][198:]

    print('Galaxies with 2*R1 > 1 arcmin in HECATE missing from the SGA:')
    for bit, label in zip([1, 2, 4, 8, 16], ['Intentionally excluded dwarfs: ',
                                             'Spurious galaxies: ',
                                             'Incorrect diameter: ',
                                             'Photometric shred: ',
                                             'Gap in grz coverage: ']):
        print('  Bit {}: {} {}'.format(bit, label, np.sum(np.log10(2 * hecate_notin_sga[hecate_notin_sga['SGA_NOTES'] == bit]['R1'].data) >= 0)))

    # investigate the galaxies which are in the SGA but not in Hecate
    if False:
        sga_notin_hecate = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
        srt = np.argsort(sga_notin_hecate['D26'])[::-1]
        sga_notin_hecate = sga_notin_hecate[srt]['SGA_ID', 'GALAXY', 'RA', 'DEC', 'PGC', 'D25_LEDA', 'D26', 'Z_LEDA']
    
        I = ((sga_notin_hecate['Z_LEDA'] > -1) * (sga_notin_hecate['Z_LEDA'] <= 0.047))
        Itot = ((sga['Z_LEDA'] > -1) * (sga['Z_LEDA'] <= 0.047))
        print(np.sum(I), np.sum(Itot), np.sum(I) / np.sum(Itot))
        sga_notin_hecate[I]

    remake_montage = False
    if remake_montage:
        montagedir = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga')
        if not os.path.isdir(montagedir):
            os.makedirs(montagedir, exist_ok=True)
        
        pixscale = 1.0 # 0.262
        barlen = np.ceil(60 / pixscale) # [pixels]
        barlabel = '' # '30 arcsec'

        coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)

        # split into diameter bins
        for ibin in np.arange(len(bins)):
            minbin, maxbin = histobins[ibin], histobins[ibin+1]
            print(ibin, minbin, maxbin)
            if minbin < logradcut:
                continue

            binlabel = '{:.1f}-{:.1f}arcmin'.format(10**minbin, 10**maxbin)

            dhecate = np.log10(2 * hecate_notin_sga['R1'])
            if ibin == len(bins)-1:
                B = np.where(dhecate >= minbin)[0]
            else:
                B = np.where((dhecate >= minbin) * (dhecate < maxbin))[0]

            if len(B) == 0:
                pdb.set_trace()

            if len(B) >= 100:
                ncol, nrow = 10, 10
            elif len(B) >= 49 and len(B) < 100:
                ncol, nrow = 7, 7
            elif len(B) >= 25 and len(B) < 49:
                ncol, nrow = 5, 5
            else:
                ncol, nrow = 5, 5

            ngal = ncol * nrow

            hecate_notin_sga_bin = hecate_notin_sga[B]

            # find near SGA sources, if any
            coord_hecate_notin_sga = SkyCoord(ra=hecate_notin_sga_bin['RA']*u.deg, dec=hecate_notin_sga_bin['DEC']*u.deg)
        
            # split into multiple pages
            Isplit = np.array_split(np.arange(len(hecate_notin_sga_bin)), np.ceil(len(hecate_notin_sga_bin)/ngal).astype(int))
            npage = len(Isplit)
            print(f'Splitting into {npage} pages with {ngal} galaxies per page.')

            for ipage, I in enumerate(Isplit):
                print('Working on page {}/{} with {} galaxies.'.format(ipage+1, npage, len(I)))

                sga_close = []
                for coord_hecate_notin_sga1, diam in zip(coord_hecate_notin_sga[I], 2*60*hecate_notin_sga_bin['R1'][I]):
                    sep = coord_hecate_notin_sga1.separation(coord_sga)
                    close = sep.arcsec < 2*diam
                    if np.any(close):
                        sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
                    else:
                        sga_close.append(Table())

                pngfiles = []
                for onegal, onesga in zip(hecate_notin_sga_bin[I], sga_close):
                    #pdb.set_trace()
                    jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['OBJNAME']))
                    width = int(2.5 * 2*onegal['R1']*60 / pixscale)
                    if width == 0:
                        pdb.set_trace()

                    if not os.path.isfile(jpgfile):
                        urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                            onegal['RA'], onegal['DEC'], pixscale, width, width)
                        cmd = f'wget -q -O {jpgfile} {urlfile}'
                        print(cmd)
                        subprocess.call(cmd.split())
            
                    pngfile1 = jpgfile.replace('.jpg', '.png')
                    if not os.path.isfile(pngfile1):
                        with Image.open(jpgfile) as colorimg:
                            imgsz = colorimg.size
            
                            hdr = fits.Header()
                            hdr['NAXIS'] = 2
                            hdr['NAXIS1'] = imgsz[0]
                            hdr['NAXIS2'] = imgsz[0]
                            hdr['CTYPE1'] = 'RA---TAN'
                            hdr['CTYPE2'] = 'DEC--TAN'
                            hdr['CRVAL1'] = onegal['RA']
                            hdr['CRVAL2'] = onegal['DEC']
                            hdr['CRPIX1'] = imgsz[0]/2+0.5
                            hdr['CRPIX2'] = imgsz[0]/2+0.5
                            hdr['CD1_1'] = -pixscale/3600
                            hdr['CD1_2'] = 0.0
                            hdr['CD2_1'] = 0.0
                            hdr['CD2_2'] = +pixscale/3600
                            wcs = WCS(hdr)
                    
                            try:
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                                                    onegal['PA'], 2*onegal['R1']*60, 
                                                    pixscale, color='red', linewidth=2)
                            except:
                                pdb.set_trace()

                            # add the SGA sources, if any
                            if len(onesga) > 0:
                                for onesga1 in onesga:
                                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                                        color='dodgerblue', linewidth=2)
            
                            print(f'Writing {pngfile1}')
                            colorimg.save(pngfile1)
            
                        label = onegal['OBJNAME']
                        addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
                        #pdb.set_trace()
            
                    pngfiles.append(pngfile1)
            
                pngfile = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga-{}-{:02d}.png'.format(binlabel, ipage))
                print('Writing {}'.format(pngfile))
            
                cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 512x512 '.format(ncol, nrow)
                cmd = cmd+' '.join([pngf for pngf in pngfiles])
                cmd = cmd+' {}'.format(pngfile)
                print(cmd)
                os.system(cmd)        
    
                #pdb.set_trace()
    # --------------------------------------------------

    # make the QA -
    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        elif (x < 0) and (x >= -1):
            return '{:.1f}'.format(10**x)
        else:
            return '{:.2f}'.format(10**x)

    fig, ax = plt.subplots(figsize=(10, 7))

    xlim = (minrad, maxrad)
    ylim = (6, 26)
    I = np.isfinite(hecate['BT'])
    corner.hist2d(np.log10(2*hecate['R1'][I]), hecate['BT'][I],
                  levels=[0.1, 0.25, 0.5, 0.75, 0.95, 0.99],
                  #levels=[0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                  bins=75, smooth=True, ax=ax, color='k', #mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': 'k', 'alpha': 1.0, 'ms': 3, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k', 'alpha': 0.5}
                 )
    ax.set_xlabel(r'$\log_{10}\,(2\times R_{1})$ (HECATE, arcmin)')
    ax.set_ylabel(r'$b_{\mathrm{t}}$ (Vega, HECATE)')
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(2))
    ax.xaxis.set_major_formatter(major_formatter)
    ax.set_xticks(np.log10([0.05, 0.2, 0.5, 1, 2, 5, 9, 15]))
    ax.margins()
    
    ax2 = ax.twinx()
    for ii, bb in enumerate(bins):
        #ax2.axvline(x=bb, color='orange', ls='-', alpha=1)
        if bb > -10:#-0.6:
            ax2.text(xfrac[ii]+drad/2, yfrac_corrected[ii]+0.03, 
                     '{:,d}'.format(denom[ii]), ha='center', va='bottom', 
                     alpha=1.0, fontsize=10)
    #ax2.axvline(x=np.log10(20/60), color='gray', ls='-', alpha=0.7)
    #ax2.axvline(x=np.log10(30/60), color='gray', ls='-', alpha=0.7)
    ax2.axhline(y=1.0, ls='-', lw=2, color='gray', alpha=0.7)
    ax2.step(xfrac+drad, yfrac_corrected, color=colors[4], ls='-', lw=3, where='pre',
             label='Corrected Fraction')
    ax2.step(xfrac+drad, yfrac, color=colors[3], ls='--', lw=3, where='pre', 
             label='Raw Fraction')
    ax2.set_ylim(0, 1.1)
    hh, ll = ax2.get_legend_handles_labels()
    ax2.legend([hh[1], hh[0]], [ll[1], ll[0]], loc='lower right', fontsize=14) # frameon=False, 
    #ax2.legend(loc='lower right', fontsize=14)
    ax2.margins()
    ax2.set_ylabel('Fraction of SGA-HECATE Matches', rotation=270, labelpad=35)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.subplots_adjust(bottom=0.15, right=0.85, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--sample-montage', action='store_true')
    parser.add_argument('--hyperleda-rejects', action='store_true')
    parser.add_argument('--sky', action='store_true')
    parser.add_argument('--size-mag', action='store_true')
    parser.add_argument('--sga-properties', action='store_true')
    parser.add_argument('--redshifts', action='store_true')
    parser.add_argument('--coordinates', action='store_true')
    parser.add_argument('--sga-vs-hyperleda', action='store_true')
    parser.add_argument('--sga-vs-wxsc100', action='store_true')
    parser.add_argument('--table-dwarfs', action='store_true')
    #parser.add_argument('--rich-groups', action='store_true')
    parser.add_argument('--nsa-completeness', action='store_true')
    parser.add_argument('--hecate-completeness', action='store_true')
    parser.add_argument('--z0mgs-completeness', action='store_true')
    parser.add_argument('--sb-mag', action='store_true')
    parser.add_argument('--sbmontage', action='store_true')
    #parser.add_argument('--sbmontage-gallery', action='store_true')
    args = parser.parse_args()

    #if False:
    #    galaxy, galaxydir = get_galaxy_galaxydir(sample)
    #    for onegal in sample:
    #        _galaxy, _ = get_galaxy_galaxydir(onegal)
    #        print(_galaxy, onegal[RACOLUMN], onegal[DECCOLUMN], onegal[DIAMCOLUMN])

    sga = legacyhalos.SGA.read_sga2020(ext='ELLIPSE')

    # Table
    if args.table_dwarfs:
        table_dwarfs(tex='mwdwarfs.tex')
            
    # Fig 1 - sample montage
    if args.sample_montage:
        #tractor = legacyhalos.SGA.read_sga2020(ext='TRACTOR')
        fig_sample_montage(sga, seed=1, png='sample-montage.png')
        
    # Fig 2 - Hyperleda junk rejected by visual inspection
    if args.hyperleda_rejects:
        fig_hyperleda_rejects(sga, png='hyperleda-rejects.png')
        
    # Figs 3 & X - spatial distribution on the sky
    if args.sky:
        #I = sga['D26'] > 1
        #fig_sky(sga[I], clip_hi=10, mloc=1, max_bin_area=10, png='sga-2020-sky-1arcmin.png')
        #fig_sky(sga, max_bin_area=10, png='sga-2020-sky-lores.png')

        fig_sky(sga, png='sga-2020-sky.png')

        parent = legacyhalos.SGA.read_sample(preselect_sample=False)
        #parent = fits_table(os.path.join(legacyhalos.io.legacyhalos_dir(), 'sample', 'v3.0', 'SGA-parent-v3.0.fits'))
        fig_sky(parent, clip_lo=3, mloc=20, png='sga-2020-parent-sky.png')
        
    # Fig X - bivariate scatterplot of size vs magnitude
    if args.size_mag:
        fig_size_mag(sga, png='parent-size-mag.png', leda=True)

    # Fig X - 
    if args.sga_properties:
        fig_sga_properties(sga, png='sga-properties.png')

    if args.redshifts:
        fig_redshifts(sga, png='redshifts.png')#, png_zhist='redshifts-zhist.png')
        #fig_redshifts(sga, png_sky='redshifts-sky.png', png_zhist='redshifts-zhist.png')

    if args.coordinates:
        fig_coordinates(sga, png='coordinates.png')

    if args.sga_vs_hyperleda:
        fig_sga_vs_hyperleda(sga, png='sga-vs-hyperleda.png')

    if args.sga_vs_wxsc100:
        fig_sga_vs_wxsc100(sga, png='sga-vs-wxsc100.png')

    # Fig - completeness against the NSA
    if args.nsa_completeness:
        fig_nsa_completeness(sga, png='nsa-completeness.png')
    
    # Fig - completeness against HECATE
    if args.hecate_completeness:
        fig_hecate_completeness(sga, png='hecate-completeness.png')

    # Fig - completeness against HECATE
    if args.z0mgs_completeness:
        fig_z0mgs_completeness(sga, png='z0mgs-completeness.png')

    # Fig - bivariate scatterplot of surface brightness vs magnitude
    if args.sb_mag:
        #parent = legacyhalos.SGA.read_sample(preselect_sample=False)
        fig_sb_mag(sga, png='sga-sb-mag.png')
    
    # Fig - SB montages
    if args.sbmontage:
        sample = legacyhalos.SGA.read_sga2020(galaxylist='NGC5016')
        fig_sbmontage(sample, igal=0, colorlim=(-0.5, 1.5), png='NGC5016-sbmontage.png')
        pdb.set_trace()
        sample = legacyhalos.SGA.read_sga2020(galaxylist='PGC193192')#, primary=False)
        fig_sbmontage(sample, igal=1, colorlim=(0.0, 1.5), png='PGC193199-sbmontage.png')

        #for gal in galaxy:
        #    fig_surface_brightness(sample, thisgalaxy=gal, png='surface_brightness_{}.png'.format(gal))
        #fig_surface_brightness(sample, thisgalaxy='0000195-052316929', png='surface_brightness.png')
        #fig_surface_brightness(sample, thisgalaxy='0001129-034040952', png='surface_brightness.png')

    ## Fig X - richest groups
    #if args.rich_groups:
    #    fig_rich_groups(sga, png='rich-groups.png')

    ## Fig - SB montage gallery
    #if args.sbmontage_gallery:
    #    if False:
    #        from astrometry.libkd.spherematch import match_radec
    #        saga = Table.read(os.path.join(os.getenv('HOME'), 'research', 'projects', 'SGA', 'sample', 'catalogs', 'saga_hosts.csv'))
    #        m1, m2, d12 = match_radec(sample['RA'], sample['DEC'], saga['RA'], saga['DEC'], 5/3600.0, nearest=True)
    #        out = sample[m1]
    #        out.write(os.path.join(figdir, 'saga.fits'), overwrite=True)
    #    else:
    #        #if False:
    #        sample = Table.read(os.path.join(figdir, 'saga.fits'))
    #        for onegal in sample[:45]:
    #            fig_sbmontage_gallery(onegal, png='gallery/sbmontage-{}.png'.format(onegal['GALAXY']))
    #        #else:

if __name__ == '__main__':
    main()
